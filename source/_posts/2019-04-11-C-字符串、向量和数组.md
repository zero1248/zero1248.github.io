---
title: C++ 字符串、向量和数组
date: 2019-04-11 23:54:37
tags:
    - 编程语言
    - C++
---

---

《C++ primer》笔记

---
### 一、命名空间的 using 声明

1、若不用 using 声明命名空间 std，使用库函数需要 std::cin 的形式。

2、头文件不应包含 using 声明。

<!--more-->

3、using 的两种形式：
```
using namespace std // 可使用命名空间的所有对象
using std::cin // 只能使用 cin，其他仍加 std::
```

---

### 二、标准库类型 string

1、标准库类型 string 表示可变长的字符序列，使用 string 类型必须先包含 string 头文件。

2、初始化 string 对象的方式
拷贝初始化
直接初始化
```
string s1     // 默认初始化，s1 是一个空串
string s2(s1)  // s2 是 s1 的副本
strings2=s1  // 等价于 s2(s1)，s2 是 s1 的副本 
string s3("value") // s3 是字面值“value”的副本，除了字面值最后的那个空字符外
string s3="value"  // 等价于 s3("value")，s3 是字面值"value"的副本
string s4(n，'c') // 把 s4 初始化为由连续 n 个字符 c 组成的串
```

3、string对象上的操作

| os << s        | 将 s 写到输出流 os 当中，返回 os                     |
| -------------- | ---------------------------------------------------- |
| is >> s        | 从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is  |
| getline(is, s) | 从 is 中读取一行赋给 s，返回 is                      |
| s.empty()      | s 为空返回 true，否则返回 false                      |
| s.size()       | 返回 s 中字符的个数                                  |
| s[n]           | 返回 s 中第 n 个字符的引用，位置 n 从 0 计起         |
| s1 + s2        | 返回 s1 和 s2 连接后的结果                           |
| s1 = s2        | 用 s2 的副本代替 s1 中原来的字符                     |
| s1 == s2       | 如果 s1 和 s2 中所含的字符完全一样，则它们相等；     |
| s1 != s2       | string 对象的相等性判断对字母的大小写敏感            |
| <，<=，>，>=   | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感 |

4、string 会自动忽略输入流开头的空白，从第一个真正的字符开始读起，直到遇见下一处空白为止。

5、使用 getline 可以保留输入流中的空白符。getline 遇到换行符才结束。结果中并不包含换行符。

6、size 函数返回一个 string::size_type 类型的值。size_type 是一个无符号整型数，因此不能在表达式中混用带符号数和无符号数。

7、string 对象可比较大小。

8、标准库允许把字符字面值和字符串字面值转换成 string。string 和字面值可以相加，但两个字符串字面值无法相加。

9、cctype 头文件中定义的一组标准库函数可以判断 string 中的单个字符。

10、C++ 兼容 C 语言的 <name.h> 头文件命名形式为 <cname>，<cname> 中定义的名字从属于 std 命名空间。

11、范围 for 语句可以处理 string对象中的单个元素。

12、访问 string 对象的单个字符有两种方式：下标，和迭代器。

---

###  三、标准库类型 vector

1、vector 表示对象的集合，其中所有对象的类型都相同。因为 vector “容纳着”其他对象，所以也叫容器。

2、使用 vector，必须包含 <vector>。

3、vector 是一个类模板。模板本身不是类或函数，可以将模板看作为编译器生成类或函数编写的一份说明。

4、编译器根据模板创建类或函数的过程称为实例化，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

5、引用不是对象，所以不存在包含引用的 vector。

6、某些编译器可能仍需以老式的声明语句来处理元素为vector的vector对象，如vector<vector<int> >。（两个>>之间有空格）

7、初始化 vector 对象的方法
| vector<T> v1              | v1 是一个空 vector，它潜在的元素是 T 类型的，执行默认初始化 |
| ------------------------- | ----------------------------------------------------------- |
| vector<T> v2(v1)          | v2 中包含有 v1 所有元素的副本                               |
| vector<T> v2=v1           | 等价于v2（v1），v2中包含有v1所有元素的副本                  |
| vector<T> v3(n，val)      | v3 包含了 n 个重复的元素，每个元素的值都是 val              |
| vector<T> v4(n)           | v4 包含了 n 个重复地执行了值初始化的对象                    |
| vector<T> v5{a, b, c...}  | v5包含了初始值个数的元素，每个元素被赋予相应的初始值        |
| vector<T> v5={a, b, c...} | 等价于v5{a, b, c...}                                        |

8、用花括号 {} 表示列表初始化，用 () 表示数量初始化

9、利用 vector 对象的 push_back 成员函数向其中添加元素。

10、不能使用下标形式添加元素。可用下标访问已存在元素。

确保下标合法的一种有效手段就是尽可能使用范围 for 语句。

---

### 四、迭代器

1、所有标准库容器都可以使用迭代器。string 也支持。

2、迭代器提供了对对象的间接访问。

3、有迭代器的类型都有返回迭代器的成员，分别是 begin 和 end。end 返回指向“尾后”元素的迭代器（尾元素的下一位置）。

4、标准迭代器的运算符。

5、拥有迭代器的标准库使用 iterator 和 const_iterator 来表示迭代器的类型。

6、迭代器运算。

---

### 五、数组

1、与 vector 不同的是，数组的大小确定不变。

2、定义数组必须制定类型，不能用 auto。

3、不存在引用的数组。

4、不允许用于拷贝和赋值的右值。

5、理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。

6、使用数组下标的时候，通常将其定义为 size_t 类型。

7、使用数组时，编译器一般会把它转换成指针。

8、指针也是迭代器。

9、C 风格的字符串尽量不要在 C++ 中使用，因为不方便，且容易引发程序漏洞。

10、允许使用以空字符结束的字符数组来初始化 string 对象或为 string 对象赋值。

在 string 对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在 string 对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

11、在 C++ 程序中应尽量使用 vector 和迭代器，避免使用内置数组和指针。尽量使用 string，避免使用 C 风格的基于数组的字符串。

---

### 六、多维数组

1、多维数组，即数组的数组。

2、要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

3、可用类型别名简化多维数组的指针

```
using int_array = int[4];
typedef int int_array[4];
```