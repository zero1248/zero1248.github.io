---
title: AXI slave 官方示例代码分析
tags:
  - FPGA
  - AXI
abbrlink: ca088436
date: 2022-03-16 17:35:00
---

按照通道对信号进行分类，以 always 块为单位对代码进行解读。但是代码中有写地方没有对通道进行严格的划分，存在一个 always 块中对两个通道的信号或寄存器进行操作的情况。

<!--more-->

AXI 的 5 个通道中，master 主控写地址、写数据和读地址三个通道，slave 主控写响应、读数据两个通道。

---

### 一、写地址通道（AW）

#### 1.1、awready 逻辑

当主机将 awvalid 和 wvalid 都拉高后，从机将 awready 拉高。其他状态下，awready 保持常低。

```verilog
always @( posedge S_AXI_ACLK ) begin
    if ( S_AXI_ARESETN == 1'b0 ) begin
        axi_awready <= 1'b0;
        axi_awv_awr_flag <= 1'b0;
    end
    else begin
        if (~axi_awready && S_AXI_AWVALID && ~axi_awv_awr_flag && ~axi_arv_arr_flag) begin
            // slave is ready to accept an address and
            // associated control signals
            axi_awready <= 1'b1;
            axi_awv_awr_flag  <= 1'b1;
            // used for generation of bresp() and bvalid
        end
        else if (S_AXI_WLAST && axi_wready)
            // preparing to accept next address after current write burst tx completion
        begin
            axi_awv_awr_flag  <= 1'b0;
        end
        else begin
            axi_awready <= 1'b0;
        end
    end
end
```

axi_awv_awr_flag 拉高表示 awvalid 和 awready 都拉高了，用于写响应通道生成 bresp[] 和 bvalid。

axi_arv_arr_flag 和 axi_awv_awr_flag 都为低时，才将 awready 拉高，后面的 arready 也是二者都为低时才拉高，所以 awready 和 arready 只有一个能拉高。

一次成功的写传输后（WLAST 拉高一个周期），将 axi_awv_awr_flag 重新拉低。

#### 1.2 awaddr 地址锁存

当 awvalid 和 wvalid（为什么要包括 wvalid）都有效时，锁存 awaddr。

```verilog
always @( posedge S_AXI_ACLK ) begin
    if ( S_AXI_ARESETN == 1'b0 ) begin
        axi_awaddr <= 0;
        axi_awlen_cntr <= 0;
        axi_awburst <= 0;
        axi_awlen <= 0;
    end
    else begin
        if (~axi_awready && S_AXI_AWVALID && ~axi_awv_awr_flag) begin
            // address latching
            axi_awaddr <= S_AXI_AWADDR[C_S_AXI_ADDR_WIDTH - 1:0];
            axi_awburst <= S_AXI_AWBURST;
            axi_awlen <= S_AXI_AWLEN;
            // start address of transfer
            axi_awlen_cntr <= 0;
        end
        else if((axi_awlen_cntr <= axi_awlen) && axi_wready && S_AXI_WVALID) begin

            axi_awlen_cntr <= axi_awlen_cntr + 1;

            case (axi_awburst)
                2'b00: // fixed burst
                    // The write address for all the beats in the transaction are fixed
                    begin
                        axi_awaddr <= axi_awaddr;
                        //for awsize = 4 bytes (010)
                    end
                2'b01: //incremental burst
                    // The write address for all the beats in the transaction are increments by awsize
                    begin
                        axi_awaddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] <= axi_awaddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] + 1;
                        //awaddr aligned to 4 byte boundary
                        axi_awaddr[ADDR_LSB-1:0]  <= {ADDR_LSB{1'b0}};
                        //for awsize = 4 bytes (010)
                    end
                2'b10: //Wrapping burst
                    // The write address wraps when the address reaches wrap boundary
                    if (aw_wrap_en) begin
                        axi_awaddr <= (axi_awaddr - aw_wrap_size);
                    end
                else begin
                    axi_awaddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] <= axi_awaddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] + 1;
                    axi_awaddr[ADDR_LSB-1:0]  <= {ADDR_LSB{1'b0}};
                end
                default: //reserved (incremental burst for example)
                    begin
                        axi_awaddr <= axi_awaddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] + 1;
                        //for awsize = 4 bytes (010)
                    end
            endcase
        end
    end
end
```

（1）axi_awlen_cntr 用于。。。

（2）在 awvalid 拉高，但 awready 还没拉高的周期，完成以下操作：

- awaddr、awburst、awlen 锁存
- axi_awlen_cntr 复位（置零）

因为 awvalid 的拉高是早于 awready 的，且 awvalid 拉高时总线上的数据可认为是有效的，所以此时即便从机还没有准备好处理数据（对于 AW 通道就是地址和 burst 信息），也可以先把数据先缓存过来。

（3）wready 与 wvalid 握手成功（二者均为高电平），且 axi_awlen_cntr 小于等于 axi_awlen 时，首先将 axi_awlen_cntr 自增 1。然后根据 awburst 的操作类型分别执行不同的操作：

- fixed burst 类型，地址始终为 awaddr
- incremental burst 类型，地址的最低 2/3 位填 0，其他高位增加 1
- wrapping burst 类型
    - 先判断是否需要回卷，由 aw_wrap_en 表示，需要就回卷到起始位置
    - 不需要回卷就按照第二种方式进行递增

其中，需要填 0 的低位地址位数 ADDR_LSB，通过写数据通道的数据位宽除以 32 再加 1 得到，代码如下。例如，32bit 宽度的数据，地址需要每次增加 4 个 Byte，因此地址的低 2 位需要填 0，而 64bit 宽度的数据，地址需要每次增加 8 个 Byte，则地址的低 3 位需要填 0。数据位宽越大，地址低位填 0 的位数越多。

```verilog
 localparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32)+ 1;
```

aw_wrap_en 的计算是通过将 axi_awaddr 与 aw_wrap_size 按位与之后再与 aw_wrap_size 判等得到的，代码如下。

```verilog
assign  aw_wrap_size = (C_S_AXI_DATA_WIDTH/8 * (axi_awlen));
assign  aw_wrap_en = ((axi_awaddr & aw_wrap_size) == aw_wrap_size)? 1'b1: 1'b0;
```



---

### 二、写数据通道（W）

#### 2.1、wready 逻辑

与 awready 类似，当主机将 wvalid 和 wvalid （这一句翻译自代码中的注释，为什么要等awvalid？）都拉高后，从机将 wready 拉高。其他状态下，wready 保持常低。

```verilog
always @( posedge S_AXI_ACLK ) begin
    if ( S_AXI_ARESETN == 1'b0 ) begin
        axi_wready <= 1'b0;
    end
    else begin
        if ( ~axi_wready && S_AXI_WVALID && axi_awv_awr_flag) begin
            // slave can accept the write data
            axi_wready <= 1'b1;
        end
        //else if (~axi_awv_awr_flag)
        else if (S_AXI_WLAST && axi_wready) begin
            axi_wready <= 1'b0;
        end
    end
end
```

axi_awv_awr_flag 的产生代码和作用。。。

数据之类的用 assign？todo。。。



### 三、写响应通道（B）

3.1、写响应逻辑

当 wready 和 wvalid 拉高时，从机将写响应和响应有效信号拉高。这标志着接受了地址，且指示了此次写事务的状态。

```verilog
always @( posedge S_AXI_ACLK ) begin
    if ( S_AXI_ARESETN == 1'b0 ) begin
        axi_bvalid <= 0;
        axi_bresp <= 2'b0;
        axi_buser <= 0;
    end
    else begin
        if (axi_awv_awr_flag && axi_wready && S_AXI_WVALID && ~axi_bvalid && S_AXI_WLAST ) begin
            axi_bvalid <= 1'b1;
            axi_bresp  <= 2'b0;
            // 'OKAY' response
        end
        else begin
            if (S_AXI_BREADY && axi_bvalid)
                //check if bready is asserted while bvalid is high)
                //(there is a possibility that bready is always asserted high)
                begin
                    axi_bvalid <= 1'b0;
                end
        end
    end
end
```

写事务完成后才将 bvalid 拉高，且 bresp 设置为 "OKAY" 响应。

bvalid 拉高后，即等待主机拉高 bready。等写事务握手完成后将 bvalid 拉低。注释里写了存在 bready 为常高的可能。

这个代码的 else 里面，只有 if，没有 else，会不会漏掉什么情况，或产生 latch?前面的 if 是为了等待 bready 拉高，如果不加 else，意味着 bready 没有拉高的话，bvalid 会保持不变。

另外这里用到了 buser 信号，返回了一个常 0。



---

### 四、读地址通道（AR）

#### 4.1、arready 逻辑

当主机将 arvalid 拉高时，从机将 arready 拉高，其他时候保持常低（等待 arvalid 拉高）。

```verilog
always @( posedge S_AXI_ACLK ) begin
    if ( S_AXI_ARESETN == 1'b0 ) begin
        axi_arready <= 1'b0;
        axi_arv_arr_flag <= 1'b0;
    end
    else begin
        if (~axi_arready && S_AXI_ARVALID && ~axi_awv_awr_flag && ~axi_arv_arr_flag) begin
            axi_arready <= 1'b1;
            axi_arv_arr_flag <= 1'b1;
        end
        else if (axi_rvalid && S_AXI_RREADY && axi_arlen_cntr == axi_arlen)
            // preparing to accept next address after current read completion
            begin
                axi_arv_arr_flag  <= 1'b0;
            end
        else begin
            axi_arready <= 1'b0;
        end
    end
end
```

与 awready 逻辑类似，主机将 arvalid 拉高，且 axi_awv_awr_flag 和 axi_arv_arr_flag 两个标志都拉低时，将 arready 拉高。

axi_arlen_cntr 的作用。。。



#### 4.2、araddr 地址锁存

当 arvalid 和 rvalid 拉高时，将 araddr 锁存。

```verilog
always @( posedge S_AXI_ACLK ) begin
    if ( S_AXI_ARESETN == 1'b0 ) begin
        axi_araddr <= 0;
        axi_arlen_cntr <= 0;
        axi_arburst <= 0;
        axi_arlen <= 0;
        axi_rlast <= 1'b0;
        axi_ruser <= 0;
    end
    else begin
        if (~axi_arready && S_AXI_ARVALID && ~axi_arv_arr_flag) begin
            // address latching
            axi_araddr <= S_AXI_ARADDR[C_S_AXI_ADDR_WIDTH - 1:0];
            axi_arburst <= S_AXI_ARBURST;
            axi_arlen <= S_AXI_ARLEN;
            // start address of transfer
            axi_arlen_cntr <= 0;
            axi_rlast <= 1'b0;
        end
        else if((axi_arlen_cntr <= axi_arlen) && axi_rvalid && S_AXI_RREADY) begin

            axi_arlen_cntr <= axi_arlen_cntr + 1;
            axi_rlast <= 1'b0;

            case (axi_arburst)
                2'b00: // fixed burst
                    // The read address for all the beats in the transaction are fixed
                    begin
                        axi_araddr       <= axi_araddr;
                        //for arsize = 4 bytes (010)
                    end
                2'b01: //incremental burst
                    // The read address for all the beats in the transaction are increments by awsize
                    begin
                        axi_araddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] <= axi_araddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] + 1;
                        //araddr aligned to 4 byte boundary
                        // ! 低 2/3 位地址置零
                        axi_araddr[ADDR_LSB-1:0]  <= {ADDR_LSB{1'b0}};
                        //for awsize = 4 bytes (010)
                    end
                2'b10: //Wrapping burst
                    // The read address wraps when the address reaches wrap boundary
                    if (ar_wrap_en) begin
                        axi_araddr <= (axi_araddr - ar_wrap_size);
                    end
                else begin
                    axi_araddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] <= axi_araddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] + 1;
                    //araddr aligned to 4 byte boundary
                    axi_araddr[ADDR_LSB-1:0]  <= {ADDR_LSB{1'b0}};
                end
                default: //reserved (incremental burst for example)
                    begin
                        axi_araddr <= axi_araddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB]+1;
                        //for arsize = 4 bytes (010)
                    end
            endcase
        end
        else if((axi_arlen_cntr == axi_arlen) && ~axi_rlast && axi_arv_arr_flag ) begin
            axi_rlast <= 1'b1;
        end
        else if (S_AXI_RREADY) begin
            axi_rlast <= 1'b0;
        end
    end
end
```

axi_arlen_cntr 用于读数据过程中的计数。

当主机将 arvalid 拉高，且 axi_arv_arr_flag 为低时，将 araddr、arburst、arlen 锁存，将 axi_arlen_cntr 和 rlast 置零。

当握手成功（axi_rvalid 和 S_AXI_RREADY 拉高）且 axi_arlen_cntr <= axi_arlen 的时候，将 axi_arlen_cntr 自增 1，将 rlast 置零。然后根据 arburst 的 burst 类型执行不同的操作，类似于写通道。默认是 incremental burst 类型。

当 axi_arlen_cntr 计数值等于 axi_arlen 且 rlast 没有拉高时，将 rlast 拉高。这样下一个周期，刚好是最后一个数据，且 rlast 刚好拉高。

最后一个条件判断，当 rready 为高时，将 rlast 拉低（为什么要这样做？）。



---

### 五、读数据通道（R）

读数据通道的 source 是从机，由从机发起通信，即控制 rid、rdata、rresp、rlast、rvalid 等信号，而主机只控制 rready。

当 arvalid 和 arready 都拉高时， rvalid 拉高。

rvalid 拉高标志着总线上的读出数据有效，rresp 表示读事务的状态。

```verilog
always @( posedge S_AXI_ACLK ) begin
    if ( S_AXI_ARESETN == 1'b0 ) begin
        axi_rvalid <= 0;
        axi_rresp  <= 0;
    end
    else begin
        if (axi_arv_arr_flag && ~axi_rvalid) begin
            axi_rvalid <= 1'b1;
            axi_rresp  <= 2'b0;
            // 'OKAY' response
        end
        else if (axi_rvalid && S_AXI_RREADY) begin
            axi_rvalid <= 1'b0;
        end
    end
end
```

axi_arv_arr_flag 为高时，将 rvalid 拉高。握手成功后，将 rvalid 拉低，rvalid 只握手一个周期。



---

### 六、访问用户逻辑存储区域



```verilog
generate
    if (USER_NUM_MEM >= 1) begin
        assign mem_select  = 1;
        assign mem_address = (axi_arv_arr_flag? axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]:(axi_awv_awr_flag? axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]:0));
    end
endgenerate

// implement Block RAM(s)
generate
    for(i=0; i<= USER_NUM_MEM-1; i=i+1) begin:BRAM_GEN
        wire mem_rden;
        wire mem_wren;

        assign mem_wren = axi_wready && S_AXI_WVALID ;

        assign mem_rden = axi_arv_arr_flag ; //& ~axi_rvalid

        for(mem_byte_index=0; mem_byte_index<= (C_S_AXI_DATA_WIDTH/8-1); mem_byte_index=mem_byte_index+1) begin:BYTE_BRAM_GEN
            wire [8-1:0] data_in ;
            wire [8-1:0] data_out;
            reg  [8-1:0] byte_ram [0 : 255];
            integer  j;

            //assigning 8 bit data
            assign data_in  = S_AXI_WDATA[(mem_byte_index*8+7) -: 8];
            assign data_out = byte_ram[mem_address];

            always @( posedge S_AXI_ACLK ) begin
                if (mem_wren && S_AXI_WSTRB[mem_byte_index]) begin
                    byte_ram[mem_address] <= data_in;
                end
            end

            always @( posedge S_AXI_ACLK ) begin
                if (mem_rden) begin
                    mem_data_out[i][(mem_byte_index*8+7) -: 8] <= data_out;
                end
            end

        end
    end
endgenerate
//Output register or memory read data

always @( mem_data_out, axi_rvalid) begin
    if (axi_rvalid) begin
        // Read address mux
        axi_rdata <= mem_data_out[0];
    end
    else begin
        axi_rdata <= 32'h00000000;
    end
end
```















