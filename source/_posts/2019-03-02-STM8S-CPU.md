---
title: STM8S CPU
date: 2019-03-02 23:09:51
tags:
    - 硬件拾忆
    - STM8
---

---

- stm8s 是基于 8 位框架结构的微控制器

- CPU 内核有 6 个内部寄存器

- 指令集支持 80 条基本语句，20 种寻址模式

- 了解 stm8s 指令集参考 PM0044

<!--more-->

---

#### CPU寄存器（共 6 个）

![img](https://i.loli.net/2019/03/02/5c7aa08eefb76.png)



##### 1、累加器（A）

8 位通用寄存器，用于保存算术运算、逻辑运算以及数据操作的操作数及结果。



##### 2、索引寄存器（X 和 Y）

都是 16 位寄存器，可实现高效率的寻址模式。可用作数据操作的暂存器以及用于乘除法这样的操作。大多数情况下，交叉汇编器会在使用了 Y 寄存器的指令代码中生成 PRECODE 指令，用以和使用了 X 寄存器的指令相区别。



##### 3、程序计数器（PC）

24 位寄存器，用于存储 CPU 下一条要执行指令的地址。每一次指令操作后其内容自动刷新。最大寻址范围 16M 字节。



##### 4、堆栈指针（SP）

16 位寄存器，其内容位堆栈中下一个可自由分配的单元地址。根据不同的型号，堆栈指针的高位会有一个指定的预设值。



堆栈一般用于在中断调用或子程序调用时存储 CPU 的上下文（程序计数器，关键寄存器，相关函数的参数及局部变量等）。用户可以通过 POP 和 PUSH 指令直接对堆栈操作。



SP 可以被 C 编译器的启动代码初始化，C 语言应用程序会根据用户所使用的包含绝对地址信息的链接文件来进行初始化。如果用户使用了自己编写的链接文件和启动代码，请确认 SP 被恰当地初始化（具体地址参考相应手册）。



在 MCU 复位后，或执行了堆栈复位指令后（RSP），堆栈指针被设为其被允许的最大值。对于使用了汇编语言的应用程序，用户可使用 ST 提供的启动代码或编写自己的启动代码来对 SP 进行正确的初始化。



入栈操作使堆栈指针值减小，出栈增加。当堆栈指针值为其被允许的最小值时，继续入栈会使堆栈指针值回卷至最大值，从而导致先前数据被覆盖，但此时没有中断或硬件标志位来指示该事件发生。



子程序调用会占用 2 或 3 字节空间。中断调用会占用 9 字节空间来存储内部寄存器（除 SP 之外）。



WFI/HLAT 指令会预先保存 CPU 上下文。如果 CPU 出于 WFI 或 HALT 状态下有中断发生，则进入中断所需的延时会响应减少。



##### 5、条件代码寄存器（CC）

​     8 位寄存器，用于指示刚被执行的指令结果及处理器的状态。寄存器的第 6 位（0）是保留位，这些位可以被用户程序或代码单独测试，测试结果可用于指示程序或代码执行后的状态。

![img](https://i.loli.net/2019/03/02/5c7aa06f1b407.png)



（1）V：溢出

​     在上一次有符号数的算术操作中，如果结果的最高位有溢出发生，该位置 1。可参考 INC，INCW，DEC，DECW，NEG，NEGW，ADD，ADDW，ADC，SUB，SUBW，SBC，CP，CPW 等指令。



（2）l1：中断屏蔽级别 1

​     与 l0 共同指示当前状态下 CPU 的可中断性。l1 和 l0 也会在 CPU 进入中断服务程序时被硬件自动设置为该中断对应的中断级别。

![img](https://i.loli.net/2019/03/02/5c7aa0b202fcd.png)



（3）H：半进位

​     执行 ADD 或 ADC 操作的过程中，当 ALU 的第 3 位和第 4 位见发生进位时，H 位会被置 1，对于 BCD 码算术运算很有意义。     



（4）l0：中断屏蔽级别 0



（5）N：负数

​     上一次的算术、逻辑或数据操作的结果是负的情况下，N 位被置 1



（6）Z：零

​     上一次的算术、逻辑或数据操作的结果是负的情况下，N 位被置 1



（7）C：进位

​     上一次的算术操作中，如果结果的最高位发生进位或借位，则该位置 1。当执行位测试，分支，移位，旋转和加载指令时，该位也会受到影响。参考 ADD，ADC，SUB，SBC 等指令。



​     在除法操作中，C 位用来指示在指令执行中是否有错误发生（商溢出或 0 作除数）。参考 DIV 指令。



​     在位测试操作中，被测试的位被复制到 C 位。参考 BTJF，BTJT 指令。在移位和旋转操作中，C 位根据结果进行相应地更新。参考 RRC，RLC，SRL，SLL，SRA 指令。



​     用户还可以通过 SCF，RCF，CCF 指令对 C 位进行置位，清除和取反。



------

#### stm8s 入栈出栈顺序：（入栈和出栈都需要 9 个 CPU cycles）



![img](https://i.loli.net/2019/03/02/5c7aa0c3ecdf8.png)

中断发生（中断从发生到响应之间有 1~6 个 CPU cycles 的延迟）

PUSH PCL（8bit，1 CPU cycles）  （PCL 在栈中地址较高）

PUSH PCH（8bit，1 CPU cycles ）

PUSH PCE（8bit，1 CPU cycles ）

PUSH Y（16bit，2 CPU cycles ）

PUSH X（16bit，2 CPU cycles ）

PUSH A（8bit，1 CPU cycles ）

PUSH CC（8bit，1 CPU cycles ）（CC 在栈中地址较低）

跳转至中断向量指向的中断函数

执行中断函数

POP CC

POP A

POP X

POP Y

POP PCE

POP PCH

POP PCL  （共9个CPU cycles）

跳转至PC寄存器指向的地址



------

#### stm8 CPU 寄存器映射



![Image(41).png](https://i.loli.net/2019/03/02/5c7aa11b4fc32.png)



​     CPU 寄存器在 STM8 的地址空间映射如上表，只有 CPU 的调试模块才可以使用这些寄存器的地址对其操作，在 CPU 核内执行的指令只能通过直接使用寄存器名才可以读写这些寄存器。



------

#### 全局配置寄存器（CFGGCR）

地址偏移值 0x00

复位值    0x00



![img](https://i.loli.net/2019/03/02/5c7aa0f0747c9.png)



