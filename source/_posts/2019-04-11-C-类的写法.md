---
title: C++ 类的写法
tags:
  - 编程语言
  - C++
abbrlink: 9ecb7f62
date: 2019-04-11 23:47:57
---

---

#### 一、类的声明

类的声明可以放在头文件中，如：

<!--more-->

```
class Student{

public:

    // 成员变量
    char *name;
    string stu_num;   // 学号
    int age;
    float score;
    
    // 成员函数
    void Print_Info();  // 输出该生的信息

}; // 要加分号
```

使用 class 关键字定义类。类的内部包括成员变量和成员函数。

类只是一个模板（Template），编译后不占用内存，因此不能在声明或定义时对成员变量进行初始化，必须创建对象后才能赋值。

根据成员的属性，可分为三类：
- public 公有，外部可访问
- pravite 私有，外部不可访问，不可在派生类中使用
- protected 受保护，外部不可访问，可在派生类中使用

以上三种修饰符都只能修饰类成员，不能修饰类，且可以在类中多次出现，但为了直观简洁，最好每种只出现一次。

在类的内部，三种类型的成员都可以互相访问，但在类的外部，只能通过对象访问 public 属性的成员。基类中的 protected 成员可以在派生类中使用。访问权限由高到低：public > protected > private。

private 关键字的作用在于隐藏类的内部实现，不希望外部知道、只在类内使用或对外部没有影响的成员都建议声明为 private。需要对外暴露的接口都声明为 public。如果没有写 public 和 private，则默认 private。

另外，类的声明和定义可以写在一起，即在声明时就定义成员函数，也可以把成员函数的定义放在类声明之外，声明中只对成员函数做声明，而不做定义。

---
#### 二、类的定义

类的定义通常即指成员函数的定义，一般可以放在放在 .cpp 文件中。成员函数定义在类外时，必须加上 `::`（域解析符，或作用域限定符），用来连接类名和函数名，指明当前函数属于哪个类。

```
void Student::Print_Info(){
    cout << "姓名" << ": " << name << endl;
    cout << "学号" << ": " << stu_num << endl;
    cout << "年龄" << ": " << age << endl;
    cout << "成绩" << ": " << score << endl;
}
```
即便成员函数定义在类外，也必须在类中作声明，且类的位置应在函数定义之前。

若将成员函数定义在类内，则默认其位内联函数（将函数调用处用函数体替代），若想将定义在类外的成员函数变成内联函数，则在函数前加 `inline` 即可。

---
#### 三、创建对象

##### 1、对象声明/定义

类可以看做是一种数据类型，类似于 C 语言中声明了一个新的结构体类型。

```
class Student LiLei;             // 创建单个对象
Student HanMeimei;           // 创建单个对象，class 可省略
Student students[100];        // 创建对象数组
```

##### 2、访问成员

对象的访问与结构体成员访问类似，使用 `.` 来访问：

```
int main(){

    Student LiLei;
    class Student HanMeimei;
    Student students[100];

    LiLei.name = (char*)"LiLei";
    LiLei.stu_num = "010013";
    LiLei.age = 23;
    LiLei.score = 90.5;

    LiLei.Print_Info();

    return 0;
}
```

##### 3、使用对象指针

```
// 静态分配，即指向栈中已创建的对象
Student LiLei;
Student *pStu = &LiLei;

//动态分配，即通过 new 在堆上动态创建对象
Student *pStu1 = new Student; // 需匹配相应的 delete 进行回收
```

栈中的对象都有名字，且栈内存由程序进行管理，不是必须使用指针指向它。而堆内存由程序员管理，且创建出来的对象没有名字，所以必须有指针指向它，才能进行操作。

动态分配的对象使用完毕后必须用 delete 进行回收释放。

通过指针访问成员：

```
Student HanMeimei;
Student *pStu = &HanMeimei;

pStu -> name = (char*)"HanMeimei";
pStu -> stu_num = "010014";
pStu -> age = 23;
pStu -> score = 91.5;
pStu -> Print_Info();
```

---
#### 四、类的封装

实际项目开发中，成员变量以及只在类内部使用的成员函数都建议声明为 private，而只将允许通过对象调用的成员函数声明为 public。

一般约定，private 的成员变量以 m_ 开头，以区别于成员函数的变量。private 的成员变量的作用域是整个类内部。

则相应的可将上面的类修改为：

```
#include <iostream>
using namespace std;

class Student{

public:
	void Set_Name(char *name);
	void Set_StuNum(string m_stu_num);
	void Set_Age(int age);
	void Set_Score(float score);
    void Print_Info();  // 输出该生的信息

private:
	char *m_name;
    string m_stu_num;   // 学号
    int m_age;
    float m_score;

}; // 要加分号

void Student::Set_Name(char *name){

	m_name = name;
}

void Student::Set_StuNum(string stu_num){

	m_stu_num = stu_num;
}

void Student::Set_Age(int age){

	m_age = age;
}

void Student::Set_Score(float score){

	m_score = score;
}

void Student::Print_Info(){

	cout << "姓名" << ": " << m_name << endl;
	cout << "学号" << ": " << m_stu_num << endl;
	cout << "年龄" << ": " << m_age << endl;
	cout << "成绩" << ": " << m_score << endl << endl;
}


int main(){

	Student LiLei;
	class Student HanMeimei;
	Student students[100];

	Student *pStu = &HanMeimei;
	// Student *pStu1 = new Student;
	// delete pStu1;

	LiLei.Set_Name((char*)"LiLei");
	LiLei.Set_StuNum("010013");
	LiLei.Set_Age(23);
	LiLei.Set_Score(90.5);

	pStu -> Set_Name((char*)"HanMeimei");
	pStu -> Set_StuNum("010014");
	pStu -> Set_Age(23);
	pStu -> Set_Score(91.5);

	LiLei.Print_Info();
	pStu -> Print_Info();

	return 0;
}
```

这里因为成员变量的属性改为了 private，不能通过对象从外部修改，因此增加了 public 属性的 set 函数来修改其值，相应的可以定义 get 函数来获取相应的成员变量值。

另外也可以通过定义构造函数来初始化成员变量。

---
#### 五、构造函数

##### 1、构造函数

可通过定义构造函数，使得类在实例化为对象时，可以通过传参来初始化。构造函数没有返回值，且必须是 public 属性的。

构造函数没有返回值，也没有 return 语句，且构造函数名应与类名同名。

在栈上创建对象时，实参位于对象名之后，如：

```
Student LiLei((char *)"LiLei", "010013", 23, 90.5);
```

在堆上创建对象时，实参位于类名之后，如：
```
Student *pStu1 = new Student("LiHua", "010015", 23, 92.5);
```

构造函数支持重载，可以重载多个构造函数，创建对象时根据实参判断调用哪一个构造函数。

一旦在类中定义了构造函数，构造函数的调用将是强制性的，创建时一定会调用，否则将是错误的。

如果用户没有定义构造函数，编译器会自动生成一个默认的构造函数。

如果定义了没有参数的构造函数，在创建对象时，可以不用写括号（用户不定义构造函数时即是这样调用了默认构造函数），例如，如果定义了 `Student::Student();`，则创建对象时，可以写成 `Student stu();` 或 `Student stu;`。

例程：

```
#include <iostream>
using namespace std;

class Student{

public:
	Student(char* name, string stu_num, int age, float score);
	Student();
	void Set_Name(char *name);
	void Set_StuNum(string m_stu_num);
	void Set_Age(int age);
	void Set_Score(float score);
	void Print_Info();  // 输出该生的信息

private:
	char *m_name;
	string m_stu_num;   // 学号
	int m_age;
	float m_score;

}; // 要加分号


Student::Student(char* name, string stu_num, int age, float score){

	m_name = name;
	m_stu_num = stu_num;
	m_age = age;
	m_score = score;
}

Student::Student(){

	m_name = NULL;
	m_stu_num = "NULL";
	m_age = 0;
	m_score = 0.0;
}

void Student::Set_Name(char *name){

	m_name = name;
}

void Student::Set_StuNum(string stu_num){

	m_stu_num = stu_num;
}

void Student::Set_Age(int age){

	m_age = age;
}

void Student::Set_Score(float score){

	m_score = score;
}

void Student::Print_Info(){

	cout << "姓名" << ": " << m_name << endl;
	cout << "学号" << ": " << m_stu_num << endl;
	cout << "年龄" << ": " << m_age << endl;
	cout << "成绩" << ": " << m_score << endl << endl;
}

int main(){

	Student LiLei((char *)"LiLei", "010013", 23, 90.5);
	class Student HanMeimei((char *)"HanMeimei", "010014", 23, 91.5);
	//Student students[100]; //此处将报错，因为没有调用构造函数

	Student *pStu = &HanMeimei;
	// Student *pStu1 = new Student("LiHua", "010015", 23, 92.5);
	// delete pStu1;

	LiLei.Print_Info();
	pStu -> Print_Info();

	return 0;
}
```

##### 2、参数初始化表

构造函数除了可以像正常函数一样使用函数体对成员变量一一赋值，还可以通过参数初始化表进行初始化。这种方法书写方便，效率上并无提升。例如：

```
Student::Student(char* name, string stu_num, int age, float score)
: m_name(name), m_stu_num(stu_num), m_age(age), m_score(score){
}
```
参数初始化表可以用于全部成员变量，也可以只用于部分成员变量。参数初始化表的初始化顺序只与类中成员变量的顺序有关。

**const 成员变量只能用参数初始化表的方式来初始化。**

---
#### 六、析构函数

析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要显示调用（也无法显示调用），而是在销毁对象时自动执行。

与构造函数类似，析构函数的函数名与类名相同，但要在类名前加一个 `~` 符号。

析构函数没有参数，不能被重载，一个类只能有一个析构函数。如果用户不定义，编译器会自动生成一个默认析构函数。

例如在构造函数中分配了堆内存：

```
m_array = new int[len];
```

则在析构函数中需要释放相应的内存：

```
delete[] m_array;
```

---
#### 七、this 指针

this 是一个 C++ 关键字，用于指向当前对象，通过它可以访问当前对象的所有成员。

this 是一个 const 指针，只能用在类的内部。通常可用在成员变量与成员函数的参数重名时。

用 `this -> 成员变量`  表示该变量是成员变量，而不是函数参数。

this 其实是存在对象内部的存放对象地址的 const 指针变量，所以只能用在内部，只有通过对象调用成员函数时才给 this 赋值。

成员函数最终会被变异成与对象无关的普通函数，对象只保留成员变量，因此通过 this 将成员函数与成员变量进行关联。

---
#### 八、静态成员变量

不同对象之间的相同成员变量是相互独立的，若想要不同的对象共享数据，可使用 static 定义静态成员变量。例如：

```
class Student{
public:
    static string m_teacher;
}
```

静态成员变量必须在类声明的外部进行初始化（放在构造函数中也不行），且必须带上数据类型，形式为：

```
    int Student::m_teacher = "Miss Wang";
```

静态成员变量有三种访问方式：

```
// 通过类访问
Student::m_teacher = "Mr Li";

// 通过对象访问
Student LiLei((char *)"LiLei", "010013", 23, 90.5);
LiLei.m_teacher = "Miss Zhao";

// 通过对象指针访问
Student *pStu = new Student("HanMeimei", "010014", 23, 92.5);
pStu -> m_teacher = "Mr Gao";
```

static 静态成员变量不属于某个对象，而属于类，因此不占用对象内存，而在所有对象外部（内存中的全局数据区）开辟内存，不创建对象也可以访问。

静态成员变量的访问需要遵循 public、private、protected 关键字的访问权限限制，如果属性设为 private，将不能在外部进行访问，只能通过成员函数访问。

---
#### 九、静态成员函数

在类中，除了静态成员变量，还可以声明静态成员函数。

静态成员函数只能访问静态成员，

静态成员函数没有 this 指针，不知道指向哪个对象，可以通过类来直接调用（也可以通过对象调用）。同时，无法访问对象的（普通）成员变量和调用对象的（普通）成员函数，只能访问静态成员变量和调用静态成员函数。

和静态成员变量类似，静态成员函数在声明时要加 static，在定义时不能加 static。

**静态成员函数的主要目的就是访问静态成员。**（当然普通成员函数也可以访问静态成员，但是加上 static 意义更明确）

---
#### 十、类中的 const 关键字

如果不希望数据被修改，可以用 const 修饰，包括成员变量、成员函数和对象。

##### 1、const 成员变量

const 成员变量的初始化只能通过参数初始化表。初始化之后不能修改。

##### 2、const 成员函数

const 成员函数**可以使用类中的所有成员变量，但是不能修改它们的值**。

const 成员函数**定义和声明时都要在函数头部的结尾处加上 const 关键字**，如：

```
float Get_Score() const;  // 声明

float Student::Get_Score() const{  // 定义
    return m_score;
}
```

##### 3、const 对象

const 对象也叫常对象，常对象只能访问类的 const 成员。

定义常对象时，const 关键字和类名谁前谁后都可以，通常把 const 放在前。

---
#### 十一、friend 友元函数和友元类

通过对象可以访问 public 成员，只有本类中的函数可以访问本类的 private 成员。

通过友元（friend），可以让其他类中的成员函数以及全局范围的函数访问当前类的 private 成员。

友元的关系是单向的。友元的关系不能传递。

一般不建议声明友元类，声明友元函数更为安全。

##### 1、友元函数

在当前类以外定义的、不属于当前类的函数，也可以在本类中声名，但要在前面加 friend 关键字，以构成友元函数。友元函数可以访问当前类中的所有成员，包括 public、private、protected 属性的。

调用友元函数时，不需要通过对象，直接按照普通函数的方式调用即可。

友元函数不能直接访问成员，需要通过对象或对象的指针来访问。

类 A 使用其他类 B 的成员函数作为友元函数的时候，需要提前声明类 A。

```
friend void Get_Info(Student *pStu);  // 将全局函数作为友元函数

friend string Student::Get_Teacher();  // 将 Student 类 的 Get_Teacher 函数作为友元函数
```

一个函数可以被多个类声明为友元函数。

##### 2、友元类

友元类中的所有成员函数都是另一个类的友元函数。

友元类声明语句：

```
friend class Student;
```

#### 十二、类和结构体的区别

相比较 C 语言而言，C++ 对 struct 进行了扩充，使其可以定义成员函数，因此也具备定义一个类的能力。但是在 C++ 中，最好还是使用 class 来定义类。

class 的成员默认是 private 属性，struct 的成员默认是 public 属性。

class 继承默认是 private 继承，struct 的继承默认是 public继承。

class 可使用模板，struct 不能使用模板。