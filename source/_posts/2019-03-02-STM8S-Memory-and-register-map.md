---
title: STM8S Memory and register map
date: 2019-03-02 23:44:59
tags:
    - 硬件拾忆
    - STM8
---

---

存储器映射、I/O 端口硬件寄存器映射和 CPU/SWIM、调试模块/中断控制寄存器的详细内容参见 datasheet。

<!--more-->



---

### 存储器映射

![Image.png](https://i.loli.net/2019/03/02/5c7aa57fd53a6.png)



各部分具体上限（upper limit）参看 datasheet。



---

### stm8s stack handling  栈处理

stm8s 和 stm8af MCU 的栈在 user RAM 区实现。

![Image.png](https://i.loli.net/2019/03/02/5c7aa5bc24eaa.png)



栈底所在的地址大于栈顶所在的地址。



不是所有器件都有 roll-over limit  回卷限制。



用户必须注意初始化栈指针。通常由开发工具（linker file）生成的初始化代码来正确加载这个指针，默认初始化到 RAM 尾地址。



有些器件中，栈回卷限制为一个固定地址。如果使用 push 操作或为子函数或中断函数保存上下文时，栈指针减小到栈回卷限制处，栈指针将复位到 RAM 尾地址。当栈指针正参与运算时，不会回卷。



---

### Customized stack model 自定义栈模型

stm8s 和 stm8af 的栈指针操作允许执行一个自定义的栈模型。这就使得栈的大小变得灵活，而不用受到栈回卷限制的约束。执行自定义栈也有利于寄存器配置不同的器件的软件可移植性。

![Image.png](https://i.loli.net/2019/03/02/5c7aa5fb84939.png)



并不是所有器件都有栈回卷限制。



保护单元（guard cells）是必须被应用程序连续轮询检测是否发生栈溢出的 RAM 位置。



在这个模型中，初始的栈指针必须指向超过栈回卷限制的位置（必须必回卷限制的地址小）。因此，增长的栈永远不会到达回卷限制。很明显，这样的操作下，栈大小不会受到溢出机制的限制。虽然如此，用户必须在 link file 中定义栈的位置和栈的大小，也必须确保栈指针不会超出定义的栈区域（栈顶溢出或低于栈底）。超过或在自定义栈之下的 RAM 位置可以被常规的用作 RAM 来存储变量或其他信息。



保护单元可以被配置在比栈顶更低的位置以检测是否栈指针超过了规定的边界。这些单元是标准的 RAM 位置，初始化为固定值，一旦发生溢出，栈将在这里重写。用户软件可以常规轮询这些单元，检测溢出条件，并将应用置于故障保护状态。



在软件有效期内，硬件断点可被设在栈的两个极端位置，以确认栈溢出和欠载都没有发生。



---

### 寄存器描述缩写

![Image.png](https://i.loli.net/2019/03/02/5c7aa6501fc7b.png) 

![Image.png](https://i.loli.net/2019/03/02/5c7aa6502474f.png)