---
title: 递归算法
tags:
  - 算法
abbrlink: 5f7017e8
date: 2019-03-09 11:40:42
---

---

《数据结构（C++语言版）》（邓俊辉编著）笔记

---

〇、概念

递归 —— 允许函数和过程进行<font  color=#FF0000>  自我调用 </font>的一种特殊形式。

递归基 —— 保证递归能够结束（有穷性）的平凡情况，可以有多种，至少有一种，且迟早必然会出现。递归基可能是隐含的。

<!--more-->

---

### 一、常用递归算法



#### 1、线性递归



##### 概念

每一层次上至多只有一个实例，且构成一个线性的次序关系，称为线性递归（linear recursion）。



例如：

```
int sum (int A[]，int n){ // 数组求和算法（线性递归版）
	if (1>n)// 递归基
		return 0;
	else
		return sum (A，n-1) + A[n-1]; // 减而治之
}
```



##### <font  color=#FF0000>  减而治之 </font>（decrease-and-conquer）策略

递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡的简单问题。

问题划分为两个子问题：

- 平凡的子问题
- 规模缩减的子问题



#### 2、二分递归（多路递归）



##### 概念

将一个大规模的问题划分为若干（通常两个）规模大体相当的子问题，分别求解子问题，由子问题的解，得到原问题的解。



例如：

```
int sum(int A[]，int lo，int hi){ // 数组求和算法(二分递归版)
    if(lo == hi) // 递归基
        return A[lo];
    else{ 
        int mi = (lo+hi)>>1;
        return sum(A，lo，mi) + sum(A，mi+1，hi); // 分而治之
    }
}
```



##### <font  color=#FF0000> 分而治之 </font>（divide-and-conquer）策略

将问题分解为若干规模更小的子问题，再通过递归机制分别求解。



#### 3、多向递归（多分支递归）



每一递归实例虽有多个可能的递归方向，但只能从中选择其一。

各层次上的递归实例依然构成一个线性次序关系，这种情况本质上仍属于线性递归。



例如：

```
inline_int64 sqr(_int64 a){ return a*a;}
int64 power2(int n){ //幂函数 2^n 算法(优化递归版)
    if(e==n)return 1;// 递归基
    return(n&1) ？sqr(power2(n>>1))<<1 : sqr(power2(n>>1));// 多分支递归
}
```

针对输入参数 n 为奇数或偶数两种可能，分别设有不同的递归方向。



---

### 二、递归分析



#### 1、递归跟踪（recursion trace）



将算法的执行过程整理成图的形式，可以直观的分析递归算法的运行时间与空间。



#### 2、递推方程



通过对递归模式的数学归纳，导出复杂度定界函数的递推方程（组）及其边界条件，从而将复杂度的分析，转化为递归方程（组）的求解。



边界条件往往可以分析递归基获得。



---

### 三、递归消除



递归程序往往需要较多的空间，并进而影响实际的运行速度，因此，往往应将递归算法改写成等价的非递归版本。



可以借助栈来消除递归。对于单向递归和尾递归，也可利用迭代的方式进行递归消除。