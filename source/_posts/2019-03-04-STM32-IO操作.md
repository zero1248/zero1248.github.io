---
title: STM32 IO操作
date: 2019-03-04 14:26:14
tags:
    - 硬件拾忆
    - STM32
---

---

### 一、位带操作



SRAM 和片内外设区的最低 1MB 范围都支持位带操作。每一 bit 都有自己的 32 位“位带别名区”，可以用来访问原始 bit。

<!--more-->

SRAM 中最低 1MB    ：0x2000 0000 - 0x200f ffff

片内外设中最低 1MB：0x4000 0000 - 0x100f ffff

​     

当一个别名地址被访问时，会先把该地址变换成位带地址。位带区的每个比特都映射到别名地址区的一个 LSB 有效的字。



对于读操作，读取位带地址中的一个字，再把需要的位右移到 LSB，并把 LSB 返回。



对于写操作，把需要写的位左移至对应的位序号处，然后执行一个原子的“读-改-写”过程。



对于 SRAM 位带区的某个比特，记它所在字节地址为 A，位序号为 n（0<=n<=7），则该比特在别名区的地址为：



AliasAddr = 0x22000000+((A-0x20000000)*8+n)*4 = 0x22000000+(A-0x20000000)*32+n*4



![Image.png](https://i.loli.net/2019/03/04/5c7ccb6221a59.png)



对于片上外设位带区的某个比特，记它所在字节的地址为 A，位序号为 n（0<=n<=7），则该比特在别名区的地址为：



AliasAddr = 0x42000000+((A-0x40000000)*8+n)*4 = 0x42000000+(A-0x40000000)*32+n*4



![Image.png](https://i.loli.net/2019/03/04/5c7ccb8e16090.png)



c 语言代码实现：

```
//位带操作,实现 51 类似的 GPIO 控制功能

//具体实现思想,参考<<CM3权威指南>>第五章(87页~92页).

//IO口操作宏定义

#define BITBAND(addr, bitnum) ((addr & 0xF0000000)+0x2000000+((addr &0xFFFFF)<<5)+(bitnum<<2))

#define MEM_ADDR(addr)  *((volatile unsigned long  *)(addr))

#define BIT_ADDR(addr, bitnum)   MEM_ADDR(BITBAND(addr, bitnum))

//IO口地址映射

#define GPIOA_ODR_Addr    (GPIOA_BASE+12) //0x4001080C

#define GPIOB_ODR_Addr    (GPIOB_BASE+12) //0x40010C0C

#define GPIOC_ODR_Addr    (GPIOC_BASE+12) //0x4001100C

#define GPIOD_ODR_Addr    (GPIOD_BASE+12) //0x4001140C

#define GPIOE_ODR_Addr    (GPIOE_BASE+12) //0x4001180C

#define GPIOF_ODR_Addr    (GPIOF_BASE+12) //0x40011A0C   

#define GPIOG_ODR_Addr    (GPIOG_BASE+12) //0x40011E0C   



#define GPIOA_IDR_Addr    (GPIOA_BASE+8) //0x40010808

#define GPIOB_IDR_Addr    (GPIOB_BASE+8) //0x40010C08

#define GPIOC_IDR_Addr    (GPIOC_BASE+8) //0x40011008

#define GPIOD_IDR_Addr    (GPIOD_BASE+8) //0x40011408

#define GPIOE_IDR_Addr    (GPIOE_BASE+8) //0x40011808

#define GPIOF_IDR_Addr    (GPIOF_BASE+8) //0x40011A08

#define GPIOG_IDR_Addr    (GPIOG_BASE+8) //0x40011E08



//IO 口操作，只对单一的 IO 口

//确保 n 的值小于16

#define PAout(n)   BIT_ADDR(GPIOA_ODR_Addr,n)  //输出

#define PAin(n)    BIT_ADDR(GPIOA_IDR_Addr,n)  //输入



#define PBout(n)   BIT_ADDR(GPIOB_ODR_Addr,n)  //输出

#define PBin(n)    BIT_ADDR(GPIOB_IDR_Addr,n)  //输入



#define PCout(n)   BIT_ADDR(GPIOC_ODR_Addr,n)  //输出

#define PCin(n)    BIT_ADDR(GPIOC_IDR_Addr,n)  //输入



#define PDout(n)   BIT_ADDR(GPIOD_ODR_Addr,n)  //输出

#define PDin(n)    BIT_ADDR(GPIOD_IDR_Addr,n)  //输入



#define PEout(n)   BIT_ADDR(GPIOE_ODR_Addr,n)  //输出

#define PEin(n)    BIT_ADDR(GPIOE_IDR_Addr,n)  //输入



#define PFout(n)   BIT_ADDR(GPIOF_ODR_Addr,n)  //输出

#define PFin(n)    BIT_ADDR(GPIOF_IDR_Addr,n)  //输入



#define PGout(n)   BIT_ADDR(GPIOG_ODR_Addr,n)  //输出

#define PGin(n)    BIT_ADDR(GPIOG_IDR_Addr,n)  //输入
```



---

### 二、IO 口模式



1、输入浮空

2、输入上拉

3、输入下拉

4、模拟输入

5、开漏输出

6、推挽输出

7、推挽式复用功能

8、开漏复用功能



每个 IO 口有 7 个寄存器：

- 配置模式的 2 个 32 位端口配置寄存器 CRL 和 CRH

- 2 个 32 位数据寄存器 IDR 和 ODR

- 1 个 32 位的置位/复位寄存器 BSRR

- 1 个 16 位的复位寄存器 BRR

- 1 个 32 位的锁存寄存器 LCKR

  

![Image.png](https://i.loli.net/2019/03/04/5c7ccc73aea1c.png)



**CRL 和 CRH**



每个 IO 口占 4 位，高 2 位为 CNF，低 2 位为 MODE。



0x0 表示模拟输入（ADC 用）

0x4 表示浮空输入

0x8 表示上下拉模式（输入口）PxODR=0下拉；=1上拉



0x3 表示推挽输出（输出口，50M速率）（0x2-2M、0x1-10M）

0x7 表示开漏输出（0x6-2M 、0x5-10M ）

0xb 表示复用推挽输出（IO口第二功能，50M速率 ）（0xa-2M 、0x9-10M ）

0xf 表示复用开漏输出（IO口第二功能，50M速率 ）（0xe-2M 、0xd-10M ）



**IDR 和 ODR**

​     

只用了低 16 位。IDR 为只读，ODR 为读写。