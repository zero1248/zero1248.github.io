---
title: C++ 模板
date: 2019-04-13 21:46:49
tags:
    - 编程语言
    - C++
---

---

#### 一、函数模板（Function Template）

值的参数化：

<!--more-->

- 在函数定义时形参数据的值是未知的，只有等到函数调用时接收了实参才能确定其值。

类型的参数化：

- 在 C++ 中，数据类型也可以通过参数来传递，在函数定义时不指明具体数据类型，函数调用时，编译器可以根据传入的实参自动推断数据类型。

函数模板：

- 建立一个函数的模板，其用到的数据类型（返回值、形参、局部变量的类型）用一个虚拟的类型代替。



函数模板的语法：（模板头 + 使用新定义的类型参数的函数定义）

```
template <typename 类型参数1 , typename 类型参数2 , ...> 
返回值类型  函数名(形参列表){
	…
}
```

比如：

```
template<typename T> void Swap(T &a, T &b){

	T temp = a;
	a = b;
	b = temp;
}
```

函数模板也可以先声明后定义，但是声明的时候也必须带上模板头。

可以用多个 typename 声明多种不同的类型参数。

typename 关键字也可以使用 class 关键字代替。



------

#### 二、类模板（Class Template）

类模板的定义与函数模板类似，语法如下：

```
template<typename 类型参数1, typename 类型参数2 , …> class 类名{
    …
};
```

类的成员函数的定义时，语法为：

```
template <typename 类型参数1, typename 类型参数2,  …>

返回值类型 类名<类型参数1, 类型参数2, … > :: 函数名(参数表){
	…
}
```

在类名之后，需带上该类全部的类型参数表（不需要写 typename），函数的参数表中，用到了哪个类型参数写哪个就可以。

```
template<typename T> class Operation{

public:

	Operation(T a, T b) :m_a(a), m_b(b){}
	T Sum();
	bool SetValue(T a, T b);

private:

	T m_a;
	T m_b;
};

template<typename T>
T Operation<T>::Sum(){

	T c = m_a + m_b;
	return c;

}

template<typename T>
bool Operation<T>::SetValue(T a, T b){

	m_a = a;
	m_b = b;

}

int main(){

	Operation<float> ope(2.3, 3.4);
	float sum = ope.Sum();
	cout << sum << endl;

return 0;

}
```

使用类模板创建对象时，需显示指明类型参数，例如：

```
Operation<float> ope(2.3, 3.4);
```

如果是创建对象指针，赋值时两边都要指明具体类型，且要保持一致：

```
Operation<float> *ope = new Operation<float>(1.2, 2.3);
```

另外，也可以仿造类模板定义结构体模板。