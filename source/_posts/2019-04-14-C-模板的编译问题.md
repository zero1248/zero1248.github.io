---
title: C++ 模板的编译问题
date: 2019-04-14 18:57:31
tags:
    - 编程语言
    - C++
---

---

#### 一、C++ 对模板的编译
使用普通函数和类的时候，编译器只需掌握函数或类的声明即可，所以声明和定义通常分别放在 .h 和 .cpp 文件中。

<!--more-->

而模板和模板的成员函数都是在用到的时候才会实例化，这就导致如果按照普通函数或类的方法去定义和声明模板类，在链接阶段，链接器将找不到模板函数或模板类成员函数的定义，因为它们所在的 .cpp 文件并未被编译。为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，因此**模板的头文件通常既包括声明，也包括定义**。

事实上，C++对想要将声明和定义分别放在两个文件中进行编译提供了两种方式：
- 包含编译
- 分离编译

包含编译：
大部分内容与正常函数或类的定义和声明相同，只是文件包含有所区别，不需要 cpp 头部包含 .h 文件，而是**用头文件包含源文件**，在 .h 文件的末尾#include<XXX.cpp>。这样其实就相当于把所有内容都写在了头文件中，因为预编译阶段就是把 #include 的文件复制到包含位置。

分离编译：
仍是大部分内容与正常函数或类的定义和声明相同，在定义所在的 .cpp 文件中的函数定义的最前面加上 export 关键字，以告诉编译器该定义在哪里被引用。

然而在 codeblocks12.11 中使用上面两种方法时，均失败。分别报错说 .cpp 中的类名“does not name a type”，和 export 关键字没有被实现，因而将被忽略，进而导致实例化时该类模板“undefined reference”。

可见，以上两种方法虽理论上可行，但实际上由于编译器的原因，并不一定能使用。

---
#### 二、Codeblocks 中使用模板的方法

##### 方法一：

定义和声明放在同一个 .h 文件中。这是最可靠的方式，无论哪个编译器都不会出错。只是有可能在大规模项目中导致文件特别大。

##### 方法二：

声明和定义放在不同的 .h 文件中，在声明文件的末尾（注意是末尾） #include 定义的 .h 文件。

这样做原理上与方法一是一致的，在预编译阶段通过复制使它们成为了一个文件。

##### 方法三：

声明和定义分别放在 .h 和 .cpp 文件中，.cpp 文件包含 .h 文件，在 .cpp 文件中写一个函数，对该文件中涉及到的所有成员函数全部实例化一遍（如果只对部分成员函数实例化了，则剩余函数不会被编译）。

这种方法的原理在于：
- 如果不在 .cpp 文件中进行实例化，编译阶段编译器遇到这个 .cpp 文件，一看里面全是模板，就会将这个文件忽略，这样在链接阶段，链接器就会因为找不到模板函数的定义文件而报错。
- 在 .cpp 文件中通过一个函数进行了实例化之后，编译阶段，编译器发现这个文件中有非模板函数，就会对其进行编译，由于它的内部对模板进行了实例化，所以，而这些模板的定义和声明又有迹可循，所以就能对它们进行编译。

##### 方法四：

声明和定义分别放在 .h 和 .cpp 文件中，.cpp 文件包含 .h 文件，在实例化模板的文件中，再统一包含这两个文件。

例如，在 main() 函数中对类模板及其中的成员函数进行了实例化，则在 main() 函数所在的文件头部包含 .cpp 和 .h 文件。此方法的原理类似于方法三。

---
以上四种方法都是在 codeblocks12.11 中验证过的。总体来说，还是方法一和方法二更实用一些。但是在摸索这些方法的过程中，加深对程序编译和 C++ 语言特性的理解，还是颇有好处的。

参考博文及书籍：
《C++ primer（中文第 5 版）》
https://blog.csdn.net/xiaoyaohuqijun/article/details/50558208
https://blog.csdn.net/qq_41230365/article/details/80207842
https://blog.csdn.net/u012814856/article/details/84645963
https://blog.csdn.net/chenyiming_1990/article/details/9094593