---
title: C++ 数据类型
date: 2019-04-11 23:53:10
tags:
    - 编程语言
    - C++
---

---

《C++ primer》笔记

---
### 一、基本内置类型

1、long long 是在 C++11 中新定义的。

2、char 和 signed char 并不一样。

<!--more-->

3、long 一般和 int 有一样的尺寸。

4、算术表达式中不要使用 char 或 bool。char 跨平台容易出问题，要用也明确指明 signed 或 unsigned。

5、浮点运算通常选 double，float 通常精度不够，且二者计算代价相差无几。

6、无符号类型赋值时如果超范围，将取模后赋值。有符号类型赋值时如果超范围，结果是未定义的。

7、不要混用有符号类型和无符号类型，计算时有符号类型会转换成无符号类型。

8、指定常量（字面值）的类型

字面值即常量，每种字面值都有对应的数据类型。

| L'a’     | 宽字符型字面值，类型是 wchar_t                          |
| -------- | ------------------------------------------------------- |
| u8"hi"   | utf-8字符串字面值（utf-8 用 8 位编码一个 Unicode 字符） |
| 42ULL    | 无符号整型字面值，类型是 unsigned long long             |
| 1E-3F    | 单精度浮点型字面值，类型是 float                        |
| 3.14159L | 扩展精度浮点型字面值，类型是 long double                |

字符和字符串常量（字面值）
| 前缀 | 含义                    | 类型     |
| ---- | ----------------------- | -------- |
| u    | Unicode 16 字符         | char16_t |
| U    | Unicode 32 字符         | char32_t |
| L    | 宽字符                  | wchar_t  |
| u8   | UTF-8(仅用于字符串常量) | char     |

整型字面值
| 后缀     | 最小匹配类型 |
| -------- | ------------ |
| u or U   | unsigned     |
| l or L   | long         |
| ll or LL | long long    |

浮点型字面值
| 后缀   | 类型        |
| ------ | ----------- |
| f or F | float       |
| l or L | long double |

布尔字面值 和 指针字面值
true 和 flase
nullptr

---

### 二、变量

1、对 C++ 程序员来说，变量 和 对象 一般可以互换使用。

2、一般情况下，对象指一块能存储数据并具有某种类型的内存空间。

3、C++ 中初始化和赋值是两个完全不同的概念。初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

4、四种初始化语句：
```
int units sold=0; 
int units_sold={0]; 
int units_sold{0};
int units sold(0);
```
使用花括号（列表初始化）的好处是若初始值存在丢失信息的风险，则编译器将报错。如将 long double 型的常量赋给 int 型变量。

5、未初始化的变量将被默认初始化，默认值由变量类型决定，同时定义变量的位置也会对此有影响。
内置类型的变量未初始化时，全局变量将被初始化为 0，局部变量将不被初始化。
每个类各自决定其初始化对象的方式。

6、变量声明和定义的关系
```
extern int i;  // 只声明
extern int i = 1;  // 声明并定义
int j;           // 声明并定义
```
函数内部初始化一个由 extern 标记的变量，将引发错误。

7、标识符对大小写敏感。
必须以字母或下划线开头，不能数字开头。
不能出现两个连续的下划线。
不能下划线紧连大写字母开头。
定义在函数体外的标识符不能以下划线开头。

8、C++ 关键字

9、C++ 操作符替代名

10、名字的作用域
名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。

全局作用域、块作用域。

作用域可嵌套，内层作用域可以重新定义外层作用域已有的名字。

使用全部变量的函数不应再在内部定义同名局部变量。

---

### 三、复合类型

1、一条声明语句由一个基本数据类型和一个紧随其后的声明符列表组成。

2、引用，有左值引用和右值引用，通常单说“引用”是指左值引用。符号为“&”。

出现在表达式中，& 是取地址符。
出现在声明中，且紧跟在 数据类型之后，& 是引用符。（若出现在初始化的表示式右侧，仍是取地址符）

引用即别名。

引用必须被初始化，因为程序把应用和它的初始值绑定在一起，而不是拷贝，无法令应用重新绑定到另外一个对象。

不能定义引用的引用，因为引用不是一个对象，只是一个别名。

引用只能绑定在对象上，不能与某个常量或表达式的值绑定在一起。

3、指针
指针本身是一个对象，允许赋值和拷贝，且在生命周期内可以指向不同对象，可以不初始化。

不能定义指向引用的指针，因为引用不是对象，没有实际地址。

被指针指向的对象，可通过解引用符（*）来访问。解引用符适用于有效指针。

4、空指针的生成方法

```
int *p1 = nullptr;  // 等价于 int *p1 = 0;
int *p2 = 0;   // 直接将 p2 初始化为字面常量 0
// 需要包含 cstdlib 头文件
int *p3 = NULL;  // 等价于 int *p3 = 0;
```
尽量用 nullptr，避免用 NULL。

5、void* 指针
可用于存放任意对象的地址。

能进行的操作有限：与其他指针比较、作为函数的输入或输出、赋值给另一个 void* 指针。

不能直接操作 void* 指针所指的对象，因为不知道所指对象的类型。

6、`int* p, q;` 只将 p 声明为 int 型指针，而 q 是 int 型变量，因为该声明的实质是 `int *p, q; ` 基本数据类型是 int，而非 int*。

7、可以定义指向指针的引用。

8、面对一条比较复杂的指针或引用的声明语句，从右向左阅读有助于弄清其真实含义。

---
### 四、const 限定符

1、const 对象必须初始化，且不能再做修改。

默认状态下，const 对象仅在文件内有效。在其他文件中使用需声明。也可以加上 extern，并在头文件中声名。

2、对 const 对象引用后，不能（通过引用）修改所绑定的对象。

3、指向 const 对象的指针，不能（通过指针）改变其所指对象的值。

4、* const 是 指针常量。
const * 是 常量指针。
从右往左看。

5、顶层 const 表示指针本身是个常量。更一般的，顶层 const 可以表示任意的对象是常量，适用于任何数据类型。
底层 const 表示指针所指的对象是一个常量。
```
const int &r = ci;  // 用于声明引用的 const 都是底层 const
```
执行对象的拷贝操作时，常量是顶层 const 还是底层 const 区别明显。

6、如果认定变量是一个常量表达式，可以声明成 constexpr 类型。

7、常量表达式 和 constexpr 变量。

8、在 constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关。

```
const int *p=nullptr； // p是一个指向整型常量的指针constexpr int *q=nullptr； // q是一个指向整数的常量指针
```

---

### 五、处理类型

1、两种定义类型别名的方法
- 关键字 typedef：
```
typedef double wages；// wages 是 double 的同义词typedef wages base，*p；// base 是 double 的同义词，p 是 double* 的同义词
```
- 别名声明（关键字 using）：
```
using SI = Sales_item；// SI 是 Sales_item 的同义词
```

2、将类型别名替换成本来的样子再理解语句是错误的
```
typedef char *pstring；// pstring 是 char * 的别名
const pstring cstr = 0；// cstr 是指向 char 的常量指针
```
替换后：
```
const char *cstr = 0；// 是对 const pstring cstr 的错误理解，此处 cstr 是指向 char 型常量的指针
```
前者 const 修饰 *，后者 const 修饰 char。

3、auto 类型说明符可根据表达式的运算结果分析变量的类型，用 auto 定义的变量必须有初始值。

auto 一般会忽略掉顶层 const，而保留底层 const。如果希望推断出的 auto 类型是一个顶层 const，需要明确指出。
```
const auto f=ci；//ci的推演类型是int，f是const int
```

设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。

4、decltype 与 auto 类似，但它值分析表达式并得到类型，却不实际计算表达式的值，也就不用表达式的值初始化变量。

decltype 处理顶层 const 和引用的方式与 auto 有些许不同。如果 decltype 使用的表达式是一个变量，则 decltype 返回该变量的类型（包括顶层 const 和引用在内）：


```
const int ci = 0，&cj = ci；
decltype（ci）x = 0；// x 的类型是 const int 
decltype（cj）y = x；// y 的类型是 const ints，y 绑定到变量 x 
decltype（cj）z；// 错误：z 是一个引用，必须初始化
```

decltype 后不加括号，得到的是该变量的类型，如果加了括号，将被当成一个表达式。
**decltype（（variable））（注意是双层括号）的结果永远是引用，而decltype（variable）结果只有当variable本身就是一个引用时才是引用。**

---

### 六、自定义数据结构

1、类内部定义的名字必须唯一，但可以与类外部定义的名字重复。类的花括号形成了一个新的作用域。

2、一般不要把对象的定义和类的定义放在一起。

3、string 类型是字符的序列，操作有 >>、<< 和 ==，代表读入、写出和比较字符串。

4、类通常被定义在头文件中，且类所在头文件的名字应与类的名字一样。

5、预处理变量无视 C++ 语言中关于作用域的规则。