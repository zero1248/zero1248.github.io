---
title: 算法复杂度分析
tags:
  - 算法
abbrlink: f3215fef
date: 2019-03-08 15:55:01
---

---

《数据结构（C++语言版）》（邓俊辉编著）笔记

---

### 一、高效解



#### 1、常数复杂度（constant-time algorithm） O(1)



运行时间可表示和度量为 <font  color=#FF0000>  T(n) = O(1)</font> 的算法。通常不含循环、分支、子程序调用等。



仅需常数规模辅助空间的算法，称为就地算法（in-place algorithm）。

<!--more-->

#### 2、对数复杂度（logarithmic-time algorithm） O(logn)

- 常底数无所谓
  - log a n = log a b · log b n = Θ( log b n )
- 常数次幂无所谓
  - log n^c = c log n = Θ( log n )
- <font  color=#FF0000>对数多项式</font>（ploy-log function）
  - T( n ) = O( (logn)^c )
  - 忽略低次项



此类算法非常有效，复杂度无限接近于常数

- 任意 c>0，log n = O( n^c )
- 低于任何一个多项式的复杂度



举例：

```
int countones(unsigned int n){//统计整数n的二进制展开中数位1的总数：0（1ogn）
	int ones = e；
	while(e<n){
		ones += (1&n)；
		n >>= 1；
	return ones；
}
```



---

### 二、有效解



#### 1、线性复杂度（linear-time algorithm） O(n)



所有 O( n ) 类算法。

如迭代累加：

```
int sumI(int A[]，int n){
	int sum = e；
	for(inti=e；i<n；i++)
		sum += A[i]；
	return sum；
}  //0（1）+0（n）*O（1）+0（1）=0（n+2）=0（n）`
```



#### 2、多项式复杂度（polynomial-time algorithm） O( polynomial(n) )



O( n^c ) 类算法，低次项可忽略。



多项式复杂度被视作一个具有特殊意义的复杂度级别，实际应用中一般认为是可接受的。



---

### 三、难解



#### 1、指数复杂度（exponential-time algorithm） O( c^n )



运行时间可以表示和度量为 T(n) = O(a^n) 形式的算法。



通常认为，指数复杂度算法无法真正应用于实际问题中，它们不是有效算法，甚至不能称作算法。



---

### 四、复杂度层次



典型的复杂度层次包括：

O( 1 )

O( log * n )

O( loglogn )

O( logn )

O( sqrt(n) )

O( n )

O( nlog * n )

O( nloglogn )

O( nlogn )

O( n^2 )

O( n^3 )

O( n^c )

O( 2^n )



---

### 五、输入规模



待计算问题的输入规模，应严格定义为：用以描述输入所需的空间规模。



有些情况下，以输入参数 n 本身的数值作为基准而得出的 O( logn ) 和 O( n ) 复杂度，应分别称为伪对数的（pseudo-logarithmic）和伪线性的（pseudo-linear）复杂度。



例如：

```
__int4 power2BF_I(int n){
	__int64 pow = 1；
    while（e<n--）
        pow <<= 1;
	return pow；
}
```

此程序如果以 n 本身数值作为基准，复杂度为 O( n )。但如果以输入参数 n 的二进制展开的宽度 r 作为输入规模，则为 O( 2^r )，这样也更为合理。