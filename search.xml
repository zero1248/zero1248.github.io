<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git 与 Github</title>
    <url>//blog/2019/02/20/Git%20%E4%B8%8E%20Github/</url>
    <content><![CDATA[<hr>
<h3 id="〇、Github-与-Git-的关系"><a href="#〇、Github-与-Git-的关系" class="headerlink" title="〇、Github 与 Git 的关系"></a>〇、Github 与 Git 的关系</h3><h4 id="1、Git-与-Github-简介"><a href="#1、Git-与-Github-简介" class="headerlink" title="1、Git 与 Github 简介"></a>1、Git 与 Github 简介</h4><ul>
<li>Git 是一款免费、开源的分布式版本控制系统</li>
<li>GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。另外还有其他的平台，如国内的 <a href="https://gitee.com/" target="_blank" rel="noopener">码云</a> </li>
<li>Git 负责本地的代码版本控制，而 Github 负责远程托管</li>
</ul>
<a id="more"></a>
<h4 id="2、Git-的工作流程："><a href="#2、Git-的工作流程：" class="headerlink" title="2、Git 的工作流程："></a>2、Git 的工作流程：</h4><ul>
<li><p>1）在工作目录（Working Directory）中修改文件。</p>
</li>
<li><p>2）暂存文件，将文件的快照放入暂存区域（Staging Area）。</p>
</li>
<li><p>3）提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录（Repository）。</p>
</li>
<li><p>其中：</p>
<ul>
<li>Git <strong>仓库目录 </strong> 是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</li>
<li><strong>工作目录</strong> 是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li>
<li><strong>暂存区域</strong> 是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区域。</li>
</ul>
<p><a href><img src="https://i.loli.net/2019/02/22/5c6f7b352931b.png" alt="1550655399046"></a></p>
</li>
</ul>
<h4 id="3、Git-与-Github关系图示："><a href="#3、Git-与-Github关系图示：" class="headerlink" title="3、Git 与 Github关系图示："></a>3、Git 与 Github关系图示：</h4><p><img src="https://i.loli.net/2019/02/22/5c6f7b3522b74.png" alt="1550656393570"></p>
<hr>
<h3 id="一、注册-Github-账号"><a href="#一、注册-Github-账号" class="headerlink" title="一、注册 Github 账号"></a>一、注册 Github 账号</h3><p>注册没有难度，这里不赘述，建议使用简单大方的用户名和注册邮箱，方便后期使用。</p>
<p>网址： <a href="https://github.com/" target="_blank" rel="noopener">Github</a></p>
<hr>
<h3 id="二、下载安装-Git"><a href="#二、下载安装-Git" class="headerlink" title="二、下载安装 Git"></a>二、下载安装 Git</h3><p>网址： <a href="https://book.git-scm.com/downloads" target="_blank" rel="noopener">Git</a> （如果链接打不开可在网上搜索其他下载站点）</p>
<p>软件安装也没有什么难度，安装完成之后在任意文件夹下右键出现 Git Bash Here 说明安装成功。</p>
<p>在任意文件夹中都可以使用 Git Bash Here，既可以将所有需要代码版本管理的项目放在同一个文件夹中，也可以分散在任意地方，建议前者。</p>
<p>关于 Git 的一些资料</p>
<p><a href="https://book.git-scm.com/docs" target="_blank" rel="noopener">Reference Manual</a>（可查看各种 Git 指令的说明）</p>
<p><a href="https://book.git-scm.com/book" target="_blank" rel="noopener">Pro Git</a> （Git 的详细介绍）</p>
<hr>
<h3 id="三、安装-Git-后的配置"><a href="#三、安装-Git-后的配置" class="headerlink" title="三、安装 Git 后的配置"></a>三、安装 Git 后的配置</h3><h4 id="1、如果是个人使用"><a href="#1、如果是个人使用" class="headerlink" title="1、如果是个人使用"></a>1、如果是个人使用</h4><p>大部分配置可以暂时忽略，仅设置用户名称和邮件地址即可：</p>
<p>通过 Git Bash Here 进入命令行界面，输入：</p>
<p><code>git config --global user.name &quot;YourName&quot;</code>  （引号不可省略）</p>
<p><code>git config --global user.email YourEmail</code></p>
<p>YourName 和 YourEmail 设置成你 Github 里注册的用户名和邮箱。</p>
<p><strong>这里的设置是为了让 Github 根据用户名和邮箱去确定代码上传者的信息，也可以只设置其中一个。</strong></p>
<h4 id="2、如果是团队使用"><a href="#2、如果是团队使用" class="headerlink" title="2、如果是团队使用"></a>2、如果是团队使用</h4><p>若需要设置统一的提交信息格式，可以创建一个模板文件，通过 commit.template 来设置模板文件。</p>
<p>也可以通过 core.editor 修改编辑<strong>提交信息</strong>的默认编辑器。</p>
<p>详情都请查看 <a href="https://book.git-scm.com/docs" target="_blank" rel="noopener">Reference Manual</a> 中的 <a href="https://book.git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-%E9%85%8D%E7%BD%AE-Git" target="_blank" rel="noopener">自定义 Git - 配置 Git</a> ，也可以输入 <code>git config</code> 自行探索。</p>
<hr>
<h3 id="四、创建自己的代码仓库"><a href="#四、创建自己的代码仓库" class="headerlink" title="四、创建自己的代码仓库"></a>四、创建自己的代码仓库</h3><h4 id="1、在-Github-上创建-Repository"><a href="#1、在-Github-上创建-Repository" class="headerlink" title="1、在 Github 上创建 Repository"></a>1、在 Github 上创建 Repository</h4><p>1）点击 Github 页面右上角 “+” 号，点击 New repository</p>
<p><img src="https://i.loli.net/2019/02/22/5c6f7b3519899.png" alt="1550660057745"></p>
<p>2）填写基本信息后，点击 Create repository</p>
<p><img src="https://i.loli.net/2019/02/22/5c6f7b3540ee4.png" alt="1550660339034"></p>
<p>3）建成的仓库如下图</p>
<p><img src="https://i.loli.net/2019/02/22/5c6f7c69a0e58.png" alt="1550660390202"></p>
<ul>
<li><p>README.md 文件是 markdown 格式的文件，通常用来描述项目信息（可以看看其他人是怎么写的），可以后期自己建立并上传。Github 会显示根目录下的 md 文件内容。</p>
</li>
<li><p>如果需要删除代码仓库，点击上图中的 Settings，在页面最下方的 Danger Zone 中有 Delete  this repository 按钮。</p>
</li>
</ul>
<h4 id="2、在本地建立-Repository"><a href="#2、在本地建立-Repository" class="headerlink" title="2、在本地建立 Repository"></a>2、在本地建立 Repository</h4><h5 id="添加-SSH-key"><a href="#添加-SSH-key" class="headerlink" title="添加 SSH key"></a>添加 SSH key</h5><h6 id="Github-的仓库链接有两种格式："><a href="#Github-的仓库链接有两种格式：" class="headerlink" title="Github 的仓库链接有两种格式："></a>Github 的仓库链接有两种格式：</h6><ul>
<li>https 格式，例如 <a href="https://github.com/YourName/YourRepo.git" target="_blank" rel="noopener">https://github.com/YourName/YourRepo.git</a> </li>
<li><p>SSH 格式，例如 <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:YourName/YourRepo.git</p>
</li>
<li><p>两种形式的地址都可以用于 Github 与本地 Git 建立连接，但是如果用的是 https，每次上传代码的时候，都需要输入 Github 用户名和密码，因此<strong>建议使用 SSH</strong>。</p>
</li>
</ul>
<h6 id="生成-SSH-key-的步骤："><a href="#生成-SSH-key-的步骤：" class="headerlink" title="生成 SSH key 的步骤："></a>生成 SSH key 的步骤：</h6><ul>
<li>提示： Git Bash 命令行界面中，复制/粘贴的快捷键分别是 Ctrl+Ins 和 Shift+Ins</li>
</ul>
<p>1&gt; 在任意文件夹内右击，选择 Git Bash Here，进入命令行界面。</p>
<p>2&gt; 输入 <code>ssh-keygen -t rsa -C &quot;YourEmail@YourEmail.com&quot;</code></p>
<p>​    引号内是 Github 的登录邮箱，引号不能省略。</p>
<p>3&gt; 一般不建议修改 SSH Key 的保存目录，因此连按三下回车，选择默认路径以及无密码。从提示信息中可以找到你的电脑上 SSH Key 的保存位置。</p>
<p>4&gt; 从 3&gt; 中的保存位置找到 id_rsa.pub 文件，通常路径为 <code>C:\Users\Administrator\.ssh</code>，用记事本或其他编辑软件打开并复制里面的内容。也可以在 Git Bash 命令行界面中输入 clip &lt; ~/.ssh/id_rsa.pub 后按回车，若无错误提示表示复制成功。</p>
<p>5&gt; 打开 Github，鼠标指向自己的头像，选择 Settings。</p>
<p>6&gt; 在左边栏中选择 SSH and GPG keys，点击 New SSH Key，添加复制的 SSH Key 即可。如果个人有多台电脑，为了方便区分，SSH Key 的 Title 取一个辨识度较高的名字。</p>
<p>7&gt; Git Bash 命令行界面中输入 <code>ssh -T git@github.com</code></p>
<p>​    问是否继续连接，输入 yes ，按回车。</p>
<p>​    如果出现 <code>Hi YourName! You&#39;ve successfully authenticated, but GitHub does not ...</code> 说明设置成功了。</p>
<h5 id="本地建立-Repository"><a href="#本地建立-Repository" class="headerlink" title="本地建立 Repository"></a>本地建立 Repository</h5><h6 id="方法一：（git-clone-指令）"><a href="#方法一：（git-clone-指令）" class="headerlink" title="方法一：（git clone 指令）"></a>方法一：（git clone 指令）</h6><p>使用 git clone 指令可以直接将 Github 上的代码仓库（可以是新建的，也可以是已经有内容的） clone 到本地仓库。</p>
<p>步骤如下：</p>
<p>1&gt; 在 Github 页面进入准备 clone 到本地的代码仓库，点击如下图①位置的 Clone or download 即可复制代码仓库链接。注意应使用 SSH 格式的链接，在②位置可以切换两种格式。</p>
<p><img src="https://i.loli.net/2019/02/22/5c6f7b3549236.png" alt="1550770191930"></p>
<p>2&gt; 在欲存放代码的地方进入 Git Bash（不需要自己再建立文件夹），输入 <code>git clone git@github.com:YourName/YourRepo.git</code>（复制的仓库链接），即可完成本地仓库的建立。此时可直接上传新的代码文件至 Github，具体操作见后文。 </p>
<p>注意：如果选择了 https 格式的地址，想修改成 SSH 格式的地址，可以按照以下步骤操作：</p>
<p>git remote rm origin # 移除当前远端服务器</p>
<p>git remote -v # 查看当前 Github 仓库服务器地址，无返回信息说明已移除</p>
<p>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:YourName/YourRepo.git # 添加 SSH 格式地址</p>
<p>git remote -v # 再次查看当前 Github 仓库服务器地址，是否已修改成功</p>
<h6 id="方法二：（git-init-指令）"><a href="#方法二：（git-init-指令）" class="headerlink" title="方法二：（git init 指令）"></a>方法二：（git init 指令）</h6><p>使用 git init 指令可以在本地初始化一个代码仓库，然后与 Github 上的代码仓库进行连接，操作如下：</p>
<p>1&gt; 在欲存放代码的地方建立项目文件夹，进入该文件夹后右击进入 Git Bash，输入 <code>git init</code>，可以看到此时在文件夹中生成了一个隐藏的 .git 文件夹，此文件夹内存放着此代码仓库的各种信息。</p>
<p>2&gt; 如果在安装好 Git 后已经配置了用户名和邮箱，此步骤可跳过，否则输入</p>
<p><code>git config --global user.name &quot;YourName&quot;</code>  （引号不可省略）</p>
<p><code>git config --global user.email YourEmail</code>    </p>
<p>3&gt; 输入 <code>git remote add origin git@github.com:yourName/yourRepo.git</code>，依旧建议使用 SSH 格式地址。此时就建立起了与 Github 服务器的连接。</p>
<p>在方法一中，由于是直接 clone 远端的 Github 仓库的内容，所以无论是新建的 Github 仓库，还是已经上传过内容的 Github 仓库，都可以完整地克隆到本地。</p>
<p>但在方法二中，由于是从本地先初始化了一个代码仓库，仓库中无任何内容，所以如果本地仓库中的内容和 Github 仓库中的内容不一致（例如 Github 仓库初始化时生成了 README.md 文件），就需要先把 Github 仓库中的内容下载（pull）到本地，保持两者的一致性之后，才能上传（push）代码到 Github 仓库，具体操作是输入 <code>git pull origin master</code> ，等代码下载完成，即可添加新内容并上传。</p>
<hr>
<h3 id="五、简单-Git-操作指令"><a href="#五、简单-Git-操作指令" class="headerlink" title="五、简单 Git 操作指令"></a>五、简单 Git 操作指令</h3><h4 id="1、push-代码到-Github"><a href="#1、push-代码到-Github" class="headerlink" title="1、push 代码到 Github"></a>1、push 代码到 Github</h4><p>假设要 push 一个名为 123.txt 的文件，在项目文件夹中进入 Git Bash，分别输入以下内容：</p>
<p><code>git add 123.txt  # 将文件内容添加到缓存区快照</code></p>
<p><code>git commit -m &quot;123.txt&quot; # 将改动点记录到代码仓</code></p>
<p><code>git push origin master # 将改动提交到 Github 远端服务器，分支为 master</code></p>
<p>说明：</p>
<ul>
<li><p>若一次提交多个文件，可使用 <code>git add .</code> ，注意 “.” 不能省略</p>
</li>
<li><p>第二行中引号内的内容是提交信息，会显示在 Github 上，如果需要提交很多信息，输入 <code>git commit</code> 即可，会弹出默认编辑器 GUN nano，如果不会使用该编辑器，可以运行 <code>git config --global core.editor &quot;F：\Program Files\Sublime Text 3\sublime text.exe&quot;</code> ，其中引号中是想修改的新编辑器的路径，根据自己电脑上的位置修改。</p>
</li>
<li><p>master 是指该仓库的 master 分支，关于分支的概念请参考 Git 官网。</p>
</li>
</ul>
<h4 id="2、从-Github-pull-代码"><a href="#2、从-Github-pull-代码" class="headerlink" title="2、从 Github pull 代码"></a>2、从 Github pull 代码</h4><p><code>git pull origin master</code></p>
<h4 id="3、查看工作目录状态"><a href="#3、查看工作目录状态" class="headerlink" title="3、查看工作目录状态"></a>3、查看工作目录状态</h4><p><code>git status</code></p>
<p>以上几个指令是个人使用时最常用的指令，如果多人合作，或 fork 其他人的项目，可以从官网查询其他指令。</p>
]]></content>
      <tags>
        <tag>软件使用</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 随笔</title>
    <url>//blog/2019/02/22/2018-%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<hr>
<p><img src="https://i.loli.net/2019/02/22/5c7009ac95f91.jpg" alt="214599.jpg"></p>
<a id="more"></a>
<p>12.29</p>
<p>编造的历史于作者和读者都有益，但于真相和真理无益。</p>
<p>12.26</p>
<p>笛卡尔用坐标系帮我们打开了数学世界的大门，也把我们牢牢束缚在了看不见的坐标系中。帮我们认识了三维世界，也把我们困在了三维世界中。</p>
<p>12.17</p>
<p>减少知识记忆，提高创新能力和复杂事物沟通能力。当下一个爱因斯坦诞生的时候，我们能不能听懂他的话？</p>
<p>12.16</p>
<p>西方民主是一种产物，而不是其他事物的原因。</p>
<p>12.08</p>
<p>多折腾事，少折腾人。</p>
<p>11.27</p>
<p>靠想象力创造是件好事，但是靠想象力说话就算了。</p>
<p>11.24</p>
<p>一见如故易，再见如初难。</p>
<p>很少有人会选择多米诺骨牌式的人生 —— 用尽一生去码牌，只为了最后推倒那一刻。</p>
<p>11.15</p>
<p>摩擦力的存在，让我们用了很长时间才认识到运动的本质规律，如果不存在摩擦力，动力学的研究工作可能会提早很多年，因为现象与本质都显而易见了。有些事物的表象与根因相去甚远，甚至看起来毫无联系，这也正是科研探索的难点和乐趣所在。</p>
<p>当你选择了走捷径，这条捷径有可能就成了你唯一的路。</p>
<p>11.13</p>
<p>干一行爱一行的根本原因是只有干好了，才会感兴趣。</p>
<p>11.13</p>
<p>一千年后，古代 APP 在古玩市场交易火热。。。</p>
<p>11.03</p>
<p>大学那会的加分条，是不是就和快递单上的“此人是国家栋梁，请优先配送”一个道理。</p>
<p>11.02</p>
<p>表达者的宿命是被误会。</p>
<p>10.30</p>
<p>可喜的是，今天阳光明媚，难过的是，这太阳是 8 分钟前的。</p>
<p>10.29</p>
<p>藏弓早，借剑难。</p>
<p>10.26</p>
<p>从来不学习的天才，以及没有天分的学习者，都不能成为大师。</p>
<p>10.25</p>
<p>真正的隐士，都是入世的强者。</p>
<p>10.22</p>
<p>只学了如何相遇，没有学如何告别。</p>
<p>很多时候快乐只不过是被多巴胺和荷尔蒙欺骗而产生的错觉，并不是真正的快乐，只是化学过程的搬运工。</p>
<p>10.21</p>
<p>雪中不送炭，锦上别添花。</p>
<p>09.25</p>
<p>君子不立危墙之下。</p>
<p>09.24</p>
<p>目的通常是复合的。</p>
<p>09.23</p>
<p>许多所谓的规格，无非是成年社会为了省心而承袭的惯性。</p>
<p>怕就怕，坐在井底还闭着眼。</p>
<p>09.23</p>
<p>余生漫长，你不要慌。</p>
<p>09.22</p>
<p>善弈者通盘无妙手。</p>
<p>善战者无赫赫之功，善医者无煌煌之名。</p>
<p>09.08</p>
<p>成熟的重要标志之一是知道什么时候动脑，什么时候动心。</p>
<p>09.05</p>
<p>投机者都在所谓的创新领域，因为这里的东西好抄。</p>
<p>08.29</p>
<p>在光的眼里，我们是什么样？</p>
<p>08.28</p>
<p>一些整天不说话的职业非常容易导致个体情绪激动。</p>
<p>不是时间约束了我们，而是我们约束了时间。</p>
<p>没有认识到玻璃的重要性，是几百年前中国与西方拉开差距的重要原因。</p>
<p><img src="https://i.loli.net/2019/02/22/5c700a6b62c6a.jpg" alt="284105.jpg"></p>
<p>08.21</p>
<p>吾生有涯而（小）知无涯</p>
<p>08.12</p>
<p>每一次发明时光机之后的世界都不存在了。</p>
<p>08.06</p>
<p>远见超出能力的时候，再去做管理。</p>
<p>07.27</p>
<p>思考是找答案，学习是找问题。</p>
<p>07.20</p>
<p>素人一本书，大师一句话。</p>
<p>07.19</p>
<p>努力不够，朋友圈来凑。</p>
<p>07.17</p>
<p>聪明人需要笨功夫，不够聪明的需要走捷径。</p>
<p>07.15</p>
<p>有缘相会，无缘幸会。</p>
<p>07.13</p>
<p>你必须非常努力，才能知道自己是真的不行。</p>
<p>07.10</p>
<p>奴性是社会组成的一部分。</p>
<p>07.09</p>
<p>朋友圈三日可见 —— 士别三日当刮目相待。</p>
<p>07.08</p>
<p>除掉恶龙最好的办法就是不唤醒心中的恶龙。</p>
<p>正确答案闪闪发光，我选择视而不见。</p>
<p>不敢发火，怕点着肚子里的草，不过也无所谓，毕竟有脑子里的水。</p>
<p>06.28</p>
<p>靠经济萧条切入市场的小企业，能在下一次萧条中活下来才是真正有价值的公司。</p>
<p>06.28</p>
<p>新品牌的崛起很多都是靠用户对老品牌的不满。</p>
<p>06.22</p>
<p>你看中人家的利息，人家看中你的本金。</p>
<p>06.21</p>
<p>加班就像借钱， 救急不救穷。</p>
<p>06.17</p>
<p>慢慢来，是最快的。</p>
<p>06.16</p>
<p>听从你心，无问西东。</p>
<p>06.14</p>
<p>民主和专制貌似已无法概括现今的政治制度了。</p>
<p>06.12</p>
<p>我们这一代很多人的梦想，已经从儿女双全变成猫狗双全了。</p>
<p>06.06</p>
<p>德不配位，必有灾殃</p>
<p>06.03</p>
<p>在全是蚊子的房间里，我才是外人。</p>
<p>05.31</p>
<p>没见过世面的老实人，未必是真老实。</p>
<p>05.28</p>
<p>物联网的真正崛起，不仅需要 5G 和微电子的崛起，还需要一场世界范围的金融危机。</p>
<p>05.27</p>
<p>一点就炸，弱者心态。</p>
<p>05.21</p>
<p>世界第一之前喜欢国外文化那叫崇洋媚外，世界第一之后就叫兼容并包。</p>
<p>人在看到他人遭遇无法改变的苦难时，会将苦难合理化，轮到自己时，总会抱怨命运的不公。</p>
]]></content>
      <tags>
        <tag>心花路放</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430 IO</title>
    <url>//blog/2019/02/22/MSP430-IO/</url>
    <content><![CDATA[<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>上电后寄存器状态为输入高电平。</p>
<p>改变 PxOUT 或 PxDIR 时 PxIFG 标志将置位。</p>
<p>向 PxIES 写入数据将导致相应的中断标志置位。</p>
<a id="more"></a>
<p>只置位 PxSELx 不能自动设置引脚方向。其他外设模块需要跟据模块功能配置 PxDIRx，改变引脚方向。</p>
<font color="#FF0000"> 开启外部中断时，要先设置 OUT、DIR、IES，然后复位 IFG，最后开中断。 </font>

<p>msp430x14x、x15x、x16x的 P1、P2 口具有中断能力。</p>
<p>未使用的IO引脚应配置成IO功能，输出方向，并连接在PCB板上，以降低功耗。PxOUT位的值无所谓，因为其引脚未连接。</p>
<p>未使用的引脚的正确连接方式：</p>
<p><img src="https://i.loli.net/2019/02/22/5c6fb3c7b5cc8.png" alt="1550824357362"></p>
<h3 id="MSP430-IO-特点"><a href="#MSP430-IO-特点" class="headerlink" title="MSP430 IO 特点"></a>MSP430 IO 特点</h3><ul>
<li><p>独立的可编程 IO</p>
</li>
<li><p>同组 IO 口输入输出任意组合</p>
</li>
<li><p>P1、P2 中断独立配置</p>
</li>
<li><p>输入输出数据寄存器独立</p>
</li>
</ul>
<h3 id="一、输入寄存器-PxIN"><a href="#一、输入寄存器-PxIN" class="headerlink" title="一、输入寄存器 PxIN"></a>一、输入寄存器 PxIN</h3><p>Bit = 0 ： 输入为低</p>
<p>Bit = 1 ： 输入为高</p>
<p>PxIN是只读寄存器，执行写入指令将增加电流消耗。</p>
<h3 id="二、输出寄存器-PxOUT"><a href="#二、输出寄存器-PxOUT" class="headerlink" title="二、输出寄存器 PxOUT"></a>二、输出寄存器 PxOUT</h3><p>Bit = 0 ： 输出为低</p>
<p>Bit = 1 ： 输出为高</p>
<h3 id="三、方向寄存器-PxDIR"><a href="#三、方向寄存器-PxDIR" class="headerlink" title="三、方向寄存器 PxDIR"></a>三、方向寄存器 PxDIR</h3><p>PxDIR 的每一位用来选择相应引脚的方向，无论选择了什么第二功能。</p>
<p>如果 IO 开启了第二功能，必须根据需要来设置相应的方向。</p>
<p>Bit = 0 ： 输入方向</p>
<p>Bit = 1 ： 输出方向</p>
<h3 id="四、功能选择寄存器-PxSEL"><a href="#四、功能选择寄存器-PxSEL" class="headerlink" title="四、功能选择寄存器 PxSEL"></a>四、功能选择寄存器 PxSEL</h3><p>端口引脚经常复用作其他内部外设模块功能。PxSEL 的每一位决定了引脚用作 IO 功能还是内部外设模块功能（第二功能）。</p>
<p>Bit = 0 ： IO功能</p>
<p>Bit = 1 ： 内部外设功能</p>
<p>只置位PxSELx不能自动设置引脚方向。其他外设模块需要跟据模块功能配置 PxDIRx，改变引脚方向。</p>
<p>PxSEL 置位时，中断关闭。</p>
<p>当引脚作为外设的输入时，输入到外设的信号在因脚伤经过一次锁存。当 PxSELx=1 时，内部输入信号跟随引脚上的输入信号。若 PxSELx=0，输入到外设的信号将维持引脚上的输入信号的值，直到 PxSELx 位重置。</p>
<ul>
<li>P1、P2 口可中断的器件<ul>
<li>通过配置 PxIFG、PxIE 和 PxIES 寄存器，P1 和 P2 口的每个引脚都能具有中断能力。所有的 P1 口引脚都使用一个单独的中断源，所有的 P2 引脚使用另一个单独的中断源。可以检测 PxIFG 来判断 P1 或 P2 中断。</li>
</ul>
</li>
</ul>
<h3 id="五、中断标志位寄存器-P1IFG，P2IFG"><a href="#五、中断标志位寄存器-P1IFG，P2IFG" class="headerlink" title="五、中断标志位寄存器 P1IFG，P2IFG"></a>五、中断标志位寄存器 P1IFG，P2IFG</h3><p>选择的输入信号边沿出现在引脚上时，相应的中断标志会置位。相应的 PxIE 以及 GIE 置位后，所有 PxIFGx 中断标志都需要一个中断响应。PxIFG 必须由软件复位。软件也可以置位PxIFG，提供一种软件触发中断的方法。</p>
<p>Bit = 0 ： 无中断请求</p>
<p>Bit = 1 ： 中断请求</p>
<p>只有跳变能触发中断，而稳定的电平不能。如果任意 PxIFGx 在中断服务程序中置位，或者在中断服务程序执行 RETI 命令之后置位，PxIFGx 标志位将触发另一个中断。这样确保了每一个跳变得到响应。</p>
<font color="#FF0000">   改变 PxOUT 或 PxDIR 时 PxIFG 标志将置位。 </font>



<p>任何外部中断时间都应该至少是 MCLK 的 1.5 倍，以保证单片机能检测到并且中断标志置位。</p>
<h3 id="六、中断边沿选择寄存器-P1IES，P2IES"><a href="#六、中断边沿选择寄存器-P1IES，P2IES" class="headerlink" title="六、中断边沿选择寄存器 P1IES，P2IES"></a>六、中断边沿选择寄存器 P1IES，P2IES</h3><p>PxIES 用来选择中断 IO 引脚的中断边沿。</p>
<p>Bit = 0 ： 由低向高的跳变置位 PxIFGx</p>
<p>Bit = 1 ： 由高向低的跳变置位 PxIFGx</p>
<font color="#FF0000">   向 PxIES 写入数据将导致相应的中断标志置位。 </font>

<table>
<thead>
<tr>
<th style="text-align:center">PxIESx</th>
<th style="text-align:center">PxINx</th>
<th style="text-align:center">PxIFGx</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0→1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">May be set</td>
</tr>
<tr>
<td style="text-align:center">0→1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">Unchanged</td>
</tr>
<tr>
<td style="text-align:center">1→0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">Unchanged</td>
</tr>
<tr>
<td style="text-align:center">1→0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">May be set</td>
</tr>
</tbody>
</table>
<h3 id="七、中断使能寄存器P1IE，P2IE"><a href="#七、中断使能寄存器P1IE，P2IE" class="headerlink" title="七、中断使能寄存器P1IE，P2IE"></a>七、中断使能寄存器P1IE，P2IE</h3><p>Bit = 0 ： 中断关闭</p>
<p>Bit = 1 ： 中断使能</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>MSP430</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430 串口</title>
    <url>//blog/2019/02/22/MSP430-%E4%B8%B2%E5%8F%A3/</url>
    <content><![CDATA[<hr>
<p>MSP430 常见的 USART（universal synchronous/asynchronous receive/ransmit）接口通常有三种：UART、IIC、SPI。其中 UART（串口）是调试过程中最常用的接口，这里根据 User’s Guide 谈谈 MSP430x1xx 系列串口的使用。</p>
<a id="more"></a>
<p>在 UART 一章的开始，有这样一段文字：</p>
<p><img src="https://i.loli.net/2019/02/22/5c6fb7ad78699.png" alt="img"></p>
<p>可见，在 X14X 和 X16X 中，有两组串口，而 X12X 、X13X 和 X15X 中只有 UART0。使用不同型号，务必先查看手册中的资源介绍。</p>
<h3 id="一、Introduction"><a href="#一、Introduction" class="headerlink" title="一、Introduction"></a>一、Introduction</h3><p>本节一开始，有这样一段话：</p>
<p><img src="https://i.loli.net/2019/02/22/5c6fb8b4147a0.png" alt="img"></p>
<p>说明了UART提供两个接口：UTXD（发送）和URXD（接收），使用时只需要这两个引脚就可以与其他串口设备通信，但要注意的一点是，除了这两个引脚的连接外，两设备还必须共地，也就是说他们的GND也要连在一起，这是两设备成功通信的关键！</p>
<p>接下来介绍了该模块的特性：</p>
<p><img src="https://i.loli.net/2019/02/22/5c6fb8ed393ef.png" alt="img"></p>
<p>值得关注的几点是：</p>
<p>1、430 UART 的发送和接收移位寄存器都是独立的</p>
<p>2、发射和接收缓冲器是分离的，这一点不同于 51 单片机</p>
<p>3、低位优先发送和接收</p>
<h3 id="二、Operation"><a href="#二、Operation" class="headerlink" title="二、Operation"></a>二、Operation</h3><p>发送和接收使用相同的波特率。</p>
<p>PUC（上电清除）或SWRST置位会导致USART复位。</p>
<h4 id="1、上电复位后各位状态"><a href="#1、上电复位后各位状态" class="headerlink" title="1、上电复位后各位状态"></a>1、上电复位后各位状态</h4><p><img src="https://i.loli.net/2019/02/22/5c6fb93cad626.png" alt="img"></p>
<p>上面这段话给出了上电后，各标志位的初始状态：</p>
<p>1）USART 自动置位（置1）</p>
<p>2） URXIEx、UTXIEx、URXIFGx、RXWAKE、TXWAKE、RXERR、BRK、PE、OE 和 FE 复位（置0）</p>
<p>3） UTXIFGx、TXEPT 置位</p>
<p>4） URXEx 和 UTXEx 不受影响</p>
<p>清除 SWRST 将允许操作 USART。</p>
<h4 id="2、初始化或重配置顺序"><a href="#2、初始化或重配置顺序" class="headerlink" title="2、初始化或重配置顺序"></a>2、初始化或重配置顺序</h4><p><img src="https://i.loli.net/2019/02/22/5c6fb9e5da6c4.png" alt="img"></p>
<p>1）SWRST 置位（置1）</p>
<p>2）在 SWRST=1 的前提下初试化各个 USART 寄存器</p>
<p>3）通过 MEx 特殊功能寄存器使能 USART 模块</p>
<p>4）软件清除 SWRST（置0）</p>
<p>5）通过 IEx 特殊功能寄存器使能中断</p>
<h4 id="3、字符格式"><a href="#3、字符格式" class="headerlink" title="3、字符格式"></a>3、字符格式</h4><p><img src="https://i.loli.net/2019/02/22/5c6fbb36cc550.png" alt="img"></p>
<p>起始位 – 7 或 8 位数据位 – 地址位 – 奇偶校验位 – 1 或 2 位停止位。由波特率寄存器设置。</p>
<h4 id="4、异步通信格式"><a href="#4、异步通信格式" class="headerlink" title="4、异步通信格式"></a>4、异步通信格式</h4><p>双机通信时，使用空闲总线模式。多机通信时，支持空闲总线模式和地址位处理模式。</p>
<h5 id="1）空闲总线多处理机模式（MM-0）"><a href="#1）空闲总线多处理机模式（MM-0）" class="headerlink" title="1）空闲总线多处理机模式（MM=0）"></a>1）空闲总线多处理机模式（MM=0）</h5><p><img src="https://i.loli.net/2019/02/22/5c6fbbf2bfed8.png" alt="img"></p>
<p>两个数据块之间隔了一个大于 10 个时钟的空闲时间，而数据块内的数据之间的间隔小于 10 个时钟。在前一个字符的的第一个停止位之后又接收了 10 或者更多连续的时钟后，将检测接收总线。当使用 2 个地址位时，第二个地址位将作为空闲周期的第一个标志。</p>
<p>一个空闲周期之后的第一个接收到的数据是地址字符。RXWAKE 位用来标志每个数据块的地址位。空闲总线模式下，当接收到地址并且传送至 UxRXBUF 时，该位将置位。</p>
<p>URXWIE 位用来控制数据接收。当该位置位时，所有的非地址字符被收集，但是不移送至 UxRXBUF 中，也不触发中断。接收到地址字符时接收器将暂时激活将字符传送至 UxRXBUF 中并且置位 URXIFGx 中断标志。任何满足条件的错误标志位也将置位。用户可以验证接收地址。</p>
<p>如果接收到一个地址字符，用户可以软件验证地址，并且必须复位 URXWIE 以保证继续接收数据。如果保持置位，将只接收地址字符。URXWIE 位不会由硬件自动修改。</p>
<p>在空闲总线模式下，可以由 USART 产生一个精准的空闲周期去产生 UTXDx 中的地址字符标志符来传送地址。WUT 暂时唤醒标志是一个由用户可访问的TXWAKE位双缓存的内部标志。当发送器从 UxTXBUF 中载入数据，WUT 也从 TXWAKE 中载入，并复位 TXWAKE。</p>
<p>以下步骤可以传送一个空闲帧表明后面是地址字符：</p>
<p>1&gt; 置位 TXWAKE，然后向 UxTXBUF 写入任意字符。UxTXBUF 必须准备好接收新字符（UTXIFGx = 1）。</p>
<p>TXWAKE 值移入 WUT，当 UxTXBUF 准备好接收新数据时，UxTXBUF 的内容被移入发送移位寄存器。这将置位WUT，抑制正常传输中的起始位、数据位、奇偶校验位。然后发送大约十一位的空闲周期。当使用两个地址位时，第二个地址位将作为空闲周期的第一个标志。TXWAKE 自动复位。</p>
<p>2&gt; 向 UxTXBUF 中写入所需地址字符。UxTXBUF 必须准备好接收新字符（UTXIFGx = 1）。</p>
<p>在 UTXDx 的地址标志空闲周期之后，代表了特殊地址的新字符被发出。必须向 UxTXBUF 写入第一个任意字符，这是为了将 TXWAKE 位移入 WUT 并触发空闲总线条件。这个数据并不重要，也不会出现在 UTXDx 上。</p>
<h5 id="2）地址位多处理机模式（MM-1）"><a href="#2）地址位多处理机模式（MM-1）" class="headerlink" title="2）地址位多处理机模式（MM=1）"></a>2）地址位多处理机模式（MM=1）</h5><p>每个数据包含一个额外的位用于地址表示。数据块中的第一个字符带有一个置位的地址位表明这个字符是地址。当接收到字符是一个有效的地址字符且被移入 UxRXBUF 中，USART 的 RXWAKE 位将被置位。</p>
<p>URXWIE 位用来控制数据接收。当该位置位时，数据字符（地址位=0）将被接收器接收但不送入 UxRXBUF 并且不触发中断。当收到一个包含了地址位置位的字符时，接收器暂时唤醒将字符传送到 UxRXBUF 并将 URXIFGx 置位。所有满足条件的状态错误标志也会被置位。</p>
<p>如果接收到一个地址，用户必须软件复位URXWIE以保证继续接收数据。如果 URXWIE 保持置位，值有地址字符（地址位=1）可以倍接收。URXWIE 位不会有 USART 硬件自动改变。</p>
<p>在地址位模式下发送地址数据时，一个字符的地址位可以通过写入 TXWAKE 位来控制。TXWAKE 位的值将被载入从UxTXBUF 传送到移位寄存器的字符的地址位，然后自动清除 TXWAKE 位。TXWAKE 不能软件复位，它将在传送至 WUT 或被 SWRST 置位后有 USART 硬件清零。</p>
<h5 id="3）自动错误检测"><a href="#3）自动错误检测" class="headerlink" title="3）自动错误检测"></a>3）自动错误检测</h5><p>参看User’s Guide。</p>
<h4 id="5、USART接收使能"><a href="#5、USART接收使能" class="headerlink" title="5、USART接收使能"></a>5、USART接收使能</h4><p><img src="https://i.loli.net/2019/02/22/5c6fbd113b5d8.png" alt="img"></p>
<p>从状态转移图可以清楚的看出 URXEx 对接收的影响。</p>
<h4 id="6、USART发送使能"><a href="#6、USART发送使能" class="headerlink" title="6、USART发送使能"></a>6、USART发送使能</h4><p><img src="https://i.loli.net/2019/02/22/5c6fbd4edc15d.png" alt="img"></p>
<p>​     </p>
<p>当 UTXEx 置位时，UART 发送器使能。向 UxTXBUF 写入数据将发起发送。数据将在 TX 移位寄存器置空的下一个 BITCLK 被送进去，然后发送开始。</p>
<p>当 UTXEx 位复位时发送终止。任何移入 UxTXBUF 的数据和任何正在发送移位寄存器中进行的数据发送，若先于清空 UTXEx 的操作，都将继续进行发送，直到所有的数据发送完毕。</p>
<p><img src="https://i.loli.net/2019/02/22/5c6fbdb591472.png" alt="img"></p>
<p>当发送器被使能（UTXEx=1），数据不应该被写入 UxTXBUF，除非 UxTXBUF 已经准备好接收新数据，表现为 UTXIFGx=1。如果 UxTXBUF 中的数据在它将被送至发送寄存器时被修改，这一扰乱将导致错误的发送。</p>
<p>完成所有发送后，发送器需要关闭（UTXEx=0），表现为发送器清空标志位置位（TXEPT = 1）。在发送器关闭时，任何写入 UxTXBUF 的数据都将被保存在缓冲器中，但是不会移入发送移位寄存器或者被发送。一旦 UTXEx 被置位，发送缓存里的数据立即被载入发送移位寄存器中，而且数据发送重新开始。</p>
<h4 id="7、UART波特率产生"><a href="#7、UART波特率产生" class="headerlink" title="7、UART波特率产生"></a>7、UART波特率产生</h4><p>USART 波特率发生器是由不标准的时钟频率产生标准的波特率。波特率发生器使用一个预定标器/除法器和一个调制器。这个组合为波特率发生器提供小数除数因子。USART 的最大波特率是 UART 时钟频率 BRCLK 的三分之一。</p>
<p><img src="https://i.loli.net/2019/02/22/5c6fbeb2cc5f3.png" alt="img"></p>
<p><img src="https://i.loli.net/2019/02/22/5c6fbecf62cd1.png" alt="img"></p>
<p>波特率配置常数及误差：</p>
<p><img src="https://i.loli.net/2019/02/22/5c6fbf177d762.png" alt="img"></p>
<h4 id="8、USART中断"><a href="#8、USART中断" class="headerlink" title="8、USART中断"></a>8、USART中断</h4><p>USART有一个发送中断向量和一个接收中断向量。</p>
<h5 id="1）发送中断操作"><a href="#1）发送中断操作" class="headerlink" title="1）发送中断操作"></a>1）发送中断操作</h5><p>发送器置位 UTXIFGx 中断标志位，表明 UxTXBUF 准备好接收另一个字符。如果 UTXIEx 和GIE 置位，也会触发一个中断请求。若中断请求得到响应或者一个字符写入 UxTXBUF，UTXIFGx 将自动复位。</p>
<p>UTXIFGx 在 PUC 之后或 SWRST=1 时都会被置位。</p>
<p><img src="https://i.loli.net/2019/02/22/5c6fbf6c3b1f2.png" alt="img"></p>
<h5 id="2）接收中断操作"><a href="#2）接收中断操作" class="headerlink" title="2）接收中断操作"></a>2）接收中断操作</h5><p>每次接收到一个数据并载入 UxRXBUF 都会置位 URXIFGx 中断标志。如果 URXIEx 和 GIE 置位，也会触发一个中断请求。URXIFGx 和 URXIEx 会在系统复位信号 PUC 之后或 SWRST=1 时复位。若悬而未决的中断得到响应（当 URXSE=0）或者当 UxRXBUF 被读取时，URXIFGx 将自动复位。</p>
<p><img src="https://i.loli.net/2019/02/22/5c6fbfa5e7432.png" alt="img"></p>
<p>URXEIE 用来使能或关闭置位 URXIFGx 造成的错误字符。在使用地址位模式时，URXWIE 用来自动检测有效的地址字符和拒绝不需要的数据字符。</p>
<p>两种字符不能置位 URXIFGx：当 URXEIE=0 时的错误字符，当 URXWIE=1 时的非地址字符。</p>
<p>当 URXEIE=1 一个 break 条件将置位 BRK 位和 URXIFGx 标志。</p>
<h5 id="3）接收起始边沿检测操作"><a href="#3）接收起始边沿检测操作" class="headerlink" title="3）接收起始边沿检测操作"></a>3）接收起始边沿检测操作</h5><p>URXSE 位使能接收起始边沿检测特性。当 BRCLK 由 DCO 提供，以及当 DCO 因为低功耗模式而关闭时，推荐使用接收开始边沿特性。DCO 的超快振荡允许在起始边沿检测之后接收字符。</p>
<p>当 URXSE，URXIEx 和 GIE 置位，并且一个起始边沿出现在 URXDx，内部信号 URXS 将会置位。当 URXS 置位，将会触发一个接收中断请求，但 URXIFGx 不会置位。用户在接收中断服务程序中可以检测 URXIFGx 来判断中断源。当 URXIFGx=0，检测起始边沿；当 URXIFGx=1，接收一个有效的字符（或 break）。</p>
<p>当中断服务函数判断中断请求来自起始边沿，用户软件触发 URXSE，而且必须从中断服务函数中返回有效的模式或一个 BRCLK 激活的低功耗模式，以使能 BRCLK。如果中断服务函数返回到一个 BRCLK 未激活的低功耗模式，字符不能被接收。触发 URXSE 清除 URXS 信号并将为未来的字符重新使能起始边沿检测。</p>
<p>当前激活的 BRCLK 允许 USART 接收字符。接收完一个字符并送入 UxRXBUF 之后，URXIFGx 将置位，并请求一个中断服务。在中断服务函数入口，URXIFGx=1 表明接收到一个字符。当用户软件读取 UxRXBUF 时 URXIFGx 标志被清除。</p>
<p>当使用接收边沿检测时，若BRCLK关闭，将不能检测到break条件。</p>
<h5 id="4）接收起始边沿检测条件"><a href="#4）接收起始边沿检测条件" class="headerlink" title="4）接收起始边沿检测条件"></a>4）接收起始边沿检测条件</h5><p>当 URXSE=1 时，故障将抑制阻止 USART 被意外启动。URXDs 的任何一个比抗尖峰脉冲时间（大约300ns）短的低电平都会被 USART 忽视而不会触发中断请求。</p>
<p>当一个故障时间长于抗尖峰脉冲时间，或一个有效的起始位出现在 URXDx，USART 接收将启动，且会进行一个多数投票。如果多数投票认为没有检测到的不是起始位，将会中断字符接收。</p>
<p>如果字符接收中断，就没有必要激活 BRCLK。软件可以通过一个比字符接收持续时间长的延时周期来表明没有在预期周期内接收到字符，且软件可以关闭 BRCLK。</p>
<h3 id="三、Registers"><a href="#三、Registers" class="headerlink" title="三、Registers"></a>三、Registers</h3><p>寄存器详细内容参考相应手册。</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>MSP430</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430 单片机入门指北</title>
    <url>//blog/2019/02/22/MSP430-%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<hr>
<p>在介绍 MSP430 的学习方法前，先简略介绍一下MSP430 吧。</p>
<p>MSP430 系列单片机是美国 TI 公司 1996 年开始推向市场的一种 16 位超低功耗、具有精简指令集（RISC）的混合信号处理器（Mixed Signal Processor）。</p>
<a id="more"></a>
<p>MSP430 单片机（后面简称 430）称之为混合信号处理器，是由于其针对实际应用需求，将多个不同功能的模拟电路、数字电路模块和微处理器集成在一个芯片上，以提供“单片机”解决方案。该系列单片机多应用于需要电池供电的便携式仪器仪表中。</p>
<p>其基本特性为：处理能力强（16 位 RISC），运算速度快（含硬件乘法器），超低功耗，片内资源丰富，开发方便等。</p>
<p>下面开始谈 430 的学习。</p>
<hr>
<p>之所以推荐大家学完 51 之后学习 430 而不是 ARM 或 STM32，不是因为大家不能学后者，而是因为在大家将要参加的很多竞赛中，常常要求低功耗，而这正是 430 的一大长处。而且，即便学完了 51，大家的程度也只停留在学过而不是学会 51。不信大家可以扪心自问，谁学 51 的时候看过单片机的芯片手册？是不是照书上的例程写的，或者从网上找个例程然后改编？这样的学习还是很粗浅的，只能让大家入个门。在实际项目开发中，我们经常会走捷径，直接拿别人的代码来用。但是在学习阶段，我们必须掌握独立完成代码的技能，只有这样，才是一个合格的开发者。</p>
<p>学习一款单片机，我们并不是为了学习这一种单片机的开发，而是为了掌握通用的单片机的开发技术，因此，我们不能为了学 430 而学 430，那样学完了还是只会用 430，甚至只会用这一种型号的 430。而事实上，市面上的单片机种类繁多，同一种单片机又分为好多种型号。如果只会用一种固定型号的单片机，可以说几乎没什么用。所以，学习 430 的时候，我们是在学习 16 位单片机的开发，甚至为接触 32 位、64 位处理器打下坚实的基础。</p>
<p>单片机的学习，不可避免的要购买开发板。因为只靠软件仿真而不看现象，一来不可靠，二来提不起兴趣。但是买开发板时随之附带的海量资料往往又让我们望而却步。其实，学习430 开发，除了在开始阶段学习一些软件的使用或者下载方法需要用到资料外，剩下的路完全可以自己走。而写这篇文档，也是为了帮助大家走好这条路。</p>
<p>刚说了路可以自己走，但是旅途中还是需要一些水啊，食物啊，拐杖啊之类的基本物品的。这些就是我们 430 自学之路的可靠战友。下面就让我们的战友们闪亮登场：</p>
<ul>
<li>战友一：所学型号的 User’s Guide：</li>
</ul>
<p>直接翻译过来就是《用户指南》，就好像旅游的时候拿一本旅游指南一样，重要性自己想。</p>
<ul>
<li>战友二：所学型号的 Datasheet：</li>
</ul>
<p>直接翻译过来就是《数据手册》，里面记载了芯片的内部模块分布与连接，以及各管脚的电气特性。在使用 IO 口时，其作用尤为重要。</p>
<ul>
<li>战友三：所学型号的详细引脚图：</li>
</ul>
<p>可以看引脚位置，更重要的是查看第二功能。其实 Datasheet 里就有，但是为了使用方便，最好单独截图出来放在外边。</p>
<ul>
<li>战友四：所学型号的库文件（其实是头文件）</li>
</ul>
<p>这个其实是在IDE中查看比较方便。像TI官方出的 CCS，可以通过 ctrl+ 鼠标左键直接访问头文件。头文件中大部分是对各个寄存器的各个位的宏定义，它们让我们的编程更方便和直观。</p>
<p>上面的都是最最核心的战友，多看看 TI 官方出的 Application Note，也是很有帮助的。</p>
<p>那么我们如何利用好这些可靠的战友资源呢？不妨边了解它们的资源，边学习如何利用。</p>
<h3 id="一、User’s-Guide"><a href="#一、User’s-Guide" class="headerlink" title="一、User’s Guide"></a>一、User’s Guide</h3><p>​     <img src="https://i.loli.net/2019/02/22/5c6fa2c7944d3.png" alt="img"></p>
<p>430 的 User’s Guide 通常都是按系列给出，因为好多型号内部资源大同小异，这样也避免了过多的工作量。如果我们是拿 MSP430F149 或者 F169 来进行学习，那么只需要看MSP430x1xx Family User’s Guide 就可以。</p>
<p>​     <img src="https://i.loli.net/2019/02/22/5c6fa2eda8508.png" alt="img"></p>
<p>打开后封面如上图，然而这个并不重要。我们先通过目录了解一下其内部资源：</p>
<p>​     <img src="https://i.loli.net/2019/02/22/5c6fa32a33893.png" alt="img"></p>
<p>如上图，目录很清楚地列出了该系列 430 的所有内部资源。但是要注意的一点是，由于是按系列给出，所有有些内部资源在有些型号中是没有的。在查看对应章节时，里面会说明哪些型号不含此资源。另外查看 Datasheet 也能知晓该资源有没有，因为 Datasheet 本身就是记录内部资源连接以及电气特性的。</p>
<p>   <img src="https://i.loli.net/2019/02/22/5c6fa37159201.png" alt="img"></p>
<p><img src="https://i.loli.net/2019/02/22/5c6fa386b6bf3.png" alt="img"></p>
<p>不难看出，几乎各章节都有《Introduction》、《Operation》、《Registers》。个别章节还有其他小节。</p>
<p><img src="https://i.loli.net/2019/02/22/5c6fa3b357474.png" alt="img"></p>
<p>​     </p>
<p>《Introduction》是通过很短的篇幅整体介绍该模块，同时列出它的特性。</p>
<p>​     <img src="https://i.loli.net/2019/02/22/5c6fa3cba4580.png" alt="img"></p>
<p>《Operation》是具体介绍模块在使用时的配置方式及注意事项。因为有些寄存器的某些位配置以后是会对其他位或寄存器有影响的，所以这里都会具体说明。</p>
<p>​     <img src="https://i.loli.net/2019/02/22/5c6fa3e799cae.png" alt="img"></p>
<p>​     <img src="https://i.loli.net/2019/02/22/5c6fa3f9d5e5f.png" alt="img"></p>
<p>《Register》则是具体给出各寄存器的每一位的位置，及其功能的详细描述。因此，熟练的编程者在了解了前两节的内容后，以后编程可以直接看这一节。但是前提是前两节里的注意事项你都记住了！否则，将给你的编程及调试带来很多莫名的麻烦。</p>
<h3 id="二、Datasheet"><a href="#二、Datasheet" class="headerlink" title="二、Datasheet"></a>二、Datasheet</h3><p>​     <img src="https://i.loli.net/2019/02/22/5c6fa40f31a03.png" alt="img"></p>
<p>Datasheet 第一页看起来就没有 User’ Guide 封面的逼格那么高了，而与正常芯片的Datasheet 格式大致相同。因为这个本来就是给专业技术人员看的，为了让系统设计更加专业，因此就采用正规的 Datasheet 格式了。而 User’s Guide 写的通俗，是因为它是面向用户的一个指南，而用户专业程度未必很高，所以写的尽量简单易懂。</p>
<p>​     <img src="https://i.loli.net/2019/02/22/5c6fa41d76796.png" alt="img"></p>
<p>Datasheet 中会给出该手册涉及的各个信号的具体引脚图，从图中不仅能查看各引脚的位置，还能知道它们的第二功能，有些高度复用的型号还有第三功能，这是极为重要的。</p>
<p>​     <img src="https://i.loli.net/2019/02/22/5c6fa43d3da67.png" alt="img"></p>
<p>​     <img src="https://i.loli.net/2019/02/22/5c6fa4516d995.png" alt="img"></p>
<p>从目录也能看出，哪些型号具有或不具有哪些资源。有时候在编程遇到具体问题时，还是要看看 Datasheet 里具体模块的描述。比如在 AD 采集时，要查看对应引脚的最高输入电压。还有在驱动外围器件时，必须知道对应引脚的最大拉电流、最大灌电流以及外围模块的正常工作电流，才能设计出稳定的系统。</p>
<p>​     <img src="https://i.loli.net/2019/02/22/5c6fa461856f4.png" alt="img"></p>
<p>这一部分，也就是《input/output schematic》是编程中最最常用的。</p>
<p>​     <img src="https://i.loli.net/2019/02/22/5c6fa47180988.png" alt="img"></p>
<p>因为这一部分给出了芯片每一个引脚的内部结构，以及相应的寄存器配置，在开启引脚第二功能时，查看这一章节，比从网上搜个程序要快的多也正确的多。奇怪的是，这里的引脚结构并不是按组给出，有的是三五个一组，有的一两个一组，这是因为每个引脚几乎都有第二功能，而且有的还有中断功能，因此其端口电路必然不同，所以就把相似程度较高（而不是完全相同）的几个引脚放在同一组给出。     </p>
<h3 id="三、引脚图"><a href="#三、引脚图" class="headerlink" title="三、引脚图"></a>三、引脚图</h3><p>这个就不说了，没啥可说的。图在上一节也贴过了。</p>
<h3 id="四、库文件"><a href="#四、库文件" class="headerlink" title="四、库文件"></a>四、库文件</h3><p>每个可以编译仿真 430 程序的 IDE 都会提供其各种型号的库文件，供用户直接调用。先介绍下常用的 IDE 吧。</p>
<p>430 编程中常用的 IDE 是 IAR 和 CCS。</p>
<p>其中 CCS 是 TI 官方推出的一款基于 Eclipse 的 IDE， 包含一整套用于开发和调试嵌入式应用的工具。它包含适用于每个 TI 器件系列的编译器、源码编辑器、项目构建环境、调试器、描述器、仿真器以及多种其它功能。其优点是界面人性化，快捷键方便，支持动态语法检查，支持 Grace 图形化界面配置，以及提供 TI 官方例程。缺点是软件功能过于全面带来的冗杂，编译效率低，以及运行和编译时可能崩溃，即不稳定。</p>
<p>IAR 是瑞典的IAR公司推出的 C编译器-IAR Embedded Workbench, 支持众多知名半导体公司的微处理器。如 8051、MSP430、STM32、ARM 等。优点是界面简洁，与常见 IDE 风格类似，编译效率高，另外几乎支持各厂商的单片机，在使用其他单片机时不用学习新的 IDE。缺点是编辑快捷键不够便捷，调试时的一些功能不够智能化和直观。</p>
<p>下面开始介绍库文件，对于用户来讲其实是相应型号的 .h 文件。如果用 f149 的话，就打开下面的头文件。</p>
<p>在 CCS 中，ctrl+ 左键点击上面的 &lt;msp430x14x.h&gt; 就可以打开该文件：</p>
<p><code>#include &lt;msp430x14x.h&gt;</code> </p>
<p>如果是 IAR，就在头文件上右键，然后点击 Open “msp430x14x.h”:</p>
<p>​     <img src="https://i.loli.net/2019/02/22/5c6fa4841045f.png" alt="img"></p>
<p>这样就打开了 &lt;msp430x14x.h&gt; 这一头文件：</p>
<p><img src="https://i.loli.net/2019/02/22/5c6fa4906a883.png" alt="img"></p>
<p><img src="https://i.loli.net/2019/02/22/5c6fa4b892d1b.png" alt="img"></p>
<p>不同的 IDE 提供的库文件可能内容是不一样的，但是使用方法是一样的。</p>
<p>比如，要使用 ADC12 的相关寄存器设置，就在头文件中按快捷键 “ctrl+f”，输入 “ADC12”，然后回车，就会出现相关内容：</p>
<p>​     <img src="https://i.loli.net/2019/02/22/5c6fa4c53d2a0.png" alt="img"></p>
<p><img src="https://i.loli.net/2019/02/22/5c6fa4d3283ba.png" alt="img"></p>
<p>这些都是 ADC12 的相关寄存器的宏定义，具体使用则要看后面的注释。一般来说注释就能很清楚的表达其功能，如果表达不清楚，再参看 User’s Guide 的《Register》章节即可。</p>
<p>在这里简要谈了 430 的学习方法，后面会推出各模块的独立编程方法。我们的目标是参看手册去编程，而不是参看例程去编程。</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>MSP430</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430 时钟系统</title>
    <url>//blog/2019/02/22/MSP430-%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<hr>
<p>系统时钟是一个程序运行的指挥官，时序和中断也是整个程序的核心和中轴线。</p>
<a id="more"></a>
<p>MSP430 最多有三个振荡器：</p>
<p>DCO：内部数字控制振荡器，它的频率可以通过 DCOCLK 进行配置。在系统 PUC 之后，DCOx=7，MODx=3。在系统 PUC 之后，SMCLK 与 MCLK 都以 DCO 作为时钟源，震荡频率在 1.1M 左右，ACLK 以 LFXT1 作为时钟源，工作在 LF 模式下内部 6pF 的负载电容。</p>
<p>LFXT1：可接高速和低速晶振，在低速模式下，它可以外接 32k 的晶振而不需要负载电容，在单片机内部已经集成了几个电容供选择。同时，通过寄存器进行配置，它还可以接内部的 VLOCLK，这个晶振是一个 12k 的低速晶振。高速模式下它可以接 0.4~16M（有的是 8M） 的晶振。通常将 LFXT1 配置成一个 32k 的振荡源，为 ACLK 提供低速的时钟信号。</p>
<p>XT2：高速振荡器，它可以接一个 0.4~16M（有的是 8M） 的晶振，需要外接电容，它相当于高速模式下的 LFXT1。通常将它配置成一个高速的振荡源，为 MCLK 和 SMCLK 提供高速时钟信号。</p>
<p>经验发现，接 XT2 时，需要注意自己开启 XT2，并延时 50us 等待 XT2 起振，然后手工清除 IFG1 中的 OFIFG 位，其操作顺序为：打开 XT2 -&gt; 等待 XT2 稳定 -&gt; 切换系统时钟为 XT2。</p>
<p>MSP430 有三种时钟信号：MCLK 系统主时钟，可分频1 2 4 8，供 cpu 使用，其他外围模块在有选择情况下也可使用；SMCLK 系统子时钟，供高速外设使用，可选择不同振荡器产生的时钟信号；ACLK 辅助时钟，只能由 LFXT1 产生，供低速外设使用。</p>
<p>DIVS0~DIVS1：DIVS=0,1,2,3 对应 SMCLK 的分频因子为 1,2,4,8</p>
<p>SELS：选择 SMCLK 的时钟源，0：COCLK；1：XT2CLK/LFXTCLK</p>
<p>DIVM0~1：选择 MCLK 的分频因子</p>
<p>DIVM=0,1,2,3：对应分频因子为 1,2,4,8</p>
<p>SELM0~1：选择 MCLK 的时钟源，0, 1：COCLK,    2：XT2CLK,   3：FXT1CL</p>
<p>其它：</p>
<p>1、LFXT1：一次有效的 PUC 信号将使 OSCOFF 复位，允许 LFXT1 工作，如果 LFXT1 信号没有用作 SMCLK 或 MCLK，可软件置 OSCOFF 关闭 LFXT1。</p>
<p>2、XT2：XT2 产生 XT2CLK 时钟信号，如果 XT2CLK 信号没有用作时钟 MCLK 和 SMCLK，可以通过置 XT2OFF 关闭 XT2，PUC 信号后置 XT2OFF，即 XT2 的关闭的。</p>
<p>3、振荡器失效时，DCO振荡器会自动被选做 MCLK 的时钟源。如果 DCO 信号没有用作 SMCLK 和 MCLK 时钟信号时，可置SCG0 位关闭 DCO 直流发生器。</p>
<p>4、在 PUC 信号后，由 DCOCLK 作为 MCLK 的时钟信号，根据需要可将 MCLK 的时钟源另外设置为 LFXT1 或 XT2，设置顺序如下：</p>
<p><1> 清 OSCOFF/XT2。</1></p>
<p><2> 清 OFIFG。</2></p>
<p><3> 延时等待至少 50us。</3></p>
<p><4> 再次检查 OFIFG，如果仍置位，则重复(1)-(4)步，直到 OFIFG=0 为止。</4></p>
<p><5> 设置 BCSCTL2 的相应 SELM。</5></p>
<p>注意：</p>
<p><1> 最好将 IFG1&amp;=~OFIFG; 放入 do-while 循环中</1></p>
<p><2> 在 XT2 出现错误的情况下将 XT2 设定为 MCLK SMCLK 的时钟源，单片机会自动的把时钟源更换为 DCO 振荡器。当时钟信号丢失 50us 时，振荡器失效。如果 MCLK 信号来自 LFXT1 或者 XT2，那么 MSP430 自动把 MCLK 的信号切换为 DCO，这样可以保证程序继续运行。MSP430 不对低频模式的 LFXT1 进行监测。</2></p>
<p><3> BCSCTL2=SELM_2+SELS; 语句必须放在 while 之后，因为当 XT2 没有起振之前，XT2 处于错误阶段，因此在 XT2 没有起振之前将它设定为主时钟与子系统时钟后，单片机会自动的将 DCO 设定为 SMCLK MCLK 的时钟源。</3></p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>MSP430</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430 中断系统</title>
    <url>//blog/2019/02/23/MSP430-%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<hr>
<p>中断是 MSP430 的一大特色，因为几乎每个外设模块都能产生中断，MSP430 可以在没有任务时进入超低功耗状态，有事件时中断唤醒 cpu，处理完毕再次进入超低功耗状态。 </p>
<a id="more"></a>
<p>整个中断的响应过程是这样的，当有中断请求时，如果 cpu 处于活动状态，先完成当前命令；如果处于低功耗，先退出，将下一条指令的 pc 值压入堆栈；如果有多个中断请求，先响应优先级高的；执行完后，等待中断请求标志位复位，要注意，单中断源的中断请求标志位自动复位，而多中断的标志位需要软件复位；然后系统总中断允许位 SR.GIE 复位，相应的中断向量值装入 pc，程序从这个地址继续执行。 </p>
<p>这里要注意，中断允许位 SR.GIE 和中断嵌套问题。如果当你执行中断程序过程中，希望可以响应更高级别的中断请求时，必须在进入第一个中断时把 SR.GIE 置位。 </p>
<p>其实，其他的外围模块时钟沿着时钟和中断这个核心来执行的。具体的结构我也不啰嗦了，可以参考 MSP430 系列手册。</p>
<p>MSP430 中断格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma vetcor = 中断向量</span><br><span class="line"></span><br><span class="line">__(两个)interrupt void 函数名(void)&#123;  //中断函数无返回值 无形参</span><br><span class="line"></span><br><span class="line">    用户程序;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>MSP430</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430 仿真与下载</title>
    <url>//blog/2019/02/23/MSP430-%E4%BB%BF%E7%9C%9F%E4%B8%8E%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<hr>
<p>对于 MSP430 来说，无论仿真还是烧写程序一般可以通过：JTAG、SBW、BSL 接口进行。</p>
<p>JTAG、SBW 接口可以用于仿真接口，BSL 接口不能用于仿真。而编程器则三种接口都支持。 </p>
<p>所以并不能说 JTAG 只支持仿真不支持编程，这是概念错误，JTAG 仅仅是一种接口协议而已。 </p>
<a id="more"></a>
<p>J-TAG  6线</p>
<p>SBW    2线</p>
<p>BSL      2线（UART）</p>
<p>下面简单描述一下三种接口的区别： </p>
<p>1、JTAG 是边界扫描技术，其在 430 内部有逻辑接口给 JTAG 使用，内部有若干个寄存器连接到了 430 的内部数据地址总线上，所以可以用JTAG访问 430 内部的所有资源，包括对 FLASH 的读写操作。所以可以用于对 MSP430 的仿真及编程。主要连接线有 TMS、TCK、TDI、TDO、RST、TEST。 </p>
<p>2、SBW 是 SPY-BI-WIRE，可以简称两线制 JTAG，主要用 SBWTCK（连接到 JTAG 仿真器的 7 脚 TCK）与 SBWTDIO（连接到 JTAG 仿真器的 1 脚 TDO/TDI），该接口主要用于小于 28 脚的 2 系列的 430 单片机，因为 28 脚以内的 2 系列单片机的 JTAG 接口一般与 IO 口复用，为了给用户预留更多的 IO 口，才推出了 SBW 接口。同样 SBW 接口可以用于仿真器及编程器。 </p>
<p>3、BSL 是 TI 在对 MSP430 出厂时预先固化到MCU内部的一段代码，有点类似 bootloader，但又与 bootloader 有明显的区别，BSL 只能用于对 MCU 内部的 FLASH 访问，不能对其他的资源访问，所以只能用作编程器接口。BSL 通过UART协议与编程器连接通信。编程器可以发送不同的通信命令来对 MCU 的存储器做不同的操作。BSL 的启动有些特殊，一般 430 复位启动时 PC 指针指向 FFFE 复位向量，但可以通过特殊的启动方式可以使 MCU 在启动是让 PC 指向 BSL 内部固化的程序。启动方式一般是由 RST 引脚与 TEST（或TCK）引脚做一个稍复杂的启动逻辑后产生。 BSL 启动后，就可以对 MCU 进行访问了。 </p>
<p>一般的 MCU 都有代码加密功能，430 是如何实现的呢？外部对 430 内部的代码读写只能通过上述的三种方式，所以又引入了熔丝位，熔丝位只存在于 JTAG、SBW接口逻辑内。BSL内部没有熔丝。当熔丝烧断时（物理破坏，且不可恢复）JTAG 与 SBW 的访问将被禁止，此时只有 BSL 可以访问。而通过 BSL 对 MCU 的访问是需要 32 个字节的密码，该密码就是用户代码的中断向量表。所以 430 的加密系统到目前为止尚无被解密的报告。一般个人学习用，不熔丝操作，只有成熟产品推向市场的时候，防止被其他人破解，才会熔丝。 </p>
<p>仿真器的型号一般有 UIF（USB 接口，支持 JTAG、SBW）、PIF（并口，只支持 JTAG）、EZ430（USB 接口的，只支持 SBW 模式）。专业编程器有 GANG430（串口、一拖 8 个，支持 JTAG、SBW，不支持 BSL）；多功能编程器（JTAG、SBW、BSL）。这些编程器都可以做离线烧写，即脱离计算机来对目标板烧写。</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>MSP430</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8S Boot ROM</title>
    <url>//blog/2019/03/02/STM8S-Boot-ROM/</url>
    <content><![CDATA[<hr>
<p>stm8s Boot ROM 是用于系统启动的只读存储器。</p>
<a id="more"></a>
<p>在某些 STM8 型号中有 2K 字节的内部 Boot ROM，其中包含有用于启动的代码。这段代码的主要作用是利用 STM8 的 SPI，CAN 或 UART 接口，将应用程序代码，数据，选项字节（Option Byte）和中断向量表下载到内部的 FLASH 和 E2RPOM 中去。</p>
<p>执行的自举加载工作在 LIN 模式下，另一种引导装载程序通信协议在 UART2/UART3 和 UART1 中执行。</p>
<p>复位后，启动代码开始执行。更多详细内容参考 STM8 启动代码用户手册 UM0560。</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM8</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8S CPU</title>
    <url>//blog/2019/03/02/STM8S-CPU/</url>
    <content><![CDATA[<hr>
<ul>
<li><p>stm8s 是基于 8 位框架结构的微控制器</p>
</li>
<li><p>CPU 内核有 6 个内部寄存器</p>
</li>
<li><p>指令集支持 80 条基本语句，20 种寻址模式</p>
</li>
<li><p>了解 stm8s 指令集参考 PM0044</p>
</li>
</ul>
<a id="more"></a>
<hr>
<h4 id="CPU寄存器（共-6-个）"><a href="#CPU寄存器（共-6-个）" class="headerlink" title="CPU寄存器（共 6 个）"></a>CPU寄存器（共 6 个）</h4><p><img src="https://i.loli.net/2019/03/02/5c7aa08eefb76.png" alt="img"></p>
<h5 id="1、累加器（A）"><a href="#1、累加器（A）" class="headerlink" title="1、累加器（A）"></a>1、累加器（A）</h5><p>8 位通用寄存器，用于保存算术运算、逻辑运算以及数据操作的操作数及结果。</p>
<h5 id="2、索引寄存器（X-和-Y）"><a href="#2、索引寄存器（X-和-Y）" class="headerlink" title="2、索引寄存器（X 和 Y）"></a>2、索引寄存器（X 和 Y）</h5><p>都是 16 位寄存器，可实现高效率的寻址模式。可用作数据操作的暂存器以及用于乘除法这样的操作。大多数情况下，交叉汇编器会在使用了 Y 寄存器的指令代码中生成 PRECODE 指令，用以和使用了 X 寄存器的指令相区别。</p>
<h5 id="3、程序计数器（PC）"><a href="#3、程序计数器（PC）" class="headerlink" title="3、程序计数器（PC）"></a>3、程序计数器（PC）</h5><p>24 位寄存器，用于存储 CPU 下一条要执行指令的地址。每一次指令操作后其内容自动刷新。最大寻址范围 16M 字节。</p>
<h5 id="4、堆栈指针（SP）"><a href="#4、堆栈指针（SP）" class="headerlink" title="4、堆栈指针（SP）"></a>4、堆栈指针（SP）</h5><p>16 位寄存器，其内容位堆栈中下一个可自由分配的单元地址。根据不同的型号，堆栈指针的高位会有一个指定的预设值。</p>
<p>堆栈一般用于在中断调用或子程序调用时存储 CPU 的上下文（程序计数器，关键寄存器，相关函数的参数及局部变量等）。用户可以通过 POP 和 PUSH 指令直接对堆栈操作。</p>
<p>SP 可以被 C 编译器的启动代码初始化，C 语言应用程序会根据用户所使用的包含绝对地址信息的链接文件来进行初始化。如果用户使用了自己编写的链接文件和启动代码，请确认 SP 被恰当地初始化（具体地址参考相应手册）。</p>
<p>在 MCU 复位后，或执行了堆栈复位指令后（RSP），堆栈指针被设为其被允许的最大值。对于使用了汇编语言的应用程序，用户可使用 ST 提供的启动代码或编写自己的启动代码来对 SP 进行正确的初始化。</p>
<p>入栈操作使堆栈指针值减小，出栈增加。当堆栈指针值为其被允许的最小值时，继续入栈会使堆栈指针值回卷至最大值，从而导致先前数据被覆盖，但此时没有中断或硬件标志位来指示该事件发生。</p>
<p>子程序调用会占用 2 或 3 字节空间。中断调用会占用 9 字节空间来存储内部寄存器（除 SP 之外）。</p>
<p>WFI/HLAT 指令会预先保存 CPU 上下文。如果 CPU 出于 WFI 或 HALT 状态下有中断发生，则进入中断所需的延时会响应减少。</p>
<h5 id="5、条件代码寄存器（CC）"><a href="#5、条件代码寄存器（CC）" class="headerlink" title="5、条件代码寄存器（CC）"></a>5、条件代码寄存器（CC）</h5><p>​     8 位寄存器，用于指示刚被执行的指令结果及处理器的状态。寄存器的第 6 位（0）是保留位，这些位可以被用户程序或代码单独测试，测试结果可用于指示程序或代码执行后的状态。</p>
<p><img src="https://i.loli.net/2019/03/02/5c7aa06f1b407.png" alt="img"></p>
<p>（1）V：溢出</p>
<p>​     在上一次有符号数的算术操作中，如果结果的最高位有溢出发生，该位置 1。可参考 INC，INCW，DEC，DECW，NEG，NEGW，ADD，ADDW，ADC，SUB，SUBW，SBC，CP，CPW 等指令。</p>
<p>（2）l1：中断屏蔽级别 1</p>
<p>​     与 l0 共同指示当前状态下 CPU 的可中断性。l1 和 l0 也会在 CPU 进入中断服务程序时被硬件自动设置为该中断对应的中断级别。</p>
<p><img src="https://i.loli.net/2019/03/02/5c7aa0b202fcd.png" alt="img"></p>
<p>（3）H：半进位</p>
<p>​     执行 ADD 或 ADC 操作的过程中，当 ALU 的第 3 位和第 4 位见发生进位时，H 位会被置 1，对于 BCD 码算术运算很有意义。     </p>
<p>（4）l0：中断屏蔽级别 0</p>
<p>（5）N：负数</p>
<p>​     上一次的算术、逻辑或数据操作的结果是负的情况下，N 位被置 1</p>
<p>（6）Z：零</p>
<p>​     上一次的算术、逻辑或数据操作的结果是负的情况下，N 位被置 1</p>
<p>（7）C：进位</p>
<p>​     上一次的算术操作中，如果结果的最高位发生进位或借位，则该位置 1。当执行位测试，分支，移位，旋转和加载指令时，该位也会受到影响。参考 ADD，ADC，SUB，SBC 等指令。</p>
<p>​     在除法操作中，C 位用来指示在指令执行中是否有错误发生（商溢出或 0 作除数）。参考 DIV 指令。</p>
<p>​     在位测试操作中，被测试的位被复制到 C 位。参考 BTJF，BTJT 指令。在移位和旋转操作中，C 位根据结果进行相应地更新。参考 RRC，RLC，SRL，SLL，SRA 指令。</p>
<p>​     用户还可以通过 SCF，RCF，CCF 指令对 C 位进行置位，清除和取反。</p>
<hr>
<h4 id="stm8s-入栈出栈顺序：（入栈和出栈都需要-9-个-CPU-cycles）"><a href="#stm8s-入栈出栈顺序：（入栈和出栈都需要-9-个-CPU-cycles）" class="headerlink" title="stm8s 入栈出栈顺序：（入栈和出栈都需要 9 个 CPU cycles）"></a>stm8s 入栈出栈顺序：（入栈和出栈都需要 9 个 CPU cycles）</h4><p><img src="https://i.loli.net/2019/03/02/5c7aa0c3ecdf8.png" alt="img"></p>
<p>中断发生（中断从发生到响应之间有 1~6 个 CPU cycles 的延迟）</p>
<p>PUSH PCL（8bit，1 CPU cycles）  （PCL 在栈中地址较高）</p>
<p>PUSH PCH（8bit，1 CPU cycles ）</p>
<p>PUSH PCE（8bit，1 CPU cycles ）</p>
<p>PUSH Y（16bit，2 CPU cycles ）</p>
<p>PUSH X（16bit，2 CPU cycles ）</p>
<p>PUSH A（8bit，1 CPU cycles ）</p>
<p>PUSH CC（8bit，1 CPU cycles ）（CC 在栈中地址较低）</p>
<p>跳转至中断向量指向的中断函数</p>
<p>执行中断函数</p>
<p>POP CC</p>
<p>POP A</p>
<p>POP X</p>
<p>POP Y</p>
<p>POP PCE</p>
<p>POP PCH</p>
<p>POP PCL  （共9个CPU cycles）</p>
<p>跳转至PC寄存器指向的地址</p>
<hr>
<h4 id="stm8-CPU-寄存器映射"><a href="#stm8-CPU-寄存器映射" class="headerlink" title="stm8 CPU 寄存器映射"></a>stm8 CPU 寄存器映射</h4><p><img src="https://i.loli.net/2019/03/02/5c7aa11b4fc32.png" alt="Image(41).png"></p>
<p>​     CPU 寄存器在 STM8 的地址空间映射如上表，只有 CPU 的调试模块才可以使用这些寄存器的地址对其操作，在 CPU 核内执行的指令只能通过直接使用寄存器名才可以读写这些寄存器。</p>
<hr>
<h4 id="全局配置寄存器（CFGGCR）"><a href="#全局配置寄存器（CFGGCR）" class="headerlink" title="全局配置寄存器（CFGGCR）"></a>全局配置寄存器（CFGGCR）</h4><p>地址偏移值 0x00</p>
<p>复位值    0x00</p>
<p><img src="https://i.loli.net/2019/03/02/5c7aa0f0747c9.png" alt="img"></p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM8</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8S Memory and register map</title>
    <url>//blog/2019/03/02/STM8S-Memory-and-register-map/</url>
    <content><![CDATA[<hr>
<p>存储器映射、I/O 端口硬件寄存器映射和 CPU/SWIM、调试模块/中断控制寄存器的详细内容参见 datasheet。</p>
<a id="more"></a>
<hr>
<h3 id="存储器映射"><a href="#存储器映射" class="headerlink" title="存储器映射"></a>存储器映射</h3><p><img src="https://i.loli.net/2019/03/02/5c7aa57fd53a6.png" alt="Image.png"></p>
<p>各部分具体上限（upper limit）参看 datasheet。</p>
<hr>
<h3 id="stm8s-stack-handling-栈处理"><a href="#stm8s-stack-handling-栈处理" class="headerlink" title="stm8s stack handling  栈处理"></a>stm8s stack handling  栈处理</h3><p>stm8s 和 stm8af MCU 的栈在 user RAM 区实现。</p>
<p><img src="https://i.loli.net/2019/03/02/5c7aa5bc24eaa.png" alt="Image.png"></p>
<p>栈底所在的地址大于栈顶所在的地址。</p>
<p>不是所有器件都有 roll-over limit  回卷限制。</p>
<p>用户必须注意初始化栈指针。通常由开发工具（linker file）生成的初始化代码来正确加载这个指针，默认初始化到 RAM 尾地址。</p>
<p>有些器件中，栈回卷限制为一个固定地址。如果使用 push 操作或为子函数或中断函数保存上下文时，栈指针减小到栈回卷限制处，栈指针将复位到 RAM 尾地址。当栈指针正参与运算时，不会回卷。</p>
<hr>
<h3 id="Customized-stack-model-自定义栈模型"><a href="#Customized-stack-model-自定义栈模型" class="headerlink" title="Customized stack model 自定义栈模型"></a>Customized stack model 自定义栈模型</h3><p>stm8s 和 stm8af 的栈指针操作允许执行一个自定义的栈模型。这就使得栈的大小变得灵活，而不用受到栈回卷限制的约束。执行自定义栈也有利于寄存器配置不同的器件的软件可移植性。</p>
<p><img src="https://i.loli.net/2019/03/02/5c7aa5fb84939.png" alt="Image.png"></p>
<p>并不是所有器件都有栈回卷限制。</p>
<p>保护单元（guard cells）是必须被应用程序连续轮询检测是否发生栈溢出的 RAM 位置。</p>
<p>在这个模型中，初始的栈指针必须指向超过栈回卷限制的位置（必须必回卷限制的地址小）。因此，增长的栈永远不会到达回卷限制。很明显，这样的操作下，栈大小不会受到溢出机制的限制。虽然如此，用户必须在 link file 中定义栈的位置和栈的大小，也必须确保栈指针不会超出定义的栈区域（栈顶溢出或低于栈底）。超过或在自定义栈之下的 RAM 位置可以被常规的用作 RAM 来存储变量或其他信息。</p>
<p>保护单元可以被配置在比栈顶更低的位置以检测是否栈指针超过了规定的边界。这些单元是标准的 RAM 位置，初始化为固定值，一旦发生溢出，栈将在这里重写。用户软件可以常规轮询这些单元，检测溢出条件，并将应用置于故障保护状态。</p>
<p>在软件有效期内，硬件断点可被设在栈的两个极端位置，以确认栈溢出和欠载都没有发生。</p>
<hr>
<h3 id="寄存器描述缩写"><a href="#寄存器描述缩写" class="headerlink" title="寄存器描述缩写"></a>寄存器描述缩写</h3><p><img src="https://i.loli.net/2019/03/02/5c7aa6501fc7b.png" alt="Image.png"> </p>
<p><img src="https://i.loli.net/2019/03/02/5c7aa6502474f.png" alt="Image.png"></p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM8</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa1583（DigitGenerator）解决思路</title>
    <url>//blog/2019/03/02/UVa1583%EF%BC%88DigitGenerator%EF%BC%89%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<hr>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>如果x加上x的各个位数字之和得到y，就说x是y的生成元；给出n（1≤n≤100000），求最小生成元。无解输出0。例如，n=216，121，2005时的解分别为198 , 0, 1979。</p>
<a id="more"></a>
<h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>本题核心部分在于判断是否存在小于给定数字的一个数字，其本身与其各位数字之和等于给定数字，并不复杂。</p>
<p>由于输入数字范围并不大，因此可以考虑用事先计算好范围内所有数字的最小元，然后通过查表的方式输出。而且建立查找表的过程也很简单，不需要计算生成元，而是从小到大遍历数值范围一遍，将数字与各位数值相加，便可作为生成元存放到对应的表中。</p>
<p>另外，也可以每次都直接根据输入值来计算其生成元，省去了存放查找表的内存开销，但是每次都要重新计算。如果每次计算是用暴力方法遍历计算，会导致时间溢出，因此可根据题目的特点进行优化：</p>
<p>由于生成元的数值本身加上各位数值即为输入数字，因此，根据输入数字的数量级，生成元最多比输入数值小 9x6=54（其实是9x5=45）。因此在求解生成元时，无需从 1 开始遍历，只需从比输入数值小 50 的数值开始遍历即可。至于输入小于 50 的情况也无需考虑，只是在负数的地方浪费了一点时间，不会影响平均时间复杂度。</p>
<h4 id="解法一：查表"><a href="#解法一：查表" class="headerlink" title="解法一：查表"></a>解法一：查表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAXM 100005</span><br><span class="line">int ans[MAXM];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int t, n;</span><br><span class="line">    memset(ans, 0, sizeof(ans));</span><br><span class="line">    for(int m=1; m&lt;MAXM; m++)&#123;</span><br><span class="line">        int x=m, y=m;</span><br><span class="line">        while(x&gt;0)&#123;</span><br><span class="line">            y += x%10;</span><br><span class="line">            x /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(y&gt;MAXM)</span><br><span class="line">            continue;</span><br><span class="line">        if(ans[y]==0 || m&lt;ans[y])</span><br><span class="line">            ans[y] = m;</span><br><span class="line">    &#125;</span><br><span class="line">//    for(int i=1; i&lt;MAXM; i++)&#123;</span><br><span class="line">//        printf(&quot;%7d %7d\n&quot;, i, ans[i]);</span><br><span class="line">//    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        printf(&quot;%d\n&quot;, ans[n]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解法二：暴力枚举"><a href="#解法二：暴力枚举" class="headerlink" title="解法二：暴力枚举"></a>解法二：暴力枚举</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int t, n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        int x = 0;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i=n-50; i&lt;n; i++)&#123;</span><br><span class="line">            x = i;</span><br><span class="line">            sum = x;</span><br><span class="line">            while(x&gt;0)&#123;</span><br><span class="line">                sum += x%10;</span><br><span class="line">                x /= 10;</span><br><span class="line">            &#125;</span><br><span class="line">            if( sum == n)&#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8S Flash 程序存储器和数据 EEPROM</title>
    <url>//blog/2019/03/03/STM8S-Flash-%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%99%A8%E5%92%8C%E6%95%B0%E6%8D%AE-EEPROM/</url>
    <content><![CDATA[<hr>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>stm8 内部的 FLASH 程序存储器和数据 EEPROM 由一组通用寄存器来控制。用户可以使用这些寄存器来编程或擦出存储器的内容，设置写保护，或者配置特定的低功耗模式。用户也可以对器件的选项字节（Option byte）进行编程。</p>
<a id="more"></a>
<hr>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>块 Block —— 一个块是指可由一个简单编程操作变成或擦除的一组字节。块级的操作非常快，是标准的编程和擦除操作。</p>
<p>页 Page —— 一页由一组块组成。stm8s 器件拥有启动代码，程序代码和数据 EEPROM，这些区域都有特定的结构所保护。通过对特定的选项字节进行操作，这些区域的大小能够以页为单位来进行调整。</p>
<hr>
<h3 id="Flash-主要特性"><a href="#Flash-主要特性" class="headerlink" title="Flash 主要特性"></a>Flash 主要特性</h3><h5 id="stm8s-EEPROM-分为两个存储器阵列："><a href="#stm8s-EEPROM-分为两个存储器阵列：" class="headerlink" title="stm8s EEPROM 分为两个存储器阵列："></a>stm8s EEPROM 分为两个存储器阵列：</h5><ul>
<li><p>最多至 128K 字节的 FLASH 程序存储器，不同的器件容量有所不同。</p>
</li>
<li><p>最多至 2K 字节的数据 EERPOM（包括option byte），不同器件容量不同。</p>
</li>
</ul>
<h5 id="编程模式："><a href="#编程模式：" class="headerlink" title="编程模式："></a>编程模式：</h5><ul>
<li><p>字节编程和自动快速字节编程（没有擦除操作）</p>
</li>
<li><p>字编程</p>
</li>
<li><p>块编程和快速块编程（没有擦除操作）</p>
</li>
<li><p>在编程/擦除操作结束时和发生非法编程操作时产生中断</p>
</li>
</ul>
<p>读同时写（RWW）功能。该特性并非所有 stm8s 器件都有。</p>
<p>在应用编程（IAP）和在线编程（ICP）能力。</p>
<h5 id="保护特性："><a href="#保护特性：" class="headerlink" title="保护特性："></a>保护特性：</h5><ul>
<li><p>存储器度保护（ROP）</p>
</li>
<li><p>基于存储器存取安全系统（MASS 密钥）的程序存储器写保护</p>
</li>
<li><p>基于存储器存取安全系统（MASS 密钥）的数据存储器写保护</p>
</li>
<li><p>可编程的用户启动代码区域（UBC）写保护</p>
</li>
</ul>
<p>在待机（Halt）模式和活跃待机（Active-halt）模式下，存储器可配置为运行状态和掉电状态。</p>
<hr>
<h3 id="存储器组织结构"><a href="#存储器组织结构" class="headerlink" title="存储器组织结构"></a>存储器组织结构</h3><h4 id="1、stm8s-和-stm8af-存储器组织结构"><a href="#1、stm8s-和-stm8af-存储器组织结构" class="headerlink" title="1、stm8s 和 stm8af 存储器组织结构"></a>1、stm8s 和 stm8af 存储器组织结构</h4><p>stm8s 和 stm8af 的 EEPROM 以 32 位字长（每字 4 字节）为基础组织起来。根据不同的器件，存储器组织结构有所不同：</p>
<h5 id="小容量-stm8s-和-stm8af-器件："><a href="#小容量-stm8s-和-stm8af-器件：" class="headerlink" title="小容量 stm8s 和 stm8af 器件："></a>小容量 stm8s 和 stm8af 器件：</h5><ul>
<li>8K Flash 程序存储器，每页（或块）64 字节，共 128 页（或块）。分为 2 个区域，大小可由选项字节配置的 user boot code 区（UBC），和主程序存储区。FLash 程序存储器地址映射在 stm8s 地址空间的最上端，且包括复位和中断向量。</li>
</ul>
<ul>
<li>最多 640 字节数据 EEPROM，每页（或块） 64 字节，共 10 页（或块） 。有一个块（64 字节）中包含 11 个用来配置器件硬件特性的选项字节。选项字节可在 user，IAP 和 ICP/SWIM 模式下编程。</li>
</ul>
<h5 id="中容量-stm8s-和-stm8af-器件："><a href="#中容量-stm8s-和-stm8af-器件：" class="headerlink" title="中容量 stm8s 和 stm8af 器件："></a>中容量 stm8s 和 stm8af 器件：</h5><ul>
<li>从 16K 到 32K Flash 程序存储器，每页 4 个 128 字节的块，最多 64 页。Flash 程序存储器分为 2 个区， 大小可由选项字节配置的 user boot code 区（UBC），和主程序存储区。FLash 程序存储器地址映射在 stm8s（或 stm8af）地址空间的最上端，且包括复位和中断向量。</li>
</ul>
<ul>
<li>最多1K 字节数据 EEPROM，每页 4 个 128 字节的块，最多 2 页。有一个块（128字节）中包含 13 个用来配置器件硬件特性的选项字节。选项字节可在 user，IAP 和 ICP/SWIM 模式下编程。</li>
</ul>
<h5 id="大容量-stm8s-和-stm8af-器件："><a href="#大容量-stm8s-和-stm8af-器件：" class="headerlink" title="大容量 stm8s 和 stm8af 器件："></a>大容量 stm8s 和 stm8af 器件：</h5><ul>
<li>从 32 到 128K 字节 Flash 程序存储器，每页 4 个 128 字节的块，最多 256 页。Flash 程序存储器分为 2 个区， 大小可由选项字节配置的 user boot code 区（UBC），和主程序存储区。FLash 程序存储器地址映射在 stm8s（或 stm8af）地址空间的最上端，且包括复位和中断向量。</li>
</ul>
<ul>
<li>最多 2K 字节数据 EEPROM，每页 4 个 128 字节的块，最多 4 页。有一个块（128 字节）中包含 15 个用来配置器件硬件特性的选项字节。选项字节可在 user，IAP 和 ICP/SWIM 模式下编程。</li>
</ul>
<p>EEPROM 存取时间决定了器件最多运行在 16MHz 下。对于时钟频率超过 16MHz 的应用，FLash/数据 EEPROM 存取必须被被配置成等待状态（1 wait state）。这由器件选项字节使能。</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b3b8457334.png" alt="Image.png"></p>
<p><img src="https://i.loli.net/2019/03/03/5c7b3b9826fa5.png" alt="Image.png"></p>
<p><img src="https://i.loli.net/2019/03/03/5c7b3bab0582e.png" alt="Image.png"></p>
<h4 id="2、存储器存取-等待状态配置"><a href="#2、存储器存取-等待状态配置" class="headerlink" title="2、存储器存取/等待状态配置"></a>2、存储器存取/等待状态配置</h4><p>Flash/数据EEPROM 存取时间允许器件运行在最高 16MHz 时钟下，无需等待状态。</p>
<p>当使用高速外部时钟（HSE）在更高的最多 24MHz 下时，需要一个等待状态。在这种情况下，器件应该对选项字节进行编程以插入这个等待状态。</p>
<h4 id="3、用户启动区域（UBC）"><a href="#3、用户启动区域（UBC）" class="headerlink" title="3、用户启动区域（UBC）"></a>3、用户启动区域（UBC）</h4><p>UBC 包含有复位和中断向量表，它可用于存储 IAP 及通信程序。UBC 有一个两级保护结构可保护用户代码及数据在 IAP 编程中免于无意的擦除或修改。这意味着该区域总是写保护的，而且写保护不能通过使用 MASS 密钥来解锁。</p>
<p>在 ICP 模式下（使用 SWIM 接口）可以通过修改选项字节来配置 UBC 的大小。UBC 选项字节指定了分配在 UBC 中的页的数量。UBC 区域的歧视地址是 0x8000。</p>
<p>可以通过读取 UBC 选项字节来获得 UBC 区域的大小。</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b3c4aa8835.png" alt="Image.png"></p>
<p><img src="https://i.loli.net/2019/03/03/5c7b3c5b3ce50.png" alt="Image.png"></p>
<p>前两页的 128 个字节包含了 32 个中断向量。</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b3c9e0b417.png" alt="Image.png"></p>
<h4 id="4、数据-EEPROM（DATA）"><a href="#4、数据-EEPROM（DATA）" class="headerlink" title="4、数据 EEPROM（DATA）"></a>4、数据 EEPROM（DATA）</h4><p>数据 EEPROM（DATA）区域可用于存储用户具体项目所需的数据。默认情况下，DATA 区域是写保护的，这样可以在主程序工作在 IAP 模式时防止 DATA 区域被无意地修改。只有使用特定的 MASS 密钥才能对 DATA 区域的写保护解锁。</p>
<h4 id="5、主程序区域"><a href="#5、主程序区域" class="headerlink" title="5、主程序区域"></a>5、主程序区域</h4><p>主程序区是 Flash 程序存储器中用于存储应用代码的区域。</p>
<h4 id="6、选项字节（Option-bytes）"><a href="#6、选项字节（Option-bytes）" class="headerlink" title="6、选项字节（Option bytes）"></a>6、选项字节（Option bytes）</h4><p>选项字节用于配置硬件特性和存储器保护状态，这些字节位于同一页的特定存储器阵列中。</p>
<p>选项字节可以再 ICP/SWIM 模式中或 IAP 模式中修改，注意此时要保证 FLASH_CR2 中的 OPT 位为 1 以及 FLASH_NCR2 中的 NOPT 位为 0。</p>
<p>对选项字节的编程参考 STM8 SWIM 通讯协议和调试模块用户手册 UM0470。</p>
<hr>
<h3 id="存储器保护"><a href="#存储器保护" class="headerlink" title="存储器保护"></a>存储器保护</h3><h4 id="1、读保护"><a href="#1、读保护" class="headerlink" title="1、读保护"></a>1、读保护</h4><p>当选项字节中的 ROP 字节被编程为 0xAA 时，读保护就生效了。这种情况下，无论写保护是否生效，在 ICP 模式中（使用 SWIM 接口）读取或修改 FLASH 程序存储器和 DATA 区域都是被禁止的。即使认为没有什么保护是完全不可破解的，对于一个通用微处理器来说，stm8 的读保护的特性也提供了一个非常高水平的保护级别。</p>
<h5 id="取消写保护"><a href="#取消写保护" class="headerlink" title="取消写保护"></a>取消写保护</h5><p>可以在 ICP 模式中通过对选项字节中的 ROP 字节重新编程来接触程序存储器、UBC 和 DATA 区域的读保护。在这种情况下，程序存储器、UBC、DATA 区域以及选项字节都被自动擦除，器件也可以被重新编程了。</p>
<h4 id="2、存储器存取安全系统（MASS）"><a href="#2、存储器存取安全系统（MASS）" class="headerlink" title="2、存储器存取安全系统（MASS）"></a>2、存储器存取安全系统（MASS）</h4><p>在复位以后，主程序和 DATA 区域都被自动保护以防止无意的写操作。在试图修改其内容前必须对其解锁，而解锁的机制由存储器存取安全系统（MASS）来管理。</p>
<p>UBC 区域的特性指明了在 UBC 中的内容一直是写保护的。一旦存储器内容被修改完毕，推荐将写保护使能以防止数据被破坏。</p>
<h5 id="对主程序存储器的写保护"><a href="#对主程序存储器的写保护" class="headerlink" title="对主程序存储器的写保护"></a>对主程序存储器的写保护</h5><p>在器件复位后，可以通过向 FLASH_PUKR 寄存器连续写入两个被叫作 MASS 密钥的值来解除主程序存储器的写保护。这两个写入 FLASH_PUKR 的值回合一下两个硬件密钥值相比较：</p>
<ul>
<li><p>第一个硬件密钥：8’b01010110（0x56）</p>
</li>
<li><p>第二个硬件密钥：8’b10101110（0xAE）</p>
</li>
</ul>
<p>需要通过如下步骤来解除主程序存储器区域的写保护：</p>
<p>1）向 FLASH_PUKR 写入第一个 8 位密钥。在系统复位后，当这个寄存器被首次写入值时，数据总线上的值没有被直接锁存到这个寄存器中，而是和第一个硬件密钥值（0x56）相比较。</p>
<p>2）如果密钥输入错误，FLASH_PUKR 寄存器在下一次系统复位之前将一直被锁住。在下一次复位前，再向该寄存器进行的任何写操作都会被系统忽略掉。</p>
<p>3）如果第一个硬件密钥正确，当这个寄存器被第二次写入值时，数据总线上的值没有被直接锁存到这个寄存器中，而是和第二个硬件密钥值（0xAE）相比较。</p>
<p>4）如果密钥输入错误，FLASH_PUKR 寄存器在下一次系统复位之前将一直被锁住。在下一次复位前，再向该寄存器进行的任何写操作都会被系统忽略掉。</p>
<p>5）如果第二个硬件密钥正确，主程序存储器写保护被解除，同时 FLASH_IAPSR 中的 PUL 位为 1。</p>
<p>在开始编程之前，应用程序可以校验 PUL 为是否被有效置 1。应用程序可以再任意时刻通过清 PUL 位来重新禁止对 DATA 区域的写操作。</p>
<h5 id="对DATA区域的写操作"><a href="#对DATA区域的写操作" class="headerlink" title="对DATA区域的写操作"></a>对DATA区域的写操作</h5><p>在器件复位后，可以通过向FLASH_DUKR寄存器连续写入两个被叫作MASS密钥的值来解除主程序存储器的写保护。这两个写入FLASH_PUKR的值回合一下两个硬件密钥值相比较：</p>
<ul>
<li><p>第一个硬件密钥：8’b01010110（0x56）</p>
</li>
<li><p>第二个硬件密钥：8’b10101110（0xAE）</p>
</li>
</ul>
<p>需要通过如下步骤来解除数据区域的写保护：</p>
<p>1）向FLASH_DUKR 写入第一个 8 位密钥。在系统复位后，当这个寄存器被首次写入值时，数据总线上的值没有被直接锁存到这个寄存器中，而是和第一个硬件密钥值（0x56）相比较。</p>
<p>2）如果密钥输入错误，应用程序可以尝试重新输入这两个 MASS 密钥来对 DATA 区域进行解锁。</p>
<p>3）如果第一个硬件密钥正确，当这个寄存器被第二次写入值时，数据总线上的值没有被直接锁存到这个寄存器中，而是和第二个硬件密钥值（0xAE）相比较。</p>
<p>4）如果密钥输入错误，DATA EEPROM 区域在下一次系统复位之前将一直保持写保护状态。在下一次复位前，再向该寄存器进行的任何写操作都会被系统忽略掉。</p>
<p>5）如果第二个硬件密钥正确，DATA 区域的写保护被解除，同时 FLASH_IAPSR 中的 DUL 位为 1。</p>
<p>在开始编程之前，应用程序可以校验 DUL 为是否被有效置 1 来确认DATA区域已经将写保护解锁。应用程序可以再任意时刻通过清 DUL 位来重新禁止对 DATA 区域的写操作。</p>
<h4 id="3、对选项字节的写操作"><a href="#3、对选项字节的写操作" class="headerlink" title="3、对选项字节的写操作"></a>3、对选项字节的写操作</h4><p>​     </p>
<p>对选项字节的写操作的步骤和对 DATA EEPROM 的操作大致相同。但是要注意到 FLASH_CR2 中的 OPT 位要为 1 以及 FLASH_NCR 中的 NOPT 位要为 0，这样才可以对选项字节进行写操作。</p>
<hr>
<h3 id="存储器编程"><a href="#存储器编程" class="headerlink" title="存储器编程"></a>存储器编程</h3><p>在尝试任何编程操作之前，必须对主程序寄存器和 DATA 区域解锁。</p>
<h4 id="1、读同时写（RWW）"><a href="#1、读同时写（RWW）" class="headerlink" title="1、读同时写（RWW）"></a>1、读同时写（RWW）</h4><p>RWW 特性允许用户在执行程序和读程序存储器时对 DATA EEPROM 区域进行写操作，因此执行的时间被优化了。相反的操作是不允许的：不可以在写程序寄存器时对 DATA EEPROM 进行读操作。</p>
<p>RWW 特性是一直有效的而且可以在任意时刻使用。</p>
<p>并不是所有 stm8 器件都有 RWW 特性。</p>
<h4 id="2、字节编程"><a href="#2、字节编程" class="headerlink" title="2、字节编程"></a>2、字节编程</h4><p>可以对主程序存储器和 DATA 区域逐字节地编程。要对一个字节编程，应用程序可直接向目标地址写入数据。</p>
<ul>
<li>在主程序存储器中</li>
</ul>
<p>​     当字节编程操作执行时，应用程序停止运行。</p>
<ul>
<li>在DATA区域中</li>
</ul>
<p>​     有 RWW 功能的器件： 在 IAP 模式下，应用程序不停止运行，字节编程利用 RWW 功能进行操作。</p>
<p>​     无 RWW 功能的器件：当字节编程操作执行时，应用程序停止运行。要擦除一个字节，向对应的字节简单写入 0x00 即可。</p>
<p>应用程序可以通过读 FLASH_IAPSR 寄存器来校验编程或擦出操作是否已被正确执行：</p>
<ul>
<li><p>在一次成功的编程操作后 EOP 位被置 1。</p>
</li>
<li><p>当软件试图对一个被保护的页进行写操作时 WP_PG_DIS 位被置 1。在这种情况下，写操作不会被执行。</p>
</li>
</ul>
<p>如果 FLASH_CR1 中的 IE 位已经被预先使能，则只要这些标志位（EOP/WP_PG_DIS）中有一个被置位就会产生一个中断。</p>
<h4 id="自动快速字节编程"><a href="#自动快速字节编程" class="headerlink" title="自动快速字节编程"></a>自动快速字节编程</h4><p>根据目标地址的初始化内容的不同，编程持续时间可能也有所不同。如果字（4 个字节）中包含不为空的字节，在编程前整个字节会被自动擦除。相反，如果字为空，由于不会执行擦除操作从而编程时间变短（参考 tPROG）。</p>
<p>然而，可以通过对 FLASH_CR1 中的 FIX 位置 1 来强迫执行系统擦除操作而不管其内容是否为空，从而使编程时间固定（参考 FLASH 控制寄存器）。编程总时间随之被规定位擦除时间和写操作时间的和。</p>
<p>为了快速写一个字节（没有擦除操作），将要被写入数据的整个字（4 个字节）必须被预先擦除。因此不可能对同一个字做连续两次快速写操作（在第二次写之前没有擦除操作）：第一次写字节操作将是快速操作但针对另外一个字节的第二次写操作将需要一个擦除操作。</p>
<h4 id="3、字编程"><a href="#3、字编程" class="headerlink" title="3、字编程"></a>3、字编程</h4><p>字写入操作允许一次对整个 4 字节的字进行编程，从而将编程时间缩短。</p>
<p>主程序存储器和 DATA EEPROM 都可以进行字操作。在一些 stm8s 器件中，也拥有当 DATA EEPROM 在进行写操作时同时具备 RWW 功能。</p>
<p>为了对一个字编程，FLASH_CR2 和 FLASH_NCR2 中的 WPRG/NWPRG 位必须预先置位/清零来使能字编程模式。然后将要被编程字的 4 个字节必须被从首地址开始装载。当四个字节都被写入后，编程周期自动开始。</p>
<p>像字节操作一样，FLASH_IAPSR 中的 EOP 与 WR_PG_DIS 控制位和 FLASH 中断相配合，可用于检查操作是否被正确执行完毕。</p>
<h4 id="4、块编程"><a href="#4、块编程" class="headerlink" title="4、块编程"></a>4、块编程</h4><p>块编程比字节编程和字编程都要快。在块编程操作中，整个块的编程或擦除在一个编程周期就可以完成。</p>
<p>在主程序存储器和 DATA 区域都可以执行块操作。</p>
<ul>
<li>在主程序存储器中</li>
</ul>
<p>​     用于块编程的代码必须全部在 RAM 中执行。</p>
<ul>
<li>在 DATA 区域中</li>
</ul>
<p>​     有 RWW 功能的器件：DATA 块操作可在主程序存储器中执行，然而数据装载阶段必须在 RAM 中执行。</p>
<p>​     无 RWW 功能的器件：用于块编程的代码必须全部在 RAM 中执行。</p>
<p>​     </p>
<p>一共有三种可能的块操作：</p>
<ul>
<li><p>块编程（也叫标准块编程）：整个块在编程前被自动擦除</p>
</li>
<li><p>快速块编程：在编程前没有预先的块擦除操作。</p>
</li>
<li><p>块擦除。</p>
</li>
</ul>
<p>在块擦除时，中断被硬件自动屏蔽。</p>
<h5 id="标准块编程"><a href="#标准块编程" class="headerlink" title="标准块编程"></a>标准块编程</h5><p>块编程操作允许一次对整个进行编程，整个块在编程前被自动擦除。</p>
<p>为了对整个块编程，FLASH_CR2 和 FLASH_NCR2 中的 PRG/NPRG 位必须预先置位/清零来使能标准块编程。然后需要向主程序存储器或 DATA 区域的目标地址依次写入要编程的数据，这样数据会被锁存在内部缓存中。为编程整个块，块中的所有字节都需要被写入数据。但要注意，所有被写入缓存的数据必须位于同一个块中，这意味着这些数据必须有同样的高位地址：仅仅低 6 位的地址可以不一样。当目标块的最后一个字节被装载到缓存后，编程就自动开始了。编程前首先会自动执行一次擦除操作。</p>
<p>当对 DATA 区域进行块编程时，应用程序可以检查 FLASH_IAPSR 中的 HVOFF 位确认编程状态。一旦 HVOFF 被置 0，真正的编程阶段就开始了，此时应用程序就可以返回到主程序中去了。</p>
<p>FLASH_IAPSR 中的 EOP 与 WR_PG_DIS 控制位和 FLASH 中断相配合，可用于检查操作是否被正确执行完毕。</p>
<h5 id="快速块编程"><a href="#快速块编程" class="headerlink" title="快速块编程"></a>快速块编程</h5><p>快速块编程允许不擦除存储器内容就对块进行编程，因此快速块编程速度是标准块编程的两倍。</p>
<p>该模式仅用于被编程部分已经被擦除过的情况，同时这种模式对向空白部分写入完整的应用代码特别有用，因为这种模式可以节省相当可观的时间。</p>
<p>快速块编程的步骤和标准块编程的步骤大致一样，FLASH_CR2 和 FLASH_NCR2 中的 FPRG/NFPRG 位必须预先置位/清零来使能快速块编程。</p>
<p>FLASH_ISPSR 中的 EOP 与 WR_PG_DIS 控制位和 FLASH 中断相配合，可用于检查快速块编程操作是否被正确执行完毕。</p>
<p><strong>警告</strong>：在执行快速块编程之前如果这个块不是空的话，不能保证写入的数据无误。</p>
<h5 id="块擦除"><a href="#块擦除" class="headerlink" title="块擦除"></a>块擦除</h5><p>块擦除允许擦除整个块。</p>
<p>为了擦除整个块，FLASH_CR2 和 FLASH_NCR2 中的 ERASE/NERASE 位必须预先置位/清零来使能块擦除。通过对块中所有的字写入 0x00 00 00 00 来擦除整个块。字的起始地址必须以 0，4，8 或 C 作为结尾。</p>
<p>FLASH_IARSR 中的 EOP 与 WR_PG_DIS 控制位和 FLASH 中断相配合，可用于检查操作是否被正确执行完毕。</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b3e3b76994.png" alt="Image.png"></p>
<h4 id="5、选项字节（Option-byte）编程"><a href="#5、选项字节（Option-byte）编程" class="headerlink" title="5、选项字节（Option byte）编程"></a>5、选项字节（Option byte）编程</h4><p>对选项字节编程和对 DATA EEPROM 区域编程非常相似。</p>
<p>应用程序可直接向目标地址进行写操作。利用 stm8 的 RWW 功能，在对选项字节写操作的同时程序不必挺下来。</p>
<hr>
<h3 id="ICP-和-IAP"><a href="#ICP-和-IAP" class="headerlink" title="ICP 和 IAP"></a>ICP 和 IAP</h3><p>在线编程（ICP）用于更新整个存储器的内容。ICP 使用 SWIM 接口把用户的程序装载到微控制器中，同时提供迅速而有效的设计迭代并且去除了不必要的封装处理和器件插槽。SWIM 接口（单线接口模块）使用 SWIM 引脚和编程工具相连接。</p>
<p>相对于 ICP 方式，在应用编程（IAP）可使用 stm8 支持的任意通讯接口（I/O、I2C、SPI、UART…）来下载要编入存储器中的数据。IAP 允许在应用程序运行中对 FLASH 程序存储器的内容重新编程。然而要想使用 IAP，必须通过 ICP 对 FLASH 程序存储器预先编程。</p>
<p>stm8 FLASH 编程手册 RM0051，stm8 SWIM 通信协议和调试模块用户手册 UM0470。</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b3e7a4b4db.png" alt="Image.png"></p>
<hr>
<h3 id="FLASH寄存器"><a href="#FLASH寄存器" class="headerlink" title="FLASH寄存器"></a>FLASH寄存器</h3><p>FLASH控制寄存器1（FLASH_CR1）</p>
<p>FLASH控制寄存器2（FLASH_CR2）</p>
<p>FLASH互补控制寄存器2（FLASH_NCR2）</p>
<p>FLASH保护寄存器（FLASH_FPR）</p>
<p>FLASH保护寄存器（FLASH_NFPR）</p>
<p>FLASH程序存储器解保护寄存器（FLASH_PUKR）</p>
<p>DATA EEPROM解保护寄存器（FLASH_DUKR）</p>
<p>FLASH状态寄存器（FLASH_IAPSR）</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b3ebdd90dd.png" alt="Image.png"></p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM8</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8S 中断控制</title>
    <url>//blog/2019/03/03/STM8S-%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<hr>
<h3 id="ITC-简介"><a href="#ITC-简介" class="headerlink" title="ITC 简介"></a>ITC 简介</h3><h4 id="硬件中断管理"><a href="#硬件中断管理" class="headerlink" title="硬件中断管理"></a>硬件中断管理</h4><ul>
<li><p>大多数 I/O 口都具有外部中断能力，有专用的中断向量，每个端口都可以设置边沿检测方式（上升/下降）。</p>
</li>
<li><p>外设中断能力</p>
</li>
</ul>
<a id="more"></a>
<h4 id="软件中断能力（TRAP）"><a href="#软件中断能力（TRAP）" class="headerlink" title="软件中断能力（TRAP）"></a>软件中断能力（TRAP）</h4><p>使用复杂中断优先级和等级管理的嵌套或并发中断管理</p>
<ul>
<li><p>最多 4 个软件可编程的嵌套等级</p>
</li>
<li><p>最多 32 个由硬件固定的中断向量</p>
</li>
<li><p>2 个不可屏蔽事件：RESET，TRAP</p>
</li>
<li><p>1 个不可屏蔽的最高级硬件中断（TLI）</p>
</li>
</ul>
<h4 id="中断管理基"><a href="#中断管理基" class="headerlink" title="中断管理基"></a>中断管理基</h4><ul>
<li><p>CPU 的 CCR 寄存器的 l1 和 l0 位</p>
</li>
<li><p>软件优先级寄存器（ITC_SPRx）</p>
</li>
<li><p>复位向量地址 0x008000 在程序存储器的起始位置。在有 boot ROM 的器件中，复位初始化程序由 STMicroelectronics 编程在 ROM 中。</p>
</li>
<li><p>固定的中断向量地址位于存储器地址映射的高地址（0x00 8004 到 0x00 807C），按硬件优先级顺序排列。</p>
</li>
</ul>
<hr>
<h3 id="中断屏蔽和处理流程"><a href="#中断屏蔽和处理流程" class="headerlink" title="中断屏蔽和处理流程"></a>中断屏蔽和处理流程</h3><p>中断屏蔽由 CCR 寄存器的 l1 和 l0 位和设置每个中断向量的软件优先级等级的 ITC_SPRx 寄存器管理。</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b55bed9fc8.png" alt="Image.png"></p>
<p>当一个中断请求必须被响应时：</p>
<p>1、正常的过程被暂停在当前指令执行的最后一条。</p>
<p>2、PC，X，Y，A 和 CCR 寄存器入栈。</p>
<p>3、CCR 寄存器的 l1 和 l0 位根据 ITC_SPRx 寄存器中相应的中断向量的值置位。</p>
<p>4、PC 然后载入中断的中断向量，以响应中断，取指中断服务函数的第一条指令。</p>
<p>中断服务函数应该以IRET指令结束，这条指令使得保存的寄存器值从栈中恢复。IRET 指令也会是 l1 和 l0 从栈中恢复，同时程序恢复正常执行过程。</p>
<p>如果中断屏蔽位 l0 和 l1 在中断服务函数（ISR）中被使用 SIM 指令置位，使用 RIM 对中断屏蔽进行移除将造成软件优先级被设置为 0 级。</p>
<p>为了在中断服务函数中使能或禁止中断时恢复正确的优先级，遵循 Table 8 中的步骤来使能或禁止中断。</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b55e11a877.png" alt="Image.png"></p>
<h4 id="一、服务挂起中断"><a href="#一、服务挂起中断" class="headerlink" title="一、服务挂起中断"></a>一、服务挂起中断</h4><p>几个中断可以同时被挂起。下一个要处理的中断由以下两步操作决定：</p>
<p>1、最高软件优先级的中断被响应。</p>
<p>2、如果几个中断的软件优先级相同，硬件优先级最高的中断首先响应。</p>
<p>当一个中断请求没有被立即响应的时候，它将被锁存，并在软件优先级和硬件优先级相结合为最高优先级的时候进行处理。</p>
<p>注意：</p>
<p>1、硬件优先级是独一无二的，而软件的不是。这允许只有一个中断的时候能继续先前的过程。</p>
<p>2、在判定过程中，RESET，TLI 和 TRAP 被认为拥有最高软件优先级。</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b55fc57659.png" alt="Image.png"></p>
<h4 id="二、中断源"><a href="#二、中断源" class="headerlink" title="二、中断源"></a>二、中断源</h4><p>STM8中断控制器安排了两种中断源类型。</p>
<p>- 非可屏蔽中断：RESET，TLI 和 TRAP</p>
<p>- 可屏蔽中断：外部中断或内部外设触发的中断</p>
<p><strong>非可屏蔽中断源</strong></p>
<p>在处理非可屏蔽中断源时，忽略 CCR 寄存器的 l1 和 l0 的状态。PC，X，Y，A 和 CCR 寄存器只有在一个 TRAP 中断发生时入栈。然后，相应的中断向量载入 PC 寄存器，CCR 寄存器的 l1 和 l0 设置为禁止中断。</p>
<p>● TRAP（非可屏蔽软件中断）</p>
<p>​     当 TRAP 指令执行时，这个软件中断源得到响应。它和 TLI 一样根据 Figure 13 的流程图来响应。</p>
<p>​     TRAP 中断不允许处理器从 Halt 模式下退出。</p>
<p>● RESET</p>
<p>​     RESET 中断源拥有 STM8 最高等级的软件和硬件优先级。这意味着在复位程序的开始，所有的中断都会被禁止。它们必须被 RIM 指令重使能。</p>
<p>​     RESET 中断允许处理器从 Halt 模式下退出。</p>
<p>● TLI（顶级硬件中断）</p>
<p>​     这个硬件中断发生在在的 TLI 输入端检测到一个特定的边沿时。</p>
<p>​     TLI 服务函数中必须使用一个 TRAP 指令。</p>
<p><strong>可屏蔽中断源</strong></p>
<p>如果可屏蔽中断被使能，而且如果它自己在 ITC_SPRx 寄存器中的中断软件优先级比当前正在响应的中断（CCR 寄存器中的 l1 和 l0）高，该可屏蔽中断向量源开始响应。如果这两个条件之一没有满足，中断将被锁存并挂起。</p>
<p><strong>外部中断</strong></p>
<p>外部中断可被用来从 Halt 模式下唤醒 CPU。器件对外部中断的边沿敏感性可通过外部中断控制寄存器（EXTI_CRx）进行软件选择。</p>
<p>当连接到同一个中断线的几个输入引脚同时被选择时，他们是逻辑或的关系。</p>
<p>当外部电平触发中断被锁存时，如果给定的电平在中断程序的最后依然保持时，中断保持激活，除非它在程序中被禁止。</p>
<p><strong>外设中断</strong></p>
<p>大多数外部中断能将 MCU 从 Halt 模式下唤醒。</p>
<p>当外设状态寄存器中的一个特定的标志位置位，并且外设控制寄存器中相应的使能位置位时，发生一个外设中断。</p>
<p>​     </p>
<hr>
<h3 id="中断和低功耗模式"><a href="#中断和低功耗模式" class="headerlink" title="中断和低功耗模式"></a>中断和低功耗模式</h3><p>所有中断都能使处理器从 wait 模式中退出。</p>
<p>只有外部中断及其他特殊中断允许处理器从 halt 和 active-halt 模式下退出。</p>
<p>当从 halt 模式下唤醒又同时有几个中断挂起时，第一个响应的中断只能是一个能从 halt 模式退出的中断。它由 Figure14 中给出的过程精确选择。如果最高优先级的挂起中断不能将器件从 halt 模式中唤醒，将会响应下一个中断。</p>
<p>如果 HALT 指令执行时发生了任意内部或外部中断（例如定时器），HALT 指令会被执行完但是在 HALT 指令完成之后中断会立即调用唤醒机制。这样，MCU 实际上是从 halt 模式唤醒到 run 模式，相应的延迟参考 datasheet 中的 tWUH。</p>
<hr>
<h3 id="活跃等级-低功耗模式控制"><a href="#活跃等级-低功耗模式控制" class="headerlink" title="活跃等级/低功耗模式控制"></a>活跃等级/低功耗模式控制</h3><p>MCU 的活跃等级通过编程 CFG_GCR 寄存器中的 AL 位来配置。</p>
<p>这一位用来控制 MCU 的低功耗模式。在非常低功耗的应用中，MCU 的大部分时间花在 WFI，并且在特殊时刻（通过中断）来唤醒以执行特殊任务。这些再发任务中，有一些非常短，可以直接在中断服务函数（ISR）里执行，而不用回到主函数中。对于这种情况，可以在进入低功耗模式以前（同过执行 WFI 指令）将 AL 置位，然后中断函数直接返回到低功耗模式。由于寄存器上下文只保存在第一个中断中，run time/ISR 指令相应缩减。</p>
<p>因此，在非常简单的应用中，所有操作都可以在 ISR 中执行。在更复杂的应用中，一个中断函数可以通过复位 AL 位来重新启动主函数。</p>
<p>例如，一个应用可能需要每隔 50ms 由自动唤醒单元（AWU）来唤醒，以检查一些引脚/传感器/按键的状态。大部分时间，当这些引脚未激活时，MCU 可以返回到低功耗模式而不运行主函数。如果这些引脚的其中之一激活，ISR 将通过复位 AL 位来启动主函数。</p>
<hr>
<h3 id="并发和嵌套中断管理"><a href="#并发和嵌套中断管理" class="headerlink" title="并发和嵌套中断管理"></a>并发和嵌套中断管理</h3><p>STM8 器件的特色之一是有两个中断管理模式：</p>
<p>- 并发模式</p>
<p>- 嵌套模式</p>
<h4 id="一、并发中断管理模式"><a href="#一、并发中断管理模式" class="headerlink" title="一、并发中断管理模式"></a>一、并发中断管理模式</h4><p>在这以模式下，所有中断都是 3 级优先级，所以它们都不能被中断，除了 TLI，RESET 或 TRAP。</p>
<p>硬件优先级按照下面的从低到高的顺序给出：MAIN，IT4，IT3，IT2，IT1，IT0，TRAP/TLI（优先级相同），RESET。</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b56c0dcd3c.png" alt="Image.png"></p>
<p>二、嵌套中断管理模式：</p>
<p>在这个模式下，可以在中断函数中嵌套中断。只要有一个中断优先级低于 3 级，这个模式就会被激活。</p>
<p>硬件优先级按下面的从低到高的顺序给出：MAIN，IT4，IT3，IT2，IT1，IT0，TRAP。</p>
<p>每一个中断向量都可以通过设置相应的 ITC_SPRx 寄存器的 l1_x 和 l0_x 位，来配置软件优先级。l1_x 和 l0_x 位与 CCR 寄存器的 l1 和 l0 位的意义相同。</p>
<p>不能编程为等级 0（l1_x = 1，l0_x = 0）。在这种情况下，将保持先前存储的值。例如，如果先前的值为 0xcf，编程值等于 64h，结果是 44h。</p>
<p>RESET 和 TRAP 向量没有软件优先级。当其中一个被响应时，CCR 寄存器的 l1 和 l0 位都会置位。</p>
<p>注意：如果中断 x 被执行时，l1_x 和 l0_x 位被修改，器件会进行以下操作：如果中断 x 仍然挂起（新的中断或标志位没有清除）且新的软件优先级比先前的一个高，那么中断 x 将重新进入。否则，中断优先级将保持不变直到下一个中断请求（在中断 x 的 IRET 之后）。</p>
<p>在一个中断函数执行期间，HALT，POPCC，RIM，SIM 和 WFI 指令会改变当前的软件优先级，直到下一个 IRET 指令或前面提到的指令之一被发出。</p>
<p>警告：可能会发生栈溢出，而不通知软件这个错误。</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b56e820fb8.png" alt="Image.png"></p>
<p><img src="https://i.loli.net/2019/03/03/5c7b56f6c91b9.png" alt="Image.png"></p>
<hr>
<h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h3><p>五个中断向量专用于外部中断事件：</p>
<ul>
<li><p>PA 口有 5 个中断线：PA[6:2]</p>
</li>
<li><p>PB 口有 8 个中断线：PB[7:0]</p>
</li>
<li><p>PC 口有 8 个中断线：PC[7:0]</p>
</li>
<li><p>PD 口有 7 个中断线：PD[6:0]</p>
</li>
<li><p>PE 口有 8 个中断线：PE[7:0]</p>
</li>
</ul>
<p>除了 20 脚封装的器件可以使用一个备用功能重映射操作位在 PC3 脚上获得 TLI，其他器件的 PD7 是最高级中断源（TLI）。</p>
<p>为了触发一个中断，相应的 GPIO 端口必须配置成有中断功能的输入模式。</p>
<p>中断的边沿敏感性必须由 EXTI_CR1 和 EXTI_CR2 寄存器配置。</p>
<hr>
<h3 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h3><p><img src="https://i.loli.net/2019/03/03/5c7b57479ebfa.png" alt="Image.png"></p>
<p><img src="https://i.loli.net/2019/03/03/5c7b575da4506.png" alt="Image.png"></p>
<hr>
<h3 id="ITC（中断控制）和EXTI（外部中断）寄存器"><a href="#ITC（中断控制）和EXTI（外部中断）寄存器" class="headerlink" title="ITC（中断控制）和EXTI（外部中断）寄存器"></a>ITC（中断控制）和EXTI（外部中断）寄存器</h3><h4 id="一、CPU-状态码寄存器中断位（CCR）"><a href="#一、CPU-状态码寄存器中断位（CCR）" class="headerlink" title="一、CPU 状态码寄存器中断位（CCR）"></a>一、CPU 状态码寄存器中断位（CCR）</h4><p><img src="https://i.loli.net/2019/03/03/5c7b5840e7b1b.png" alt="Image.png"></p>
<p>l[1:0]：软件中断优先级位</p>
<p>这两位表示当前中断请求的软件优先级。当一个中断请求发生时，相应中断的软件优先级从软件优先级寄存器（ITC_SPRx）自动载入。</p>
<p>l[1:0] 位也可以使用 RIM，SIM，HALT，WFI，IRET 或 PUSH/POP 指令来软件清空。</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b585894fa4.png" alt="Image.png"></p>
<p>TLI，TRAP 和 RESET 时间可以中断一个 3 级的程序。</p>
<h4 id="二、软件优先级寄存器-x（ITC-SPRx）"><a href="#二、软件优先级寄存器-x（ITC-SPRx）" class="headerlink" title="二、软件优先级寄存器 x（ITC_SPRx）"></a>二、软件优先级寄存器 x（ITC_SPRx）</h4><p><img src="https://i.loli.net/2019/03/03/5c7b587097956.png" alt="Image.png"></p>
<p>由软件写入，来定义每一个中断向量的软件优先级。</p>
<p>ITC_SPR1 的 [1：0] 位由硬件强制置 1（TLI）</p>
<p>ITC_SPR8 的 [7：4] 位由硬件强制置 1</p>
<p>禁止写入 10（优先级 0），如果写入 10，将保持原来的值，且中断优先级不会改变。</p>
<h4 id="三、外部中断控制寄存器-1（EXTI-CR1）"><a href="#三、外部中断控制寄存器-1（EXTI-CR1）" class="headerlink" title="三、外部中断控制寄存器 1（EXTI_CR1）"></a>三、外部中断控制寄存器 1（EXTI_CR1）</h4><p><img src="https://i.loli.net/2019/03/03/5c7b5893277f1.png" alt="Image.png"></p>
<h4 id="四、外部中断控制寄存器-2（EXTI-CR2）"><a href="#四、外部中断控制寄存器-2（EXTI-CR2）" class="headerlink" title="四、外部中断控制寄存器 2（EXTI_CR2）"></a>四、外部中断控制寄存器 2（EXTI_CR2）</h4><p><img src="https://i.loli.net/2019/03/03/5c7b58e6cd03b.png" alt="Image.png"></p>
<h4 id="五、ITC-和-EXTI-寄存器映射和复位值"><a href="#五、ITC-和-EXTI-寄存器映射和复位值" class="headerlink" title="五、ITC 和 EXTI 寄存器映射和复位值"></a>五、ITC 和 EXTI 寄存器映射和复位值</h4><p><img src="https://i.loli.net/2019/03/03/5c7b59026b53a.png" alt="Image.png"></p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM8</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8S 供电</title>
    <url>//blog/2019/03/03/STM8S-%E4%BE%9B%E7%94%B5/</url>
    <content><![CDATA[<hr>
<p>STM8 MCU 有 4 种相对独立的供电电源：</p>
<p>- VDD/VSS：主电源（3V 到 5.5V）</p>
<p>- VDDIO/VSSIO：I/O 口供电电源（3V 到 5.5V ）</p>
<p>- VDDA/VSSA：模拟部分供电电源</p>
<p>- VREF+/VREF-：ADC 参考电源</p>
<a id="more"></a>
<p>VDD/VSS 引脚用来为内部主稳压器（MVR）和内部低功耗稳压器（LPVR）供电。这两个调节器的输出连在一起，向MCU的核（CPU，Flash 和 RAM）提供 1.8V 电压。</p>
<p>在低功耗模式下系统自动从 MVR 切换到 LPVR，以减少电流消耗。</p>
<p><strong>为了稳定 MVR，必须在 VCAP 脚接一个电容</strong>。</p>
<p>根据封装的大小，可能有一对或两对特定的 VDDIO/VSSIO 来给I/O供电。</p>
<p>VDDA/VSSA和VREF+/VREF- 都与ADC模块相连接。</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b5ace894e7.png" alt="Image.png"></p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM8</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8S 复位</title>
    <url>//blog/2019/03/03/STM8S-%E5%A4%8D%E4%BD%8D/</url>
    <content><![CDATA[<hr>
<p>stm8s 共 9 个复位源：</p>
<ul>
<li><p>NRST 引脚产生的外部复位</p>
</li>
<li><p>上电复位（POR）</p>
</li>
<li><p>掉电复位（BOR）</p>
</li>
<li><p>独立看门狗复位</p>
</li>
<li><p>窗口看门狗复位</p>
</li>
<li><p>软件复位 </p>
</li>
<li><p>SWIM 复位</p>
</li>
<li><p>非法操作码复位</p>
</li>
<li><p>EMS 复位：当一些关键的寄存器被破坏或错误加载时产生的复位</p>
</li>
</ul>
<a id="more"></a>
<hr>
<h3 id="一、复位电路"><a href="#一、复位电路" class="headerlink" title="一、复位电路"></a>一、复位电路</h3><p><img src="https://i.loli.net/2019/03/03/5c7b5d5ae2a63.png" alt="Image.png"></p>
<p>复位引脚 NRST 内部集成了弱上拉电阻 RPU，既可作为输入，也可作为开漏输出。</p>
<p>一个在复位引脚上宽度最小为 500ns 的低电平脉冲即可产生一个外部复位。对于复位的检测是异步进行的，因此即使 MCU 处于停机（Halt）模式，也有可能进入复位状态。</p>
<p>复位引脚也可以作为开漏输出用于对外部设备进行复位。</p>
<p>无论内部复位源是什么，一旦复位，内部复位电路都会产生一个至少脉宽为 20us 的复位脉冲。当没有外部复位发生时，内部弱上拉电阻可保证复位引脚处于高电平。</p>
<hr>
<h3 id="二、内部复位源"><a href="#二、内部复位源" class="headerlink" title="二、内部复位源"></a>二、内部复位源</h3><p>除了 POR 和 BOR，每个内部复位源在复位状态寄存器中都有一个标志位与之相对应。复位时，根据导致复位的复位源，这些标志位被分别设置。因此，这些标志位可用于指示引起最后一次复位的复位源。通过软件写 1 可清除标志位。</p>
<h4 id="1、上电复位（POR）和掉电复位（BOR）"><a href="#1、上电复位（POR）和掉电复位（BOR）" class="headerlink" title="1、上电复位（POR）和掉电复位（BOR）"></a>1、上电复位（POR）和掉电复位（BOR）</h4><p>上电期间，POR 保持设备处于复位状态，直到供电电压（VDD 和 VDDIO）到达 BOR 的启动电压。此时，BOR 复位取代 POR，POR 自动关闭。BOR 复位一直持续到供电电压到达工作电压。</p>
<p>当工作电压降到们限制 VIT- 以下时，BOR 也将产生一个复位，此后 POR 模块将重新准备好以响应下一次上电复位。</p>
<p>电压迟滞用以保证清楚地检测电压的上升和下降。</p>
<p>即使是 MCU 处于低功耗模式，BOR 也总是保持激活状态。</p>
<h4 id="2、非法操作码复位"><a href="#2、非法操作码复位" class="headerlink" title="2、非法操作码复位"></a>2、非法操作码复位</h4><p>为了提高设备的可靠性，防止意外行为的发生，使用了非法操作码检测系统。如果一个被执行的代码与任意操作码或预置字节均不相符，则产生一个复位。此功能与看门狗相配合，可是设备从一个意外错误或干扰中恢复。</p>
<p>一个有效的预置字节与一个有效的操作码组成的一个非法的组合将不会产生复位。</p>
<h4 id="3、EMS-复位"><a href="#3、EMS-复位" class="headerlink" title="3、EMS 复位"></a>3、EMS 复位</h4><p>为了避免由电磁干扰造成的对应用程序误写操作或系统挂起，大多数关键寄存器都有一个互补寄存器与之相对应。系统将会自动检测这些关键寄存器与其互补寄存器之间是否匹配。如果不匹配，则产生一个 EMS 复位，从而使应用程序恢复到正常操作。</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM8</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8S 时钟控制</title>
    <url>//blog/2019/03/03/STM8S-%E6%97%B6%E9%92%9F%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<hr>
<hr>
<h3 id="一、时钟控制"><a href="#一、时钟控制" class="headerlink" title="一、时钟控制"></a>一、时钟控制</h3><p>时钟控制器功能强大而且灵活易用。其目的在于使用户获得最好性能的同时，亦能保证消耗的功率最低。</p>
<p>用户可独立管理各个时钟源，并将它们分配到 CPU 各个外设。主时钟和 CPU 时钟均带有预分频器。</p>
<a id="more"></a>
<p>具有安全可靠的无故障时钟切换机制，可在程序运行中将主时钟从一个时钟源切换到另一个时钟源。</p>
<hr>
<h3 id="二、抗电磁干扰时钟配置寄存器"><a href="#二、抗电磁干扰时钟配置寄存器" class="headerlink" title="二、抗电磁干扰时钟配置寄存器"></a>二、抗电磁干扰时钟配置寄存器</h3><p>为了避免由电磁干扰造成的对应用程序误写操作或系统挂起，大多数关键的时钟寄存器都有一个互补寄存器与之相对应。系统将会自动检测这些关键寄存器与其互补寄存器之间是否匹配。如果不匹配，则产生一个 EMS 复位，从而使应用程序恢复到正常操作。</p>
<hr>
<h3 id="三、时钟树"><a href="#三、时钟树" class="headerlink" title="三、时钟树"></a>三、时钟树</h3><p><img src="https://i.loli.net/2019/03/03/5c7b663ce673f.png" alt="Image.png"></p>
<hr>
<h3 id="四、主时钟源"><a href="#四、主时钟源" class="headerlink" title="四、主时钟源"></a>四、主时钟源</h3><p>下面 4 种时钟源可用作主时钟：</p>
<ul>
<li><p>1~24MHz 高速外部晶体振荡器（HSE）</p>
</li>
<li><p>最大 24MHz 高速外部时钟信号（HSE user-ext）</p>
</li>
<li><p>16MHz 高速内部 RC 振荡器（HSI）</p>
</li>
<li><p>128KHz 低速内部 RC（LSI）</p>
</li>
</ul>
<p>各个时钟源可单独打开或关闭，从而优化功耗。</p>
<h4 id="1、HSE"><a href="#1、HSE" class="headerlink" title="1、HSE"></a>1、HSE</h4><p>高速外部时钟信号可由以下两个时钟源产生：</p>
<ul>
<li><p>HSE外部晶体/陶瓷谐振器</p>
</li>
<li><p>HSE用户外部有源时钟</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/03/03/5c7b66e1d3756.png" alt="Image.png"></p>
<p>为了最大限度减小输出失真和减小启动的稳定时间，谐振器和负载电容应尽可能得靠近振荡器引脚。负载电容值应根据所选的振荡器进行调整。</p>
<p>外部晶体振荡器在启动时的输出时钟信号是不稳定的，默认情况下，在时钟信号被使用之前会插入 2048 个振荡周期的延迟。用户可通过设置选项字节 HSECNT 来缩短稳定时间。</p>
<p>外部时钟寄存器 CLK_CEKR 中的标志位 HSERDY 用以指示高速外部振荡器是否稳定。启动时， HSE 时钟信号将不会生效直至次标志位被硬件置位。</p>
<p>HSE 晶体可通过设置外部时钟寄存器 CLK_ECKR 中的 HSEEN 位来打开或关闭。</p>
<p>用户可通过编程选项位 EXTCLK 选择 HSE 用户外部时钟模式，此时，占空比约 50% 的外部时钟信号（方波，正弦波，三角波）用以驱动 OSCIN 引脚，而 OSCOUT 引脚可作为 GPIO 使用。</p>
<h4 id="2、HSI"><a href="#2、HSI" class="headerlink" title="2、HSI"></a>2、HSI</h4><p>HSI 信号由内部 16MHz RC 振荡器与一个可编程分频器（分频因子从 1 到 8）产生。分频因子由寄存器 CLK_CKDIVR 决定。</p>
<p>启动时，主时钟源默认为 HSI RC 时钟的 8 分频，即 fHSI/8。</p>
<p>HSI RC 可提供一个低成本的 16MHz 时钟源，占空比 50%。HSI 启动速度比 HSE 晶体振荡器快，但是精度即使校准也仍然比外部晶体振荡器或陶瓷谐振器低。</p>
<p>内部时钟寄存器 CLK_ICKR 中的标志位 HSIRDY 用以指示 HSI RC 是否稳定。启动时，HSI 时钟信号将不会生效直至此标志位被硬件置位。</p>
<p>HSI RC 可通过设置内部时钟寄存器 CLK_ICKR 中的 HSIEN 位打开或关闭。</p>
<p><strong>备份时钟源</strong></p>
<p>当 HSE 晶体振荡器失效时 HSI/8 可作为备份时钟源使用。</p>
<p><strong>快速启动特性</strong></p>
<p>如果寄存器 CLK_ICKR 中的 FHWU 位被置 1，则MCU从停机（Halt）模式或活跃停机（Active Halt）模式唤醒时，HSI 将自动被设为主时钟源。 </p>
<p><strong>校准</strong></p>
<p>每个产品在出厂时均已经 ST 校准。</p>
<p>复位后，出厂校准值将被自动加载至内部校准寄存器。</p>
<p>如果实际应用中电压或温度偏差较大，将会影响 RC 振荡器的速度。用户可使用 HSI 时钟校准寄存器修正 HSI 的时钟频率。</p>
<h4 id="3、LSI"><a href="#3、LSI" class="headerlink" title="3、LSI"></a>3、LSI</h4><p>128KHz 的 LSI RC 时钟是一个低功耗低成本的可选主时钟源，也可在停机（Halt）模式下作为维持独立看门狗和自动唤醒单元（AWU）运行的低功耗时钟源。</p>
<p>LSI 可通过设置内部时钟寄存器 CLK_ICKR 中的 LSIEN 位打开或关闭。</p>
<p>内部时钟寄存器 CLK_ICKR 中的标志位 LSIRDY 用以指示 LSI 是否稳定。启动时，LSI 时钟信号将不会生效直至此标志位被硬件置位。</p>
<p>LSI 出厂也已经校准，但用户不能再进一步校准。</p>
<p>注意：当独立看门狗使用 LSI 为时钟源时，为了保证 CPU 在系统出错时不与独立看门狗使用同一个时钟，当选项字节位 LSI_EN 为 0 时，LSI 不能作为主时钟。</p>
<hr>
<h3 id="五、主时钟切换"><a href="#五、主时钟切换" class="headerlink" title="五、主时钟切换"></a>五、主时钟切换</h3><p>时钟切换功能为用户提供了一中易用、快速、安全的从一个时钟源切换到另一个时钟源的途径。</p>
<h4 id="1、系统启动"><a href="#1、系统启动" class="headerlink" title="1、系统启动"></a>1、系统启动</h4><p>为使系统快速启动，复位后时钟控制器自动使用 HSI 的 8 分频作为主时钟。其原因为 HSI 的稳定时间短，而 8 分频可保证系统在较差的 VDD 条件下安全启动。</p>
<p>一旦主时钟源稳定，用户程序可将主时钟切换到另外的时钟源。</p>
<h4 id="2、主时钟切换的过程"><a href="#2、主时钟切换的过程" class="headerlink" title="2、主时钟切换的过程"></a>2、主时钟切换的过程</h4><h5 id="1）自动切换"><a href="#1）自动切换" class="headerlink" title="1）自动切换"></a>1）自动切换</h5><p>自动切换使用户可使用最少的指令完成时钟源的切换。应用软件可继续其它操作而不用考虑切换事件所占的确切时间。</p>
<ul>
<li><p>设置切换控制寄存器（CLK_SWCR）中的位 SWEN，使能切换机制。</p>
</li>
<li><p>向主时钟切换寄存器（CLK_SWR）写入一个 8 位的值，用以选择目标时钟源。寄存器 CLK_SWCR 的 SWBSY 被硬件置位，目标源振荡器启动。原时钟源依然被用于驱动内核和外设。</p>
</li>
</ul>
<p>一旦目标时钟源稳定，寄存器 CLK_SWR 中的值将被复制到主时钟状态寄存器（CLK_CMSR）中去。</p>
<p>此时，SWBSY 位被清除，新时钟源替代旧时钟源。寄存器 CLK_SWCR 中的标志位 SWIF 被置位，如果 SWIEN 为 1，则会产生一个中断。</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b6a715920c.png" alt="Image.png"></p>
<h5 id="2）手动切换"><a href="#2）手动切换" class="headerlink" title="2）手动切换"></a>2）手动切换</h5><p>与自动切换不同，不能立即切换，但它允许用户精确地控制切换事件发生的时间。</p>
<ul>
<li><p>向主时钟切换寄存器（CLK_SWR）写入一个 8 位的值，用以选择目标时钟源。寄存器 CLK_SWCR 的 SWBSY 被硬件置位，目标源振荡器启动。原时钟源依然被用于驱动内核和外设。</p>
</li>
<li><p>用户软件需等待至目标时钟源稳定。寄存器 CLK_SWCR 中的标志位 SWIF 用以指示目标时钟源是否已稳定，如果 SWIEN 为 1，则会产生一个中断。</p>
</li>
<li><p>最后，由用户软件在所选的时间点，设置寄存器 CLK_SWCR 中的位 SWEN，执行切换。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/03/03/5c7b6ad97c5d4.png" alt="Image.png"></p>
<p>无论是手动切换还是自动切换，如果源时钟源仍然在被其他模块使用（如 LSI 在被独立看门狗使用），则原时钟源将不会被自动关闭。配置内部时钟寄存器 CLK_ICKR 和外部时钟寄存器 CLK_ECKR 中的相应位，可关闭原时钟源。</p>
<p>如果由于某种原因时钟切换没有成功，软件可通过清除标志位 SWBSY 以复位当前的切换操作，使寄存器 CLK_SWR 恢复原值（原时钟源）。</p>
<hr>
<h3 id="六、低速时钟源的选择"><a href="#六、低速时钟源的选择" class="headerlink" title="六、低速时钟源的选择"></a>六、低速时钟源的选择</h3><p>可通过选择位 CKAWUSEL 来选择自动唤醒单元（AWU）和独立看门狗所使用的低速时钟源，可以是 LSI 或 HSE 的分频。</p>
<p>HSE 的分频值可通过选项字节位 HSEPRSC[1:0] 编程。目的是是 HSE 分频器输出一个 128KHz 的时钟信号。</p>
<hr>
<h3 id="七、CPU-时钟分频器"><a href="#七、CPU-时钟分频器" class="headerlink" title="七、CPU 时钟分频器"></a>七、CPU 时钟分频器</h3><p>CPU 时钟 fCPU 由主时钟 fMASTER 分频而来，分频因子由时钟分频寄存器（CLK_CKDIVR）中的位 CPUDIV[2:0] 决定。共 7 个分频因子可供选择（1 至 128 中，2 的幂）。</p>
<p><strong>fCPU 为 CPU 和窗口看门狗提供时钟</strong>。</p>
<hr>
<h3 id="八、外设时钟门控"><a href="#八、外设时钟门控" class="headerlink" title="八、外设时钟门控"></a>八、外设时钟门控</h3><p>关闭未使用外设的时钟可降低功耗。外设的时钟门控（PCG）模式使用户可在运行模式下随时打开或关闭 fMASTER 与下列外设的连接：</p>
<ul>
<li><p>ADC</p>
</li>
<li><p>I2C</p>
</li>
<li><p>AWU（寄存器时钟，而非计数器时钟）</p>
</li>
<li><p>SPI</p>
</li>
<li><p>TIM[4:1]</p>
</li>
<li><p>UART</p>
</li>
<li><p>CAN（寄存器时钟，而非 CAN 时钟）</p>
</li>
</ul>
<p><strong>系统复位后，所有外设时钟均处于开的状态</strong>。用户可通过清除 CLK_PCKENR1 或 CLK_PCKENR2 中的 PCKEN 位来关闭响应的外设时钟。但是在关闭外设的时钟前，用户必须设置响应的位禁用该外设。</p>
<p>为了使能一个外设，用户必须先设置寄存器 CLK_PCKENR 中对应的 PCKEN 位，然后设置外设控制寄存器中的外设使能位。</p>
<p>AWU 计数器是由独立于 fMASTER 的内部或外部时钟（LSI 或 HSE）驱动，因此，即使寄存器的时钟已被关掉，该外设依然可以继续运行。</p>
<hr>
<h3 id="九、时钟安全系统（CSS）"><a href="#九、时钟安全系统（CSS）" class="headerlink" title="九、时钟安全系统（CSS）"></a>九、时钟安全系统（CSS）</h3><p>时钟安全系统用于监控 HSE 时钟源是否失效。当 fMASTER 使用 HSE 作为时钟源时，如果 HSE 时钟由于谐振器损坏、断开或其它原因失效，时钟控制器将激活安全恢复机制，将 fMASTER 自动切换到辅助时钟源 HSI/8。系统将一直使用辅助时钟源，直至 MCU 被复位。</p>
<p>设置时钟安全系统寄存器 CLK_CSSR 中的 CSSEN 位，可使能时钟安全系统。为安全起见，CSS 一旦使能就不能被关闭，直到下一次复位。</p>
<p>必须满足下面的条件，CSS 方可检测 HSE 石英晶体的失效：</p>
<ul>
<li><p>HSE 晶体开：（外部时钟寄存器 CLK_ECKR 中的位 HSEEN=1）</p>
</li>
<li><p>HSE 振荡器被置为石英晶体：（选项位 EXTCLK为 1）</p>
</li>
<li><p>CSS 功能开：（寄存器 CLK_CSSR 中 CSSEN=1）</p>
</li>
</ul>
<p>如果当前的主时钟源位 HSE，当失效被检测到时，CSS 将执行以下操作：</p>
<ul>
<li><p>寄存器 CLK_CSSR 中的 CSSD 位被置为，如果 CSSIEN 为 1，则同时产生一个中断</p>
</li>
<li><p>CLK_CMSR，CLK_SWR，及 CLK_CKDIVR 中的 HSIDIV[1:0] 位被置为复位值（CKM[7:0]=SW[7:0]=E1h）。HSI/8 称为主时钟</p>
</li>
<li><p>每部时钟寄存器 CLK_ICKR 中的 HSIEN 被置位（HSI开）</p>
</li>
<li><p>外部时钟寄存器 CLK_ECKR 中的 HSEEN 被清除（HSE关）</p>
</li>
<li><p>AXU 位被置位，用以指示辅助时钟源 HSI/8 被强制使用</p>
</li>
</ul>
<p>用户可通过软件清除 CSSD 位，但 AXU位 只能由复位清除。</p>
<p>为了提高时钟频率，用户在清除寄存器 CLK_CSSR 中的 CSSD 位以后，课修改寄存器 CLK_CKDIVR 中的 HSIDIV[1:0] 位。</p>
<p>如果失效发生时 HSE 不是主时钟源，主时钟将不会被切换到辅助时钟源，以上操作也不会发生，仅执行下面的操作：</p>
<ul>
<li><p>外部时钟寄存器 CLK_ECKR 中的 HSEEN 被清除，HSE 关闭。</p>
</li>
<li><p>寄存器 CLK_CSSR 中的位 CCSD 被置位，如果 CSSIEN 位 1，则同时产生一个中断。</p>
</li>
</ul>
<p>如果 HSE 不是当前主时钟源，且主时钟正在被切换至 HSE，则在清除 CSSD 位之前，必须先清除寄存器 CLK_SWCR 的 SWBSY 位。</p>
<p>如果当失效被检测到时，HSE 被 CCOSEL 选择为时钟输出模式，则 HSI（HSIDIV）将替代 HSE，被自动强制选择为输出时钟。</p>
<hr>
<h3 id="十、时钟输出功能（CCO）"><a href="#十、时钟输出功能（CCO）" class="headerlink" title="十、时钟输出功能（CCO）"></a>十、时钟输出功能（CCO）</h3><p>可配置的时钟输出功能使用户可在外部管脚 CCO 上输出指定的时钟。用户可选择下 6 种时钟信号之一作为 CCO 时钟：</p>
<ul>
<li><p>fHSE</p>
</li>
<li><p>fHSI</p>
</li>
<li><p>fHSIDIV</p>
</li>
<li><p>fLSI</p>
</li>
<li><p>fMASTER</p>
</li>
<li><p>fCPU（可选择分频）</p>
</li>
</ul>
<p>注意：在所有可能的分频值下，不能保证信号的占空比全部为 50%。</p>
<p>通过配置时钟输出寄存器 CLK_CCOR 中域 CCOSEL[3:0] 可选择输出的时钟。</p>
<p>用户需位指定的 I/O 引脚选择期望输出的时钟。<strong>此 IO 必须通过配置寄存器 Px_CR1 对应的位为 1 来设为上拉输入或推挽输出模式</strong>。</p>
<p>一旦可配置始终输出寄存器 CLK_CCOR 的 CCOEN=1 就开始输出所选定的时钟信号。</p>
<p>如果 CCOBSY 位 为1，则表明可配置时钟输出系统正在工作。只要 CCOBSY 为 1，CCOSEL 位就会被写保护。</p>
<p>如果需要，CCO 可自动激活目标振荡器。当所选时钟就绪时，CCORDY 被置位。</p>
<p>用户可通过清除 CCOEN 位来禁用时钟输出功能。CCOBSY 位和 CCORDY 位都将保持为 1 直到禁用操作结束。从清除 CCOEN 位到这两个标志位被复位之间的时间可能会很长，例如当所选的输出时钟相对于 fCPU 频率很低时。</p>
<hr>
<hr>
<h3 id="十一、时钟中断"><a href="#十一、时钟中断" class="headerlink" title="十一、时钟中断"></a>十一、时钟中断</h3><p>​     当下列事件发生时，时钟控制器可产生中断：</p>
<ul>
<li><p>主时钟源切换事件</p>
</li>
<li><p>CSS 事件</p>
</li>
</ul>
<p>​     这两个中断均可被独立屏蔽</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b6b9f5868f.png" alt="Image.png"></p>
<hr>
<h3 id="十二、时钟寄存器"><a href="#十二、时钟寄存器" class="headerlink" title="十二、时钟寄存器"></a>十二、时钟寄存器</h3><p>内部时钟寄存器              CLK_ICKR</p>
<p>外部时钟寄存器              CLK_ECKR</p>
<p>主时钟状态寄存器           CLK_CMSR</p>
<p>主时钟切换寄存器           CLK_SWR</p>
<p>切换控制寄存器              CLK_SWCR</p>
<p>时钟分频寄存器              CLK_CKDIVR</p>
<p>外设时钟门控寄存器1      CLK_PCKENR1</p>
<p>外设时钟门控寄存器2      CLK_PCKENR2</p>
<p>时钟安全系统寄存器        CLK_CSSR</p>
<p>可配置时钟输出寄存器     CLK_CCOR</p>
<p>CAN外部时钟控制寄存器 CLK_CANCCR</p>
<p>HSI时钟修正寄存器         CLK_HSITRIMR</p>
<p>SWIM时钟控制寄存器     CLK_SWIMCCR</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM8</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM CMSIS-DSP 库简介</title>
    <url>//blog/2019/03/04/ARM-CMSIS-DSP-%E5%BA%93%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<hr>
<p>CMSIS 的 DSP 库主要提供以下数字信号处理算法：</p>
<p>1、BasicMathFunctions</p>
<p>提供基本的数据运算，如加减乘除，以 _f32 结尾的函数是浮点运算，以 _q8，_q15，_q31 结尾的函数是定点运算。</p>
<a id="more"></a>
<p>2、FastMathFunctions</p>
<p>主要提供 SIN，COS 以及平方根 SPRT 的运算。</p>
<p>3、ComplexMathFunctions</p>
<p>复杂数学运算，主要是向量，求模等运算。</p>
<p>4、FilteringFunctions</p>
<p>主要是滤波函数，如 IIR，FIR，LMS 等。</p>
<p>5、MatrixFunctions</p>
<p>主要是矩阵运算。</p>
<p>6、TransformFunctions</p>
<p>变换功能。包括复数 FFT（CFFT）/负数 FFT 逆运算（CIFFT）、实数 FFT（RFFT）/实数 FFT 逆运算。</p>
<p>7、ControllerFunctions</p>
<p>控制功能，主要为 PID 控制函数。arm_sin_cos_f32/_q31.c 函数提供 360 点正余弦函数表和任意角度的正余弦函数值计算功能。</p>
<p>8、StatisticsFunctions</p>
<p>统计功能函数，如求平均值、计算 RMS 等。</p>
<p>9、SupportFunctions</p>
<p>支持功能函数，如数据拷贝，Q 格式和浮点格式相互转换。</p>
<p>10、CommonTables</p>
<p>arm_common_tables.c 文件提供位翻转或相关参数表。</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8S 电源管理</title>
    <url>//blog/2019/03/03/STM8S-%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<hr>
<p>默认情况下在系统或电源复位后，MCU 处于运行模式。在这种模式下，CPU 由 fCPU 提供时钟并执行程序代码，系统时钟分别为各个处于激活状态的外设提供时钟，MCU 功耗最大。</p>
<a id="more"></a>
<p>在运行模式下，为了保持 CPU 继续运行并执行代码，有以下几种途径可以降低功率消耗：</p>
<ul>
<li><p>降低系统时钟</p>
</li>
<li><p>关闭未使用外设的时钟</p>
</li>
<li><p>关闭所有未使用的模拟功能块</p>
</li>
</ul>
<p>但是，如果 CPU 不需要保持运行，可使用下列三种低功耗模式：</p>
<ul>
<li><p>等待（Wait）</p>
</li>
<li><p>活跃停机（Active Halt）可配置为慢速或快速唤醒</p>
</li>
<li><p>停机（Halt）可配置为慢速或快速唤醒</p>
</li>
</ul>
<p>用户可选择以上三种模式中的一种，并合理配置，以在最低功耗、最快唤醒速度和可使用的唤醒源之间获得最佳平衡点。</p>
<hr>
<h3 id="一、常规考虑"><a href="#一、常规考虑" class="headerlink" title="一、常规考虑"></a>一、常规考虑</h3><p>硅片中通常存在两种功耗：</p>
<ul>
<li><p>静态功耗：由极化电流和漏电流造成。静态功耗很小，只在停机（Halt）模式和活跃停机（Active Halt）模式下有意义。</p>
</li>
<li><p>动态功耗：来自于芯片上正在运行的数字模块。它取决于 VDD，时钟频率和负载电容。</p>
</li>
</ul>
<p>一个 MCU 的功耗取决于：</p>
<ul>
<li><p>VDD 供电电压</p>
</li>
<li><p>模拟性能</p>
</li>
<li><p>MCU 大小及数字逻辑门数（漏电流及负载电容）</p>
</li>
<li><p>时钟频率</p>
</li>
<li><p>处于激活状态的外设数目</p>
</li>
<li><p>可用的低功耗模式及级别</p>
</li>
</ul>
<p>MCU 的处理速度也很重要，这使得用户程序只需很短时间处于运行状态，而更多时间处于低功耗模式下。</p>
<hr>
<h3 id="二、低功耗的时钟管理"><a href="#二、低功耗的时钟管理" class="headerlink" title="二、低功耗的时钟管理"></a>二、低功耗的时钟管理</h3><h4 id="1、降低系统时钟"><a href="#1、降低系统时钟" class="headerlink" title="1、降低系统时钟"></a>1、降低系统时钟</h4><p>通过写时钟分频寄存器 CLK_CKDIVR 的位 CPUDIV[2:0]，可降低 fCPU 的时钟频率。这会降低 CPU 的速度，但同时可降低 CPU 的功耗。其它外设（由 fMASTER 提供时钟）不会受此设置影响。</p>
<p>在运行模式下，任何时候需要恢复全速运行，将 CPUDIV[2:0] 清 0 即可。</p>
<h4 id="2、外设时钟门控"><a href="#2、外设时钟门控" class="headerlink" title="2、外设时钟门控"></a>2、外设时钟门控</h4><p>使用时钟门控，用户可在任意时间打开或关闭 fMASTER 与各个外设的连接，在运行模式和等待模式均有效。</p>
<hr>
<h3 id="三、低功耗模式"><a href="#三、低功耗模式" class="headerlink" title="三、低功耗模式"></a>三、低功耗模式</h3><p><img src="https://i.loli.net/2019/03/03/5c7b6f3d4ef26.png" alt="Image.png"></p>
<h4 id="1、等待模式（Wait）"><a href="#1、等待模式（Wait）" class="headerlink" title="1、等待模式（Wait）"></a>1、等待模式（Wait）</h4><p>在运行模式下执行 WFI（等待中断）指令，可进入等待模式。此时 CPU 停止运行，但外设与中断控制器仍保持运行，因此功耗会有所降低。等待模式可与 PCG（外设时钟门控），降低 CPU 时钟频率，以及选择低功耗时钟源（LSI，HSI）相结合使用，以进一步降低系统功耗。</p>
<p>等待模式下，所有寄存器与 RAM 的内容保持不变，之前所定义的时钟配置也保持不变（CLK_CMSR） 。</p>
<p>当一个内部或外部中断请求发生时，CPU 从等待模式唤醒并恢复工作。</p>
<h4 id="2、停机模式（Halt）"><a href="#2、停机模式（Halt）" class="headerlink" title="2、停机模式（Halt）"></a>2、停机模式（Halt）</h4><p>该模式下主时钟停止。即由 fMASTER 提供时钟的 CPU 及所有外设均被关闭。因此，所有外设均没有时钟，MCU 的数字部分不消耗能量。</p>
<p>停机模式下，所有寄存器与 RAM 的内容保持不变，默认情况下时钟配置也保持不变（CLK_CMSR）。</p>
<p>MCU 可通过执行 HALT 指令进入停机模式。外部中断可将 MCU 从停机模式唤醒。外部中断指配置为中断输入的 GPIO 端口或具有触发外设中断能力的端口。</p>
<p>这种模式下，仅低电压调节器（和掉电复位）处于工作状态。</p>
<p><strong>快速时钟启动</strong></p>
<p>HSI RC 的启动速度比 HSE 快。因此，为了减少 MCU 唤醒时间，建议在进入暂停模式前选择 HSI 作为 fMASTER 的时钟源。在进入停机模式前可通过设置内部时钟寄存器 CLK_ICKR 的 FHWU 位选择 HSI 作为 fMASTER 的时钟源，而无需时钟切换。 </p>
<h4 id="3、活跃停机模式（Active-Halt）"><a href="#3、活跃停机模式（Active-Halt）" class="headerlink" title="3、活跃停机模式（Active Halt）"></a>3、活跃停机模式（Active Halt）</h4><p>活跃停机模式与停机模式类似，但它不需要外部中断唤醒。它使用 AWU，在一定的延时后，产生一个内部唤醒事件，延迟时间是用户可编程的。</p>
<p>在活跃停机模式下，主振荡器，CPU 以及几乎所有外设都被停止。如果 AWU 和 IWD 已被使能，则只有 LSI RC 和 HSE 仍处于运行状态，以驱动 AWU 和 IWD 计数器。</p>
<p>为进入活跃停机模式，需首先使能 AWU然后执行 HALT 指令。</p>
<p><strong>主电源调节器自动关闭</strong></p>
<p>默认情况下，为了从活跃停机模式快速唤醒，主电压调节器处于激活状态。但其电流消耗是不可忽视的。</p>
<p>为进一步降低功耗，当 MCU 进入活跃停机模式时，主电压调节器可自动关闭。通过设置内部时钟寄存器 CLK_ICKR 的 REGAH 位可实现此功能。此时:</p>
<p>- MCU 内核由低功耗电压调节器（LPVR）供电。</p>
<p>- 仅 LSI 时钟源可用，因为 HSE 时钟源对于 LPVR 来说电流消耗太大。</p>
<p>在唤醒时主电压调节器重新被打开，这需要一个比较长的唤醒时间。</p>
<p><strong>快速唤醒时钟</strong></p>
<p>为了缩短唤醒时间，建议使用 HSI 作为 fMASTER 的时钟源。FHWU 位也可用于缩短切换时间。</p>
<p>在活跃停机模式下，快速唤醒时很重要的。这可以提高 CPU 的执行效率，使 MCU 处于运行状态与低功耗模式之间的时间最短，从而减少整体平均功耗。</p>
<hr>
<h3 id="四、附加的模拟功耗控制"><a href="#四、附加的模拟功耗控制" class="headerlink" title="四、附加的模拟功耗控制"></a>四、附加的模拟功耗控制</h3><h4 id="1、停机模式下的快速内存唤醒"><a href="#1、停机模式下的快速内存唤醒" class="headerlink" title="1、停机模式下的快速内存唤醒"></a>1、停机模式下的快速内存唤醒</h4><p>默认情况下，MCU 进入 Halt 模式后 FLASH 是处于掉电状态的。此时，漏电流可忽略，功耗是非常低的。但 FLASH 的唤醒时间较长（几us）。</p>
<p>​    </p>
<p>如果用户需要从 Halt 模式快速唤醒，可将 FLASH_CR1 的 HALT 位置 1。当 MCU 进入停机模式时，这将确保 FLASH 处于等待状态，唤醒时间降至几纳秒。但功耗将增至几 uA。</p>
<h4 id="2、活跃停机模式下的超低内存功耗"><a href="#2、活跃停机模式下的超低内存功耗" class="headerlink" title="2、活跃停机模式下的超低内存功耗"></a>2、活跃停机模式下的超低内存功耗</h4><p>在活跃停机模式下，为加快唤醒时间，默认情况下 FLASH 处于工作状态，因此并没有降低功耗。</p>
<p>为降低功耗，用户可将 FLASH_CR1 的 AHALT 位置 1。在进入活跃停机模式时，这将停止向 FLASH 供电以降低功耗，但唤醒时间将增至微秒级。</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM8</tag>
      </tags>
  </entry>
  <entry>
    <title>Altium Designer PCB 操作总结</title>
    <url>//blog/2019/03/04/Altium-Designer-PCB-%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr>
<p>1、定原点（PCB文件原点）</p>
<p>Edit -&gt; origin</p>
<a id="more"></a>
<hr>
<p>2、定义尺寸（可以最开始定，也可以最后定）</p>
<p>先画mechanical layer，再复制到 keep-out-layer（要粘贴时先点Edit-&gt;paste special），然后  Design -&gt; Board Shape -&gt; Redefine Board Shape</p>
<hr>
<p>3、测量距离</p>
<p>ctrl+M </p>
<hr>
<p>4、 更换线型</p>
<p>ctrl+space，用“&lt;”和“&gt;”可改变倒角曲率半径</p>
<hr>
<p>5、铺地</p>
<p>place -&gt; polygon pour -&gt; connect to GND，选 top layer 或 bottom layer，选 pour over all same objects -&gt; 选范围 -&gt; 确定</p>
<hr>
<p>6、焊盘</p>
<p>贴片焊盘用 top layer，过孔焊盘用multi layer</p>
<hr>
<p>7、旋转</p>
<p>空格</p>
<hr>
<p>8、打开/关闭层</p>
<p>L</p>
<hr>
<p>9、切换层</p>
<p>小键盘 *</p>
<hr>
<p>10、添加层</p>
<p>design -&gt;layer stack manager -&gt;点击 Toplayer 或 Bottomlayer -&gt; 信号层 add layer/内电层 add plane</p>
<p>如果要分割，不要添加 net</p>
<hr>
<p>11、泪滴</p>
<p>Tools -&gt; Teardoops</p>
<hr>
<p>12、铺铜皮</p>
<p>Place -&gt; 矩形 Fill / 多边形 Solid region</p>
<hr>
<p>13、灌铜</p>
<p>Place -&gt; Polygon Pour（需要设置 net，也可以不设）</p>
<p>灌铜掏空：Place -&gt; Polygon Pour Cutout</p>
<hr>
<p>14、走线换层</p>
<p>shift + ctrl +鼠标滑轮</p>
<hr>
<p>15、原理图更新到 PCB 时出现 unknown pin</p>
<p>删除 PCB 图中所有 net（design -&gt; netlist）</p>
<hr>
<p>16、元件换层</p>
<p>拖住按 L</p>
<hr>
<p>17、选中需要修整的铜皮  M+G</p>
<p>修钝角 P+Y</p>
<hr>
<p>18、PCB 图中修改丝印字体</p>
<p>任一丝印右键 -&gt; find similar objects -&gt; text width 选 same -&gt; OK -&gt; 在 PCB inspector 中修改</p>
<hr>
<p>19、隐藏网络飞线</p>
<p>N -&gt; Hide Connections 选 Net</p>
]]></content>
      <tags>
        <tag>软件使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Cadence Allegro 操作总结</title>
    <url>//blog/2019/03/04/Cadence-Allegro-%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr>
<p>1、查看快捷键</p>
<p>命令行输入alias</p>
<a id="more"></a>
<hr>
<p>2、显示丝印</p>
<p>菜单栏 color192（四个方块）-&gt; component -&gt; silkscreen打钩</p>
<hr>
<p>3、关闭和显示网络飞线</p>
<p>Display -&gt; Show Rats -&gt; All -&gt; 即可打开显示所有的网络飞线（未布线的网络）</p>
<p>Display -&gt; Blank Rats -&gt; All -&gt; 关闭隐藏所有的网络飞线</p>
]]></content>
      <tags>
        <tag>软件使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Altium Designer 原理图操作总结</title>
    <url>//blog/2019/03/04/Altium-Designer-%E5%8E%9F%E7%90%86%E5%9B%BE%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr>
<p>1、统一改 IC 标号</p>
<p>Tools -&gt; Annotate Schematic -&gt; Reset All -&gt; UpdateChanges List</p>
<a id="more"></a>
<hr>
<p>2、统一改封装</p>
<p>器件右键 -&gt; Find Similar Objects -&gt; Description 选 same -&gt; Symbol Reference 选 same -&gt; OK -&gt; CTRL + A -&gt; 改 current footprint -&gt; 左击菜单外的工作台</p>
<p>改完之后因为过滤器其他器件为灰色，此时在工作台任意位置右键，点 Filter，clear filter</p>
<hr>
<p>3、导出 BOM</p>
<p>需要将每一个器件的 comment 改成对应的阻值容值，template 选 BOM Default Template 95.xlt，最后点 Export</p>
]]></content>
      <tags>
        <tag>软件使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Cadence Capture 加页码的方法</title>
    <url>//blog/2019/03/04/Cadence-Capture-%E5%8A%A0%E9%A1%B5%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>1、 选中 .dsn 文件（工程文件）</p>
<p>2、执行 tools 菜单里的 Annotate 命令</p>
<p>3、在弹出的 Annotate 对话框中选择 Packaging 页</p>
<p>4、在 action 栏选择 Add Intersheet References</p>
<p>5、点击 “确定” 按钮进入 Intersheet References 对话框，勾选第一项：Place on off page connectors</p>
<a id="more"></a>
<p>注意，在 title block 里面一定要有正确的页码，比如 1 of 8，  2 of 8 等等，这个是打页码的依据。</p>
<p>添加 title block的方法： place -&gt; title block。</p>
<p>如果要删除 off page connector 的页面编号，在 Annotate 对话框中，选择 Delete Intersheet References 即可删除。</p>
]]></content>
      <tags>
        <tag>软件使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Cadence Capture 操作总结</title>
    <url>//blog/2019/03/04/Cadence-Capture-%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr>
<p>1、放置跨页符</p>
<p>Place -&gt; Off-Page Connector</p>
<a id="more"></a>
<hr>
<p>2、更改颜色、字体等偏好</p>
<p>option -&gt; preferences</p>
<hr>
<p>3、生成PDF</p>
<p>file -&gt; Print Setup -&gt; 名称选择 Adobe PDF（或其他软件） -&gt; file -&gt; Print -&gt; OK 后选路径即可</p>
<hr>
<p>4、创建原理图文件夹 —— 选择原理图文件夹 -&gt; 选design -&gt; new schematic </p>
<p>创建原理图文件 —— 选择原理图文件夹 -&gt; 选design -&gt; new schematic page</p>
<hr>
<p>5、重命名</p>
<p>原理图：在页面主菜单 design -&gt; rename，或 dsn 下右键 -&gt; rename</p>
<p>工程文件 opj：只能在 windows 下重命名</p>
<p>设计文件 dsn：不要再 window 下重命名，这样明明后，工程文件就找不到数据库了，应该 file -&gt; save as。</p>
<hr>
<p>6、创建元件库</p>
<ul>
<li><p>file -&gt; new -&gt; library</p>
</li>
<li><p>选中新建的库文件，右键 -&gt; new part，弹出对话框</p>
</li>
<li><p>输入 name 和 rart reference prefix（U、R、C等），封装可以先空着。如果分几部分建立，part per pkg 填相应数量</p>
</li>
<li><p>添加引脚：选中 -&gt; place -&gt; pin array</p>
</li>
<li><p>改引脚名称：双击改名即可，如果需要加横线表示低有效，在每个字母后面加 “\”</p>
</li>
<li><p>统一改引脚名称：edit-properties</p>
</li>
<li><p>option -&gt; package properties可以编辑该 package 的 footprint，名称，索引符号，分裂元件数量</p>
</li>
<li>创建分裂元件<ul>
<li>在 parts per pkg 中选择分裂数量即可，若相似的几部分，选 homogeneous，若不同，选 heterogeneous</li>
<li>电源只放在一个部分即可，不需要每个部分都放，如运放</li>
<li>CTRL+N 切换不同部分</li>
</ul>
</li>
</ul>
<hr>
<p>7、开启/关闭引脚名称显示</p>
<p>option -&gt; part properties</p>
<hr>
<p>8、取消格点吸附</p>
<p>工具栏快捷键 snap to grid 可以取消/开启吸附栅格点。</p>
<hr>
<p>9、画斜线</p>
<p>拉线时按住 shift</p>
<hr>
<p>10、Capture 自带 Library 路径： </p>
<p>cadence–spb_16.3 – tools – capture – library</p>
<hr>
<p>11、总线</p>
<p>总线命名不能以空格或数字结束。</p>
<p>总线命名有3种规则：BUSNAME[0..31]或BUSNAME[0:31]或BUSNAME[0-31]。wire命名时不能带[ ]。直接BUSNAME0、BUSNAME1等。</p>
<p>如果不用总线入口，而把wire线直接连到总线上，在连接处也有连接点，但并没有真正的电气连接。</p>
<p>如果使用总线入口，总线必须通过bus entry和信号线实现互连。并且总线和信号线都要命名，并符合命名规范。</p>
<p>如果不用总线入口，总线和wire信号线之间只能通过网络名称实现电气互连。</p>
<p>两段总线如果形成T型连接，则自动放置连接点，电气上是互连的。两段十字型的总线默认没有连接点，要形成电气互连，必须手动放置连接点。</p>
<hr>
<p>12、器件重新编号</p>
<p>选择工程文件 -&gt; tools -&gt; Annotate -&gt; (Action)Reset to ? -&gt;  确定 -&gt;tools -&gt; Annotate -&gt; incremental reference update</p>
<hr>
<p>13、鼠标变成长十字快捷键  </p>
<p>按 F6</p>
<hr>
<p>14、查看所有器件、网络</p>
<p>schematic 上右键 -&gt; Edit object properties</p>
<hr>
<p>15、字母上加横线</p>
<p>命名时字母后加反斜杠</p>
<hr>
<p>16、建封装时从 excel 批量复制</p>
<p>Shift + Insert</p>
<hr>
<p>17、编辑器件 Pin Group</p>
<p>view -&gt; package -&gt; edit -&gt; properties</p>
<hr>
<p>18、新建 symbol 库</p>
<p>file -&gt; new library -&gt; olb 右键 new symbol，可新建 power、跨页符、标题栏、pin shape、端口标示</p>
<hr>
<p>19、快速新建封装</p>
<p>file -&gt; new library -&gt; olb 右键 new part from spreadsheet</p>
<p>重新修改右键 split part</p>
<hr>
<p>20、插入可编辑的 visio 图形</p>
<ul>
<li><p>Place -&gt; OleObject</p>
</li>
<li><p>选择 由文件创建</p>
</li>
<li><p>点击浏览，选择 visio 文件后点确定</p>
</li>
<li><p>在原理图中画方框（方框后期也可以随意拖动和调整大小）</p>
</li>
</ul>
<hr>
<p>21、元件不能删除和移动</p>
<p>右键该器件，选 edit part，然后退出即可</p>
]]></content>
      <tags>
        <tag>软件使用</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 F(S)MC 总线</title>
    <url>//blog/2019/03/04/STM32-F-S-MC-%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<hr>
<p>CPU 内置灵活的静态存储器控制器（FSMC），可以外扩总线型的存储器（如SRAM、NOR Flash）。FSMC 的英文全称为“Flexible static memory controller”。</p>
<p>所有的外部存储器共享控制器输出的地址、数据和控制信号，每个外部设备可以通过一个唯一的片选信号加以区分。FSMC 在任一时刻只访问一个外部设备。</p>
<a id="more"></a>
<p><img src="https://i.loli.net/2019/03/04/5c7c9846e4e2b.png" alt="Image.png"></p>
<p>注意： 上图中的有些信号是多个信号引到同一个 CPU 管脚。</p>
<p>比如 FSMC_NCE4_1 和 FSMC_NE3同时引到了 PG10 管脚。软件可配置 GPIO 和 FSMC 相关的寄存器进行选择。</p>
<p>从 FSMC 的角度看，可以把外部存储器划分为固定大小为 256M 字节的四个存储块（BLOCK），见下图。</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c988c991ba.png" alt="Image.png"></p>
<ul>
<li>存储块 1 用于访问最多 4 个 NOR 闪存或 SRAM 存储设备。这个存储区被划分为 4 个 BANK 并有 4 个专用的片选 FSMC_NE[4:1]。 CPU 的数据手册将这个区命名为 NOR/PSRAM 区，其中 NOR 指 NOR Flash；PSRAM 指伪 SRAM，即接口封装为 SRAM 形式的动态 RAM（DRAM）。其实，这个区也可以直接用于 SRAM。</li>
<li>存储块 2 和 3 用于访问 NAND 闪存设备，每个存储块连接一个 NAND 闪存。</li>
<li>存储块 4 用于访问 PC 卡设备 每一个存储块上的存储器类型是由用户在配置寄存器中定义的。</li>
</ul>
<p>HADDR 是需要转换到外部存储器的内部 AHB 地址线。HADDR[25:0] 已连接到 CPU 口线，对应 FSMC_A[25:0]。HADDR[27:26] 仅在 CPU 内部使用，没有连接到 CPU 口线。</p>
<p>HADDR[27:26] 位用于选择四个存储块之一：</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c98a311812.png" alt="Image.png"></p>
<p>HADDR 是字节地址，而存储器访问不都是按字节访问，因此接到存储器的地址线依存储器的数据宽度有所不同，如下表：</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c98bab02cd.png" alt="Image.png"></p>
<p>在同一时刻，CPU 只能访问一个外部总线设备（SRAM、NOR Flash、NAND Flash、LCD）。外部总线设备间的协调就靠 CS 片选信号进行的，也就是同一时刻，只有一个外设的片选信号为低。除了片选信号外，其它的地址线、数据线、控制线都是共用的。</p>
<p>当 SRAM 的片选为高电平时，也就是不被选中时，SRAM 的数据线 I/O15~I/O0 呈高阻状态，这样就不会影响其它总线设备的通信。</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 F4 GPIO</title>
    <url>//blog/2019/03/04/STM32-F4-GPIO/</url>
    <content><![CDATA[<hr>
<p>1、在 RESET 期间和刚 RESET 之后，IO 端口配置为浮空输入。除了调试接口会在 RESET 之后配置为相应的上下拉模式。</p>
<p>2、每个 AHB1 时钟周期输入寄存器 GPIOx_IDR 捕获当前引脚数据。</p>
<a id="more"></a>
<p>3、输出开漏模式时，只有 N-MOS 工作，写 0 时输出低，写 1 时位高阻态。</p>
<p>输出模式下，施密特触发器输入是开启的。</p>
<p>输出模式下读取输入寄存器可获得 IO 状态，读取输出寄存器可获得上一次写入的值。</p>
<p>4、RESET 之后，所有 IO 连接至第二功能 0（AF0）。</p>
<p>5、外设第二功能映射为从 AF1 到 AF13。</p>
<p>6、RTC_REFIN 引脚应配成浮空输入。</p>
<p>7、MCO1 和 MCO2 引脚必须配成第二功能模式。</p>
<p>8、ADC 和 DAC 配置成模拟功能。</p>
<p>9、通过映射到 AF15 可将 IO 用来输出 CM4 的 FPU EVENTOUT 信号。</p>
<p>10、EVENTOUT 不能映射到P C13，PC14，PC15，PH0，PH1 和 PI8。</p>
<p>11、每组 IO 口有 4 个控制寄存器</p>
<table>
<thead>
<tr>
<th>GPIOx_MODER</th>
<th>select IO direction（Input，Output，AF，Analog）</th>
</tr>
</thead>
<tbody>
<tr>
<td>GPIOx_OTYPER</td>
<td>select output type（push-pull or open-drain）</td>
</tr>
<tr>
<td>GPIOx_OSPEEDR</td>
<td>select speed</td>
</tr>
<tr>
<td>GPIOx_PUPDR</td>
<td>select pull-up/pull-down whatever the IO direction</td>
</tr>
</tbody>
</table>
<p>12、每组 IO 口有 2 个数据寄存器。</p>
<table>
<thead>
<tr>
<th>GPIOx_IDR</th>
<th>input</th>
</tr>
</thead>
<tbody>
<tr>
<td>GPIOx_ODR</td>
<td>output</td>
</tr>
</tbody>
</table>
<p>13、GPIOx_BSRR 允许对 GPIOx_ODR 寄存器进行位元操作。set 比 reset 的优先级高。位元操作时不需要关闭中断。</p>
<p>14、通过操作 GPIOx_AFRL 和 GPIOx_AFRH 寄存器可以将任一 IO 引脚连接至 16 种第二功能（AF0到AF15）的任意一个。</p>
<p>15、写 GPIOx_LCKR 寄存器需要特定的读写序列，可以锁存 4 个控制寄存器、GPIOx_AFRL 和 GPIOx_AFRH 寄存器。</p>
<p>16、使用 IO 外部中断必须配置成输入 模式。</p>
<p>17、使用模拟功能时，输出 buffer 关闭，施密特触发器关闭，施密特触发器的输出强制为 0，上下拉电阻关闭，读输入寄存器只能读到 0。</p>
<p>18、不使用 LSE 振荡器时，可将 PC14 和 PC15 用作普通 IO。LSE 的优先级比 GPIO 功能高，当 RCC_BDCR 寄存器的 LSEON 位置位时，LSE 振荡器打开 PC14 和 PC15 作为 OSC32_IN 和 OSC32_OFF。</p>
<p>1.2V 域掉电时（器件进入掉电模式），或备份域有 VBAT 供电时，PC14 和 PC15 的 GPIO 功能丧失，这种情况下，处于模拟输入模式。</p>
<p>19、RESET 后，HSE 振荡器默认关闭，此时 PH0/PH1 可以作为普通 IO，而非 OSC_IN 和 OSC_OUT 功能。通过置位 RCC_CR 寄存器的 HSEON 位可开启 HSE 振荡器。HSE 比 GPIO 优先级高。</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 IO操作</title>
    <url>//blog/2019/03/04/STM32-IO%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<h3 id="一、位带操作"><a href="#一、位带操作" class="headerlink" title="一、位带操作"></a>一、位带操作</h3><p>SRAM 和片内外设区的最低 1MB 范围都支持位带操作。每一 bit 都有自己的 32 位“位带别名区”，可以用来访问原始 bit。</p>
<a id="more"></a>
<p>SRAM 中最低 1MB    ：0x2000 0000 - 0x200f ffff</p>
<p>片内外设中最低 1MB：0x4000 0000 - 0x100f ffff</p>
<p>​     </p>
<p>当一个别名地址被访问时，会先把该地址变换成位带地址。位带区的每个比特都映射到别名地址区的一个 LSB 有效的字。</p>
<p>对于读操作，读取位带地址中的一个字，再把需要的位右移到 LSB，并把 LSB 返回。</p>
<p>对于写操作，把需要写的位左移至对应的位序号处，然后执行一个原子的“读-改-写”过程。</p>
<p>对于 SRAM 位带区的某个比特，记它所在字节地址为 A，位序号为 n（0&lt;=n&lt;=7），则该比特在别名区的地址为：</p>
<p>AliasAddr = 0x22000000+((A-0x20000000)<em>8+n)</em>4 = 0x22000000+(A-0x20000000)<em>32+n</em>4</p>
<p><img src="https://i.loli.net/2019/03/04/5c7ccb6221a59.png" alt="Image.png"></p>
<p>对于片上外设位带区的某个比特，记它所在字节的地址为 A，位序号为 n（0&lt;=n&lt;=7），则该比特在别名区的地址为：</p>
<p>AliasAddr = 0x42000000+((A-0x40000000)<em>8+n)</em>4 = 0x42000000+(A-0x40000000)<em>32+n</em>4</p>
<p><img src="https://i.loli.net/2019/03/04/5c7ccb8e16090.png" alt="Image.png"></p>
<p>c 语言代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//位带操作,实现 51 类似的 GPIO 控制功能</span><br><span class="line"></span><br><span class="line">//具体实现思想,参考&lt;&lt;CM3权威指南&gt;&gt;第五章(87页~92页).</span><br><span class="line"></span><br><span class="line">//IO口操作宏定义</span><br><span class="line"></span><br><span class="line">#define BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x2000000+((addr &amp;0xFFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</span><br><span class="line"></span><br><span class="line">#define MEM_ADDR(addr)  *((volatile unsigned long  *)(addr))</span><br><span class="line"></span><br><span class="line">#define BIT_ADDR(addr, bitnum)   MEM_ADDR(BITBAND(addr, bitnum))</span><br><span class="line"></span><br><span class="line">//IO口地址映射</span><br><span class="line"></span><br><span class="line">#define GPIOA_ODR_Addr    (GPIOA_BASE+12) //0x4001080C</span><br><span class="line"></span><br><span class="line">#define GPIOB_ODR_Addr    (GPIOB_BASE+12) //0x40010C0C</span><br><span class="line"></span><br><span class="line">#define GPIOC_ODR_Addr    (GPIOC_BASE+12) //0x4001100C</span><br><span class="line"></span><br><span class="line">#define GPIOD_ODR_Addr    (GPIOD_BASE+12) //0x4001140C</span><br><span class="line"></span><br><span class="line">#define GPIOE_ODR_Addr    (GPIOE_BASE+12) //0x4001180C</span><br><span class="line"></span><br><span class="line">#define GPIOF_ODR_Addr    (GPIOF_BASE+12) //0x40011A0C   </span><br><span class="line"></span><br><span class="line">#define GPIOG_ODR_Addr    (GPIOG_BASE+12) //0x40011E0C   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define GPIOA_IDR_Addr    (GPIOA_BASE+8) //0x40010808</span><br><span class="line"></span><br><span class="line">#define GPIOB_IDR_Addr    (GPIOB_BASE+8) //0x40010C08</span><br><span class="line"></span><br><span class="line">#define GPIOC_IDR_Addr    (GPIOC_BASE+8) //0x40011008</span><br><span class="line"></span><br><span class="line">#define GPIOD_IDR_Addr    (GPIOD_BASE+8) //0x40011408</span><br><span class="line"></span><br><span class="line">#define GPIOE_IDR_Addr    (GPIOE_BASE+8) //0x40011808</span><br><span class="line"></span><br><span class="line">#define GPIOF_IDR_Addr    (GPIOF_BASE+8) //0x40011A08</span><br><span class="line"></span><br><span class="line">#define GPIOG_IDR_Addr    (GPIOG_BASE+8) //0x40011E08</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//IO 口操作，只对单一的 IO 口</span><br><span class="line"></span><br><span class="line">//确保 n 的值小于16</span><br><span class="line"></span><br><span class="line">#define PAout(n)   BIT_ADDR(GPIOA_ODR_Addr,n)  //输出</span><br><span class="line"></span><br><span class="line">#define PAin(n)    BIT_ADDR(GPIOA_IDR_Addr,n)  //输入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define PBout(n)   BIT_ADDR(GPIOB_ODR_Addr,n)  //输出</span><br><span class="line"></span><br><span class="line">#define PBin(n)    BIT_ADDR(GPIOB_IDR_Addr,n)  //输入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define PCout(n)   BIT_ADDR(GPIOC_ODR_Addr,n)  //输出</span><br><span class="line"></span><br><span class="line">#define PCin(n)    BIT_ADDR(GPIOC_IDR_Addr,n)  //输入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define PDout(n)   BIT_ADDR(GPIOD_ODR_Addr,n)  //输出</span><br><span class="line"></span><br><span class="line">#define PDin(n)    BIT_ADDR(GPIOD_IDR_Addr,n)  //输入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define PEout(n)   BIT_ADDR(GPIOE_ODR_Addr,n)  //输出</span><br><span class="line"></span><br><span class="line">#define PEin(n)    BIT_ADDR(GPIOE_IDR_Addr,n)  //输入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define PFout(n)   BIT_ADDR(GPIOF_ODR_Addr,n)  //输出</span><br><span class="line"></span><br><span class="line">#define PFin(n)    BIT_ADDR(GPIOF_IDR_Addr,n)  //输入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define PGout(n)   BIT_ADDR(GPIOG_ODR_Addr,n)  //输出</span><br><span class="line"></span><br><span class="line">#define PGin(n)    BIT_ADDR(GPIOG_IDR_Addr,n)  //输入</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二、IO-口模式"><a href="#二、IO-口模式" class="headerlink" title="二、IO 口模式"></a>二、IO 口模式</h3><p>1、输入浮空</p>
<p>2、输入上拉</p>
<p>3、输入下拉</p>
<p>4、模拟输入</p>
<p>5、开漏输出</p>
<p>6、推挽输出</p>
<p>7、推挽式复用功能</p>
<p>8、开漏复用功能</p>
<p>每个 IO 口有 7 个寄存器：</p>
<ul>
<li><p>配置模式的 2 个 32 位端口配置寄存器 CRL 和 CRH</p>
</li>
<li><p>2 个 32 位数据寄存器 IDR 和 ODR</p>
</li>
<li><p>1 个 32 位的置位/复位寄存器 BSRR</p>
</li>
<li><p>1 个 16 位的复位寄存器 BRR</p>
</li>
<li><p>1 个 32 位的锁存寄存器 LCKR</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/03/04/5c7ccc73aea1c.png" alt="Image.png"></p>
<p><strong>CRL 和 CRH</strong></p>
<p>每个 IO 口占 4 位，高 2 位为 CNF，低 2 位为 MODE。</p>
<p>0x0 表示模拟输入（ADC 用）</p>
<p>0x4 表示浮空输入</p>
<p>0x8 表示上下拉模式（输入口）PxODR=0下拉；=1上拉</p>
<p>0x3 表示推挽输出（输出口，50M速率）（0x2-2M、0x1-10M）</p>
<p>0x7 表示开漏输出（0x6-2M 、0x5-10M ）</p>
<p>0xb 表示复用推挽输出（IO口第二功能，50M速率 ）（0xa-2M 、0x9-10M ）</p>
<p>0xf 表示复用开漏输出（IO口第二功能，50M速率 ）（0xe-2M 、0xd-10M ）</p>
<p><strong>IDR 和 ODR</strong></p>
<p>​     </p>
<p>只用了低 16 位。IDR 为只读，ODR 为读写。</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 中断</title>
    <url>//blog/2019/03/04/STM32-%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<hr>
<h3 id="一、CM3-内核"><a href="#一、CM3-内核" class="headerlink" title="一、CM3 内核"></a>一、CM3 内核</h3><p>​     </p>
<p>CM3 内核支持 256 个中断，其中前 16 个为内核中断，另外 240 个为外部中断，具有 256 级的可编程中断设置。</p>
<a id="more"></a>
<h3 id="二、stm32f1"><a href="#二、stm32f1" class="headerlink" title="二、stm32f1"></a>二、stm32f1</h3><p>stm32 有 84 个中断，包括 16 个内核中断和 68 个可屏蔽中断，具有 16 级可编程的中断优先级。f103 上只有 60 个中断，互联型如 f107 才有 68 个。</p>
<p>stm32f103 支持 19 个外部中断：</p>
<ul>
<li>线 0~15：对应外部 IO 的输入中断</li>
<li>线 16：连接到 PVD 输出</li>
<li>线 17：连接到 RTC 闹钟事件</li>
<li>线 18：连接到 USB 唤醒事件</li>
</ul>
<h3 id="三、相关寄存器"><a href="#三、相关寄存器" class="headerlink" title="三、相关寄存器"></a>三、相关寄存器</h3><p>向量中断控制器，简称 NVIC。访问地址 0xe000e000。</p>
<ul>
<li>ISER（8 个，用 3 个）Interrupt Set-Enable Registers<ul>
<li>中断使能。写 0 无效。</li>
</ul>
</li>
</ul>
<p>​     </p>
<ul>
<li>ICER（8 个，用 3 个）Interrupt Clear-Enable Registers<ul>
<li>清除使能。写 0 无效。</li>
</ul>
</li>
</ul>
<ul>
<li>ISPR（8 个，用 3 个）Interrupt Set-Pending Registers<ul>
<li>中断挂起，执行更高级中断。写 0 无效。</li>
</ul>
</li>
</ul>
<ul>
<li>ICPR（8个，用 3 个）Interrupt Clear-Pending Registers<ul>
<li>挂起解除。写 0 无效。</li>
</ul>
</li>
</ul>
<ul>
<li>IABR（8 个，用 3 个）Interrupt Active Bit Register<ul>
<li>中断活动标志，指示正在被执行的中断，硬件清零，只读。在处理器执行了某一种中断的 ISR 的第一条指令后，它的活动位就置 1，直到 ISR 返回时才硬件清零。即使该中断被抢占，其活动状态依然为 1。</li>
</ul>
</li>
</ul>
<ul>
<li>IP（240 个，用 68 个，高 4 位有效）Interrupt Priority Register</li>
</ul>
<ul>
<li>STIR<ul>
<li>具体信息见 PM0056 STM32 内核编程手册</li>
</ul>
</li>
</ul>
<ul>
<li>SCB-&gt;AIRCR 设置分组<ul>
<li>共 5 组，0 表示 0 位抢占优先级，4 表示 4 位抢占优先级</li>
</ul>
</li>
</ul>
<ul>
<li>软件中断<ul>
<li>最简单的方法是用 SETPEND 寄存器。更专业快捷的方法是用 STIR 寄存器</li>
</ul>
</li>
</ul>
<h3 id="四、外部中断"><a href="#四、外部中断" class="headerlink" title="四、外部中断"></a>四、外部中断</h3><p>IMR（中断屏蔽寄存器）</p>
<p>EMR（事件屏蔽寄存器）</p>
<p>RTSR（上升沿触发选择寄存器）</p>
<p>FTSR（下降沿触发选择寄存器 ）</p>
<p>SWIER（软件中断时间寄存器）</p>
<p>PR（挂起寄存器）</p>
<p>​     写1清除该位</p>
<h3 id="五、中断编号（f103）"><a href="#五、中断编号（f103）" class="headerlink" title="五、中断编号（f103）"></a>五、中断编号（f103）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/</span><br><span class="line"></span><br><span class="line">  NonMaskableInt_IRQn         = -14,    /*!&lt; 2 Non Maskable Interrupt                             */</span><br><span class="line"></span><br><span class="line">  MemoryManagement_IRQn       = -12,    /*!&lt; 4 Cortex-M3 Memory Management Interrupt              */</span><br><span class="line"></span><br><span class="line">  BusFault_IRQn               = -11,    /*!&lt; 5 Cortex-M3 Bus Fault Interrupt                      */</span><br><span class="line"></span><br><span class="line">  UsageFault_IRQn             = -10,    /*!&lt; 6 Cortex-M3 Usage Fault Interrupt                    */</span><br><span class="line"></span><br><span class="line">  SVCall_IRQn                 = -5,     /*!&lt; 11 Cortex-M3 SV Call Interrupt                       */</span><br><span class="line"></span><br><span class="line">  DebugMonitor_IRQn           = -4,     /*!&lt; 12 Cortex-M3 Debug Monitor Interrupt                 */</span><br><span class="line"></span><br><span class="line">  PendSV_IRQn                 = -2,     /*!&lt; 14 Cortex-M3 Pend SV Interrupt                       */</span><br><span class="line"></span><br><span class="line">  SysTick_IRQn                = -1,     /*!&lt; 15 Cortex-M3 System Tick Interrupt                   */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/******  STM32 specific Interrupt Numbers *********************************************************/</span><br><span class="line"></span><br><span class="line">  WWDG_IRQn                   = 0,      /*!&lt; Window WatchDog Interrupt                            */</span><br><span class="line"></span><br><span class="line">  PVD_IRQn                    = 1,      /*!&lt; PVD through EXTI Line detection Interrupt            */</span><br><span class="line"></span><br><span class="line">  TAMPER_IRQn                 = 2,      /*!&lt; Tamper Interrupt                                     */</span><br><span class="line"></span><br><span class="line">  RTC_IRQn                    = 3,      /*!&lt; RTC global Interrupt                                 */</span><br><span class="line"></span><br><span class="line">  FLASH_IRQn                  = 4,      /*!&lt; FLASH global Interrupt                               */</span><br><span class="line"></span><br><span class="line">  RCC_IRQn                    = 5,      /*!&lt; RCC global Interrupt                                 */</span><br><span class="line"></span><br><span class="line">  EXTI0_IRQn                  = 6,      /*!&lt; EXTI Line0 Interrupt                                 */</span><br><span class="line"></span><br><span class="line">  EXTI1_IRQn                  = 7,      /*!&lt; EXTI Line1 Interrupt                                 */</span><br><span class="line"></span><br><span class="line">  EXTI2_IRQn                  = 8,      /*!&lt; EXTI Line2 Interrupt                                 */</span><br><span class="line"></span><br><span class="line">  EXTI3_IRQn                  = 9,      /*!&lt; EXTI Line3 Interrupt                                 */</span><br><span class="line"></span><br><span class="line">  EXTI4_IRQn                  = 10,     /*!&lt; EXTI Line4 Interrupt                                 */</span><br><span class="line"></span><br><span class="line">  DMA1_Channel1_IRQn          = 11,     /*!&lt; DMA1 Channel 1 global Interrupt                      */</span><br><span class="line"></span><br><span class="line">  DMA1_Channel2_IRQn          = 12,     /*!&lt; DMA1 Channel 2 global Interrupt                      */</span><br><span class="line"></span><br><span class="line">  DMA1_Channel3_IRQn          = 13,     /*!&lt; DMA1 Channel 3 global Interrupt                      */</span><br><span class="line"></span><br><span class="line">  DMA1_Channel4_IRQn          = 14,     /*!&lt; DMA1 Channel 4 global Interrupt                      */</span><br><span class="line"></span><br><span class="line">  DMA1_Channel5_IRQn          = 15,     /*!&lt; DMA1 Channel 5 global Interrupt                      */</span><br><span class="line"></span><br><span class="line">  DMA1_Channel6_IRQn          = 16,     /*!&lt; DMA1 Channel 6 global Interrupt                      */</span><br><span class="line"></span><br><span class="line">  DMA1_Channel7_IRQn          = 17,     /*!&lt; DMA1 Channel 7 global Interrupt   </span><br><span class="line"></span><br><span class="line"> ADC1_2_IRQn                 = 18,     /*!&lt; ADC1 and ADC2 global Interrupt                       */</span><br><span class="line"></span><br><span class="line">  USB_HP_CAN1_TX_IRQn         = 19,     /*!&lt; USB Device High Priority or CAN1 TX Interrupts       */</span><br><span class="line"></span><br><span class="line">  USB_LP_CAN1_RX0_IRQn        = 20,     /*!&lt; USB Device Low Priority or CAN1 RX0 Interrupts       */</span><br><span class="line"></span><br><span class="line">  CAN1_RX1_IRQn               = 21,     /*!&lt; CAN1 RX1 Interrupt                                   */</span><br><span class="line"></span><br><span class="line">  CAN1_SCE_IRQn               = 22,     /*!&lt; CAN1 SCE Interrupt                                   */</span><br><span class="line"></span><br><span class="line">  EXTI9_5_IRQn                = 23,     /*!&lt; External Line[9:5] Interrupts                        */</span><br><span class="line"></span><br><span class="line">  TIM1_BRK_IRQn               = 24,     /*!&lt; TIM1 Break Interrupt                                 */</span><br><span class="line"></span><br><span class="line">  TIM1_UP_IRQn                = 25,     /*!&lt; TIM1 Update Interrupt                                */</span><br><span class="line"></span><br><span class="line">  TIM1_TRG_COM_IRQn           = 26,     /*!&lt; TIM1 Trigger and Commutation Interrupt               */</span><br><span class="line"></span><br><span class="line">  TIM1_CC_IRQn                = 27,     /*!&lt; TIM1 Capture Compare Interrupt                       */</span><br><span class="line"></span><br><span class="line">  TIM2_IRQn                   = 28,     /*!&lt; TIM2 global Interrupt                                */</span><br><span class="line"></span><br><span class="line">  TIM3_IRQn                   = 29,     /*!&lt; TIM3 global Interrupt                                */</span><br><span class="line"></span><br><span class="line">  TIM4_IRQn                   = 30,     /*!&lt; TIM4 global Interrupt                                */</span><br><span class="line"></span><br><span class="line">  I2C1_EV_IRQn                = 31,     /*!&lt; I2C1 Event Interrupt                                 */</span><br><span class="line"></span><br><span class="line">  I2C1_ER_IRQn                = 32,     /*!&lt; I2C1 Error Interrupt                                 */</span><br><span class="line"></span><br><span class="line">  I2C2_EV_IRQn                = 33,     /*!&lt; I2C2 Event Interrupt                                 */</span><br><span class="line"></span><br><span class="line">  I2C2_ER_IRQn                = 34,     /*!&lt; I2C2 Error Interrupt                                 */</span><br><span class="line"></span><br><span class="line">  SPI1_IRQn                   = 35,     /*!&lt; SPI1 global Interrupt                                */</span><br><span class="line"></span><br><span class="line">  SPI2_IRQn                   = 36,     /*!&lt; SPI2 global Interrupt                                */</span><br><span class="line"></span><br><span class="line">  USART1_IRQn                 = 37,     /*!&lt; USART1 global Interrupt                              */</span><br><span class="line"></span><br><span class="line">  USART2_IRQn                 = 38,     /*!&lt; USART2 global Interrupt                              */</span><br><span class="line"></span><br><span class="line">  USART3_IRQn                 = 39,     /*!&lt; USART3 global Interrupt                              */</span><br><span class="line"></span><br><span class="line">  EXTI15_10_IRQn              = 40,     /*!&lt; External Line[15:10] Interrupts                      */</span><br><span class="line"></span><br><span class="line">  RTCAlarm_IRQn               = 41,     /*!&lt; RTC Alarm through EXTI Line Interrupt                */</span><br><span class="line"></span><br><span class="line">  USBWakeUp_IRQn              = 42,     /*!&lt; USB Device WakeUp from suspend through EXTI Line Interrupt */</span><br><span class="line"></span><br><span class="line">  TIM8_BRK_IRQn               = 43,     /*!&lt; TIM8 Break Interrupt                                 */</span><br><span class="line"></span><br><span class="line">  TIM8_UP_IRQn                = 44,     /*!&lt; TIM8 Update Interrupt                                */</span><br><span class="line"></span><br><span class="line">  TIM8_TRG_COM_IRQn           = 45,     /*!&lt; TIM8 Trigger and Commutation Interrupt               */</span><br><span class="line"></span><br><span class="line">  TIM8_CC_IRQn                = 46,     /*!&lt; TIM8 Capture Compare Interrupt                       */</span><br><span class="line"></span><br><span class="line">  ADC3_IRQn                   = 47,     /*!&lt; ADC3 global Interrupt                                */</span><br><span class="line"></span><br><span class="line">  FSMC_IRQn                   = 48,     /*!&lt; FSMC global Interrupt                                */</span><br><span class="line"></span><br><span class="line">  SDIO_IRQn                   = 49,     /*!&lt; SDIO global Interrupt                                */</span><br><span class="line"></span><br><span class="line">  TIM5_IRQn                   = 50,     /*!&lt; TIM5 global Interrupt                                */</span><br><span class="line"></span><br><span class="line">  SPI3_IRQn                   = 51,     /*!&lt; SPI3 global Interrupt                                */</span><br><span class="line"></span><br><span class="line">  UART4_IRQn                  = 52,     /*!&lt; UART4 global Interrupt                               */</span><br><span class="line"></span><br><span class="line">  UART5_IRQn                  = 53,     /*!&lt; UART5 global Interrupt                               */</span><br><span class="line"></span><br><span class="line">  TIM6_IRQn                   = 54,     /*!&lt; TIM6 global Interrupt                                */</span><br><span class="line"></span><br><span class="line">  TIM7_IRQn                   = 55,     /*!&lt; TIM7 global Interrupt                                */</span><br><span class="line"></span><br><span class="line">  DMA2_Channel1_IRQn          = 56,     /*!&lt; DMA2 Channel 1 global Interrupt                      */</span><br><span class="line"></span><br><span class="line">  DMA2_Channel2_IRQn          = 57,     /*!&lt; DMA2 Channel 2 global Interrupt                      */</span><br><span class="line"></span><br><span class="line">  DMA2_Channel3_IRQn          = 58,     /*!&lt; DMA2 Channel 3 global Interrupt                      */</span><br><span class="line"></span><br><span class="line">  DMA2_Channel4_5_IRQn        = 59      /*!&lt; DMA2 Channel 4 and Channel 5 global Interrupt </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 外部中断</title>
    <url>//blog/2019/03/04/STM32-%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<hr>
<p>STM32 的每个 IO 口都可以作为中断输入，但每一个中断线只能分配到某一个 IO 口的相应管脚，如中断 2 只能分配到 PA2 或 PB2 或 PC2 等其中的一个。</p>
<a id="more"></a>
<p>把 IO 口作为外部中断输入的步骤：</p>
<p>1、初始化 IO 为输入</p>
<p>可以上拉，下拉，或浮空输入。浮空的时候外部一定要上拉或下拉，否则中断可能不停触发。干扰打的地方，就算使用了内部上/下拉，最好外部再上/下拉一下，一定程度上防止外部干扰。</p>
<p>2、开启 IO 口复用时钟，设置 IO 口与中断线的映射关系</p>
<p>IO 口复用时钟在 RCC-&gt;APB2ENR 处使能（AFIOEN），在 AFIO-&gt;EXTICR 处将 EXTI.BITx 映射到 GPIO.BITx。</p>
<p>3、开启与该 IO 口相对的线上中断/事件，设置触发条件</p>
<p>从 EXTI-&gt;IMR 处开启中断请求，从 EXTI-&gt;EMR 处开启事件请求，从 EXTI-&gt;FTSR（下降沿）和 RTSR（上升沿）设置触发条件。</p>
<p>触发条件只能是上升沿或下降沿。不配置 EMR 位，软硬件仿真都可以进入外部中断，配置以后，软件仿真不能进入外部中断。</p>
<p>4、配置中断分组（NVIC），并使能中断</p>
<p>从 SCB-&gt;AIRCR[10:8] 配置中断分组，从 NVIC-&gt;ISER 使能外部中断，从 NVIC-&gt;IP 设置优先级。见 PM0056。</p>
<p>5、编写中断服务函数</p>
<p>0~4 有各自的 ISR：void EXTI0_IRQHandler(void)</p>
<p>9~5 共用 ISR：void EXTI9_5_IRQHandler(void)</p>
<p>15~10 共用 ISR：void EXTI15_10_IRQHandler(void)</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 时钟树总结</title>
    <url>//blog/2019/03/04/STM32-%E6%97%B6%E9%92%9F%E6%A0%91%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr>
<h3 id="一、时钟源"><a href="#一、时钟源" class="headerlink" title="一、时钟源"></a>一、时钟源</h3><h4 id="1、物理时钟源"><a href="#1、物理时钟源" class="headerlink" title="1、物理时钟源"></a>1、物理时钟源</h4><p>看到好多地方都说 STM32F1 有五个时钟源 HSE、HSI、LSI、LSE 和 PLL，但是我觉得 PLL 严格来讲不算一个时钟源，它是在基本的物理时钟上倍频得到的，因此我把 HSE、HSI、LSI、LSE 归结为 STM32F1 的四个基本物理时钟源。</p>
<a id="more"></a>
<p><img src="https://i.loli.net/2019/03/04/5c7c85c0784c9.png" alt="Image.png"></p>
<p>STM32F1xx 有 4 个物理时钟源：</p>
<ul>
<li><p>HSE（High Speed External clock signal）4-16MHz</p>
</li>
<li><p>HSI（High Speed Internal clock signal） 8MHz</p>
</li>
<li><p>LSI（Low Speed Internal clock signal） 40kHz            驱动独立看门狗 IWDG 和 AWU</p>
</li>
<li><p>LSE（Low Speed External clock signal）32.768kHz     驱动RTC</p>
</li>
</ul>
<p>其中 HSE 和 HSI 可经 PLL 倍频得到 PLL 高频时钟源（最大 72M）。</p>
<h5 id="（1）高速外部时钟信号（HSE）"><a href="#（1）高速外部时钟信号（HSE）" class="headerlink" title="（1）高速外部时钟信号（HSE）"></a>（1）高速外部时钟信号（HSE）</h5><p>​     由以下两种时钟源产生：</p>
<p>·    HSE 外部晶体/陶瓷谐振器</p>
<p>·    HSE 用户外部时钟</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c842945450.png" alt="Image.png"></p>
<p><strong>外部时钟源（HSE旁路）</strong></p>
<p>在这个模式里，必须提供外部时钟。它的频率最高可达 25MHz。用户可通过设置在控制寄存器中的 HSEBYP 和 HSEON 位来选择这一模式。外部时钟信号（50% 占空比的方波、正弦波或三角波）必须连到 OSC_IN 引脚，同时保证 OSC_OUT 引脚悬空，如上图。</p>
<p><strong>外部晶体/陶瓷谐振器（HSE晶体）</strong></p>
<p>4~16MHz 外部振荡器可为系统提供更为精确的主时钟。相关的硬件配置参考上图（关于晶体/陶瓷谐振器的原理，或者遇到晶振不起振的问题，可以参考下皮尔斯振荡器）。为了减少时钟输出的失真和缩短启动稳定时间，晶体/陶瓷谐振器和负载电容器必须尽可能地靠近振荡器引脚。负载电容值必须根据所选择的振荡器来选择。时钟控制寄存器 RCC_CR 中的 HSERDY 位用来指示高速外部振荡器是否稳定。在启动时，知道这一位被硬件置“1”,时钟才被释放。如果在时钟中断寄存器 RCCC_CIR 中允许产生中断，将会产生相应中断。HSE 晶体可以通过设置时钟控制寄存器里 RCC_CR 中的 HSEON 位被启动和关闭。</p>
<h5 id="（2）高速内部时钟信号（HSI）"><a href="#（2）高速内部时钟信号（HSI）" class="headerlink" title="（2）高速内部时钟信号（HSI）"></a>（2）高速内部时钟信号（HSI）</h5><p>HSI 时钟信号由内部 8MHz 的 RC 振荡器产生，可直接作为系统时钟或在 2 分频后作为 PLL 输入（此时最大 64M）。HSI RC 振荡器能在不需要任何外部器件的条件下提供系统时钟。它的启动时间比 HSE 晶体振荡器短。然而，即使在校准之后它的时钟频率精度仍较差。</p>
<p>​     </p>
<p><strong>HSI 校准：</strong></p>
<p>制造工艺决定了不同芯片的 RC 振荡器频率会不同，这就是为什么每个芯片的 HSI 时钟频率在出厂前已经被 ST 校准到 1%（25℃）的原因。系统复位时，工厂校准值被装在到时钟控制器的 HSICAL[7:0] 位。如果用户的应用基于不同的电压或环境温度，这将会影响 RC 振荡器的精度。可以通过时钟控制寄存器里的 HSITRIM[4:0] 位来调整 HSI 频率。</p>
<p>时钟控制寄存器中的 HSIRDY 位用来指示 HSI RC 振荡器是否稳定。在时钟启动过程中，知道这一位被硬件置“1”,HSI RC 输出时钟才被释放。HSI RC 可由时钟控制寄存器中的 HSION 位来启动和关闭。</p>
<p>如果 HSE 晶体振荡器失效，HSI 时钟会被作为备用时钟源。</p>
<p>​     </p>
<h5 id="（3）低速外部时钟信号（LSE）"><a href="#（3）低速外部时钟信号（LSE）" class="headerlink" title="（3）低速外部时钟信号（LSE）"></a>（3）低速外部时钟信号（LSE）</h5><p>LSE 晶体是一个 32.768kHz 的低速外部晶体或陶瓷谐振器。它为实时时钟或其他定时功能提供一个低功耗且精确的时钟源。</p>
<p>LSE 晶体通过在备份域控制寄存器（RCC_BDCR）里的 LSEON 位启动和关闭。</p>
<p>在备份域控制寄存器（RCC_BDCR ）里的 LSERDY 指示 LSE 晶体振荡是否稳定。在启动阶段，知道这个位被硬件置 1 后，LSE 时钟信号才被释放出来。如果在时钟中断寄存器里被允许，可产生中断申请。</p>
<p><strong>外部时钟源（LSE旁路）</strong></p>
<p>在这个模式里必须提供一个 32.768kHz 频率的外部时钟源。可以通过设置在备份域控制寄存器（RCC_BDCR）里的 LSEBYP 和 LSEON 位来选择这个模式。具有 50% 占空比的外部时钟信号（方波、正弦波或三角波）必须连到 OSC32_IN 引脚，同时保证 OSC32_OUT 引脚悬空。</p>
<p>​     </p>
<h5 id="（4）低速内部时钟信号（LSI）"><a href="#（4）低速内部时钟信号（LSI）" class="headerlink" title="（4）低速内部时钟信号（LSI）"></a>（4）低速内部时钟信号（LSI）</h5><p>LSI RC 担当一个低功耗时钟源的角色，它可以在停机和待机模式下保持运行，为独立看门狗和自动唤醒单元提供时钟。LSI 时钟频率大约 40kHz（在 30kHz 到 60kHz 之间）。</p>
<p>LSI RC 可以通过控制/状态寄存器（RCC_CSR）里的 LSION 位来启动或关闭。</p>
<p>在控制/状态寄存器（RCC/CSR）里的 LSIRDY 位指示低速内部振荡器是否稳定。在启动阶段，知道这个位被硬件置 1 后，此时钟才被释放。如果在时钟中断寄存器（RCC_CIR）里被允许，将产生 LSI 中断申请。</p>
<p><strong>LSI 校准：（只有大容量和互联型产品可以进行 LSI 校准）</strong></p>
<p>可以通过校准内部低速振荡器 LSI 来补偿其频率便宜，从而获得精度可接受的 RTC 时间基数，以及独立看门狗 IWDG 的超时时间（当这些外设以 LSI 为时钟源）。</p>
<p>校准可以通过使用 TIM5 的输入时钟（TIM5_CLK）测量 LSI 时钟频率实现。测量以 HSE 的精度为保证，软件可以通过调整 RTC 的 20 位预分频器来获得精确的 RTC 时钟基数，以及通过计算得到精确的独立看门狗 IWDG 的超时时间。</p>
<p>LSI 校准步骤如下：</p>
<ul>
<li><p>打开 TIM5，设置通道 4 为输入捕获模式；</p>
</li>
<li><p>设置 AIFO_MAPR 的 TIM5_CH4_IREMAP 位为 1，在内部把 LSI 连接到 TIM5 的通道 4；</p>
</li>
<li><p>通过 TIM5 的捕获/比较 4 事件或者中断来测量 LSI 时钟频率；</p>
</li>
<li><p>根据测量结果和期望的 RTC 时间基数和独立看门狗的超时时间，设置 20 位预分频器。</p>
</li>
</ul>
<h5 id="（5）PLL"><a href="#（5）PLL" class="headerlink" title="（5）PLL"></a>（5）PLL</h5><p>内部 PLL 可以用来倍频 HSI RC 的输出时钟或 HSE 晶体输出时钟。PLL 的设置（选择 HSI 振荡器除以2或者 HSE 振荡器为 PLL 输入时钟，和选择倍频因子）必须在其被激活前完成。一旦 PLL 被激活，这些参数就不能被改动。</p>
<p>如果 PLL 中断在时钟中断寄存器里被允许，当 PLL 准备就绪时，可产生中断申请。</p>
<p>如果需要在应用中使用 USB 接口，PLL 必须被设置为输出 48 或 72MHz 时钟，用于提供 48MHz 的 USBCLK 时钟。</p>
<h4 id="2、系统时钟-SYSCLK"><a href="#2、系统时钟-SYSCLK" class="headerlink" title="2、系统时钟 SYSCLK"></a>2、系统时钟 SYSCLK</h4><p>STM32 的系统时钟 SYSCLK 由 SW 控制，从 HSI、PLLCLK 和 HSE 中三选一，通常选 PLLCLK。系统刚上电 的时候，使用系统内部 8MRC 时钟。SYSCLK 最大 72MHz，也可超频至 128MHz，但不建议。若使用 HSI 经 PLL 作为 SYSCLK，最大 64MHz，因为先 2 分频，PLL 最大只能 16 倍频。</p>
<p>系统复位后，HSI 振荡器被选为系统时钟。当时钟源被直接或通过 PLL 间接作为系统时钟时，它将不能被停止。</p>
<p>只有当目标时钟源准备就绪了，从一个时钟源到另一个时钟源的切换才会发生。在被选择时钟源没有就绪时，系统时钟的切换不会发生。直至目标时钟源就绪，才发生切换。</p>
<p>在时钟控制寄存器（RCC_CE）里的状态位指示哪个时钟已经准备好了，哪个时钟目前被用作系统时钟。</p>
<h3 id="二、时钟分配"><a href="#二、时钟分配" class="headerlink" title="二、时钟分配"></a>二、时钟分配</h3><h4 id="1、SYSCLK"><a href="#1、SYSCLK" class="headerlink" title="1、SYSCLK"></a>1、SYSCLK</h4><p>系统时钟 SYSCLK，它是供 STM32 中绝大部分部件工作的时钟源。系统时钟可选择为 PLL 输出、HSI 或者 HSE。系统时钟最大频率为 72MHz，它通过 AHB 分频器分频后送给各模块使用，AHB 分频器可选择 1、2、4、8、16、64、128、256、512 分频。其中 AHB 分频器输出的时钟送给 5 大模块使用：</p>
<ul>
<li><p>送给 AHB 总线、内核、内存和 DMA 使用的 HCLK 时钟。</p>
</li>
<li><p>通过 8 分频后送给 Cortex 的系统定时器时钟 SYSTICK。</p>
</li>
<li><p>直接送给 Cortex 的空闲运行时钟 FCLK。</p>
</li>
<li><p>送给 APB1 分频器。APB1 分频器可选择 1、2、4、8、16 分频，其输出一路供 APB1 外设使用(PCLK1，最大频率 36MHz)，另一路送给定时器 (Timer)2、3、4 倍频器使用。该倍频器可选择1 或者 2 倍频，时钟输出供定时器 2、3、4 使用。</p>
</li>
<li><p>送给 APB2 分频器。APB2 分频器可选择 1、2、4、8、16 分频，其输出一路供 APB2 外设使用(PCLK2，最大频率 72MHz)，另一路送给定时器 (Timer)1 倍频器使用。该倍频器可选择 1 或者 2 倍频，时钟输出供定时器 1 使用。另外，APB2 分频器还有一路输出供 ADC 分频器使用，分频后送给 ADC 模块使用。ADC 分频器可选择为 2、4、6、8 分频。</p>
</li>
</ul>
<p>在以上的时钟输出中，有很多是带使能控制的，例如 AHB 总线时钟、内核时钟、各种 APB1 外设、 APB2 外设等等。当需要使用某模块时，记得一定要先使能对应的时钟。</p>
<h4 id="2、具体时钟分配"><a href="#2、具体时钟分配" class="headerlink" title="2、具体时钟分配"></a>2、具体时钟分配</h4><p>CM3 的系统滴答时钟 SYSTICK，来源是 AHB 分频后再 8 分频，通常设置 AHB 不分频，所以 SYSTICK 的频率就是 SYSCLK/8。</p>
<p>APB1（低速APB）总线上的外设时钟 PCLK1，最大为 36MHz，所有挂载在 APB1 上的外设，最大时钟都是 36MHz，定时器除外。PCLK1 的时钟由 APB1 预分频器设置，默认 2 分频（72MHz/2）。挂在这一总线的外设有： 电源接口、备份接口、CAN、USB、I2C1、I2C2、UART2~5、SPI2、SPI3、窗口看门狗(WWDG)、Timer2~7。注意 USB 模块虽然需要一个单独的 48MHz 时钟信号，但它应该不是供 USB 模块工作的时钟，而只是提供给串行接口引擎(SIE)使用的时钟。</p>
<p>APB2（高速 APB）总线上的外设时钟 PCLK2，最大为 72MHz，所有挂载在 APB2 上的外设，最大时钟都是 72MHz。PCLK2 的时钟由 APB2 预分频器设置，默认不分频。挂在这一总线的外设有：UART1、GPIOA~G、SPI1、ADC1~3、高级定时器（1、8）第二功能 IO 口。</p>
<p>SDIO 接口的时钟频率固定为 HCLK/2。</p>
<p>ADC 时钟由高速 APB2 时钟经 2、4、6 或 8 分频获得。</p>
<p>如果相应的 APB 预分频系数是 1，定时器时钟频率与所在 APB 总线频率一致，否则为与其相连的 APB 总线频率的 2 倍</p>
<p>​     </p>
<p>FCLK 是 CM3 的自由运行时钟。</p>
<p>STM32 中有一个全速功能的 USB 模块，其串行接口引擎需要一个频率为 48MHz 的时钟源。该时钟源只能从 PLL 输出端获取，可以选择为 1.5 分频或者 1 分频，也就是，当需要使用 USB 模块时，PLL 必须使能，并且时钟频率配置为 48MHz 或 72MHz。</p>
<h4 id="3、时钟安全系统（CSS）"><a href="#3、时钟安全系统（CSS）" class="headerlink" title="3、时钟安全系统（CSS）"></a>3、时钟安全系统（CSS）</h4><p>时钟安全系统可以通过软件激活。一旦其被激活，时钟监测器将在 HSE 振荡器启动延迟后被使能，并在 HSE 时钟关闭后关闭。</p>
<p>如果 HSE 时钟发生故障，HSE 振荡器被自动关闭，时钟失效事件将被送到高级定时器（TIM1 和 TIM8）的刹车输入端，并产生时钟安全中断 CSSI，允许软件完成营救操作。此 CSSI 中断连接到 Cortex-M3 的 NMI 中断。</p>
<p>一旦 CSS 被激活，并且 HSE 时钟出现故障，CSS 中断就产生，并且 NMI 也自动产生。NMI 将被不断执行，知道 CSS 中断挂起位被清除。因此，在NMI的处理程序中必须通过设置时钟中断寄存器（RCC_CIR）里的 CSSC 位来清除 CSS 中断。</p>
<p>如果 HSE 振荡器被直接或间接地作为系统时钟，（间接是指作为 PLL 输入时钟而 PLL 时钟作为系统时钟），时钟故障将导致系统时钟自动切换到 HSI 振荡器，同时外部 HSE 振荡器被关闭。在时钟失效时，如果 HSE 振荡器时钟（被分频或未被分频）是用作系统时钟的 PLL 的输入时钟，PLL 也将被关闭。</p>
<h4 id="4、RTC-时钟"><a href="#4、RTC-时钟" class="headerlink" title="4、RTC 时钟"></a>4、RTC 时钟</h4><p>通过设置备份域控制寄存器（RCC_BDCR）里的 RTCSEL[1:0] 位，RTCCLK 时钟源可以有 HSE/128、LSE 或 LSI 时钟提供。除非备份域复位，此选择不能被改变。</p>
<p>LSE 时钟在备份域里，但 HSE 和 LSI 时钟不是。因此：</p>
<ul>
<li><p>如果 LSE 被选为 RTC 时钟：</p>
<ul>
<li>只要 VBAT 维持供电，尽管 VDD 供电被切断，RTC 仍继续工作。</li>
</ul>
</li>
<li><p>如果 LSI 被选为自动唤醒单元（AWU）时钟：</p>
<ul>
<li>如果 VDD 供电被切断，AWU 状态不能被保证。</li>
</ul>
</li>
<li><p>如果 HSE 时钟 128 分频后作为 RTC 时钟：</p>
<ul>
<li>如果 VDD 供电被切断或内部电压调压器被关闭（1.8V 域的供电被切断），则 RTC 状态不确定。</li>
<li>必须设置电源控制寄存器的 DPB 位为 1（取消后备区域的写保护）。</li>
</ul>
</li>
</ul>
<h4 id="5、看门狗时钟"><a href="#5、看门狗时钟" class="headerlink" title="5、看门狗时钟"></a>5、看门狗时钟</h4><p>如果独立看门狗已经由硬件选项或软件启动，LSI 振荡器将被强制在打开状态，并且不能被关闭。在 LSI 振荡器稳定后，时钟供应给 IWDG。</p>
<hr>
<h3 id="三、时钟输出"><a href="#三、时钟输出" class="headerlink" title="三、时钟输出"></a>三、时钟输出</h3><p>STM32 可以选择一个时钟信号输出到 MCO 脚(PA8)上，可以选择为 PLL 输出的 2 分频、HSI、HSE、或者 SYSCLK。</p>
<hr>
<h3 id="四、相关寄存器"><a href="#四、相关寄存器" class="headerlink" title="四、相关寄存器"></a>四、相关寄存器</h3><p>（1）时钟控制寄存器（RCC_CR）初始化用</p>
<p>（2）时钟配置寄存器（RCC_CFGR）初始化用</p>
<p>（3）时钟中断寄存器（RCC_CIR）</p>
<p>（4）APB2 外设复位寄存器（RCC_APB2RSTR）</p>
<p>（5）APB1 外设复位寄存器（RCC_APB1RSTR）</p>
<p>（6）AHB 外设时钟使能寄存器（RCC_AHBENR）</p>
<p>（7）APB2 外设时钟使能寄存器（RCC_APB2ENR）</p>
<p>（8）APB1 外设时钟使能寄存器（RCC_APB1ENR）</p>
<p>（9）备份域控制寄存器（RCC_BDCR）</p>
<p>（10）控制/状态寄存器（RCC_CSR）</p>
<p>（11）RCC 寄存器地址映像</p>
<p>RCC 地址：0x4002 1000-0x4002 13ff</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 程序烧录</title>
    <url>//blog/2019/03/04/STM32-%E7%A8%8B%E5%BA%8F%E7%83%A7%E5%BD%95/</url>
    <content><![CDATA[<hr>
<p>STM32 的程序烧录方法有多种：USB、串口、JTAG、SWD等。</p>
<p>开发板串口烧录时，mcuisp 软件设置 DTR 低电平复位，RTS 高电平进 BootLoader，选择编程前重装文件，编程后执行，校验，不要选择使用 RamIsp。</p>
<a id="more"></a>
<p>JLINK v8 支持 JTAG 和 SW</p>
<hr>
<p>STM32 启动方式：</p>
<table>
<thead>
<tr>
<th>BOOT0</th>
<th>BOOT1</th>
<th>启动模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>X</td>
<td>用户闪存存储器</td>
<td>用户闪存存储器，也就是FLASH启动</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>系统存储器</td>
<td>系统存储器启动</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>SRAM 启动</td>
<td>SRAN启动，用于在SRAM中调试代码</td>
</tr>
</tbody>
</table>
<p>用户闪存，即芯片内置的 FLASH，从用户闪存启动是正常的工作模式；</p>
<p>SRAM，是芯片内置的 RAM 区，就是内存；</p>
<p>系统存储器，是芯片内部一块特定的区域，芯片出厂时，在这个区域预置了一段 Bootloader，就是通常说的 ISP 程序，这个区域的内容在芯片出场后，没有人能够修改或擦除，即它是一个 ROM 区。</p>
<p>标准的 ISP 下载步骤（串口下载）：</p>
<p>​    ① 配置 BOOT0 为 1，BOOT1 为 0</p>
<p>​    ② 按复位键</p>
<p>​    ③ 通过程序下载代码</p>
<p>​    ④ 下载完成后将 BOOT0 设置为 GND，以便每次复位后都可以运行用户代码</p>
<p>一般不使用内置 SRAM 启动，因为 SRAM 掉电数据丢失。多数情况下 SRAM 只在调试时使用，也可以做其他用途，如故障的局部诊断，写一小段程序加载到 SRAM 中诊断板上的其他电路，或用此方法读写板上的 FLASH 或 EEPROM 等。还可以通过这种方法接触内部FLASH的读写保护，当然接触读写保护的同时，FLASH 的内容也被自动清除，以防止恶意的软件拷贝。</p>
<p>一般 BOOT0 和 BOOT1 跳线都跳到 0。只是在 ISP 下载的情况下，BOOT0=1，BOOT1=0，下载完成后，把 BOOT0 的跳线接回 0。</p>
<p>STM32 内部 FLASH 地址起始于 0x08000000，一般情况下，程序文件就从此地址开始写入。此外 STM32 是基于Cortex-M3 内核的微控制器，其内部通过一张“中断向量表”来响应中断，程序启动后，将首先从“中断向量表”取出复位中断向量执行复位中断程序完成启动，而这张“中断向量表”的起始地址 0x08000004，当中断来临，STM32 的内部硬件机制亦会自动将 PC 指针定位到“中断向量表”处，并根据中断源取出对应的中断向量执行中断服务程序。复位中断服务函数执行完之后，会跳转到 main 函数。</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 程序编译</title>
    <url>//blog/2019/03/04/STM32-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<hr>
<p>Code：表示程序所占用 FLASH 的大小（FLASH）</p>
<p>RO-data：Read Only-data，表示程序定义的常量（FLASH）</p>
<p>RW-data：Read Write-data，表示已被初始化的变量（SRAM）</p>
<p>ZI-data：Zero Init-data，表示未被初始化的变量（SRAM）</p>
<a id="more"></a>
<p>程序的大小不是 .hex 文件的大小，而是编译后 Code 和 RO-data 之和。</p>
<p>在 startup_stm32f10x_hd.s 里面，定义了堆栈（Heap+Stack）大小为 0x600，也就是 1536 字节，usart.c 里定义了 200 字节大小的接收缓冲，共占用 1736 字节的 SRAM。</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 通用定时器</title>
    <url>//blog/2019/03/04/STM32-%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<hr>
<h3 id="一、stm32-定时器简介"><a href="#一、stm32-定时器简介" class="headerlink" title="一、stm32 定时器简介"></a>一、stm32 定时器简介</h3><p>高级定时器 TIM1 TIM8</p>
<p>通用定时器 TIM2~TIM5</p>
<p>基本定时器 TIM6 TIM7</p>
<a id="more"></a>
<hr>
<h3 id="二、通用定时器"><a href="#二、通用定时器" class="headerlink" title="二、通用定时器"></a>二、通用定时器</h3><p>通用定时器通过一个可编程预分频器驱动的 16 位自动装在计数器构成。</p>
<p>它使用于多种场合，包括测量输入信号的脉冲长度（输入捕获）或者产生输出波形（输出比较和 PWM）。</p>
<p>使用定时器预分频器和 RCC 时钟控制器预分频器，脉冲长度和波形周期可以在几个微秒到几个毫秒间调整。</p>
<p>每个定时器完全独立，没有共享任何资源，可同步操作。 </p>
<p>通用定时器的功能包括：</p>
<p>1）16 位向上、向下、向上/向下自动装载计数器（TIMx_CNT）</p>
<p>2）16 位可编程（可实时修改）预分频器（TIMx_PSC），计数器时钟频率的分频系数为 1~65535 之间的任意数值。</p>
<p>3）4 个独立通道（TIMxCH1~4），这些通道可以用来作为：</p>
<p>​    A. 输入捕获</p>
<p>​    B. 输出比较</p>
<p>​    C. PWM 生成（边缘或中间对齐模式）</p>
<p>​    D. 单脉冲模式输出</p>
<p>4）可使用外部信号（TIMx_ETR）控制定时器和定时器互连（可以用1个定时器控制另外一个定时器）的同步电路。</p>
<p>5）如下事件发生时产生中断/DMA</p>
<ul>
<li><p>更新：计数器向上溢出/向下溢出，计数器初始化（通过软件或者内/外部触发）</p>
</li>
<li><p>触发事件（计数器启动、停止、初始化或者由内/外部触发计数）</p>
</li>
<li><p>输入捕获</p>
</li>
<li><p>输出比较</p>
</li>
</ul>
<p>6）支持针对定位的增量（正交）编码器和霍尔传感器电路</p>
<p>7）触发输入作为外部时钟或者按周期的电流管理</p>
<p><img src="https://i.loli.net/2019/03/04/5c7ce26498d19.png" alt="Image.png"></p>
<hr>
<h3 id="三、通用定时器使用步骤："><a href="#三、通用定时器使用步骤：" class="headerlink" title="三、通用定时器使用步骤："></a>三、通用定时器使用步骤：</h3><p>1）TIMx 时钟使能</p>
<p>因为 Stm32_Clock_Init() 函数里把 APB1 的分频设置为 2，所以 TIM3 时钟是 APB1 时钟的 2 倍，等于 72M。</p>
<p>2）设置 TIM3_ARR 和 TIM3_PSC 的值</p>
<p>3）设置 TIM3_DIER 允许更新中断</p>
<p>4）允许 TIM3 工作</p>
<p>5）TIM3 中断分组</p>
<p>6）编写中断服务函数</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8S TIM1 时基单元</title>
    <url>//blog/2019/03/04/STM8S-TIM1-%E6%97%B6%E5%9F%BA%E5%8D%95%E5%85%83/</url>
    <content><![CDATA[<hr>
<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>TIM1 由一个 16 位自动装载计数器组成，它由一个可编程的预分频器驱动。</p>
<a id="more"></a>
<p>高级控制定时器适用于许多不同的用途：</p>
<ul>
<li><p>基本的定时</p>
</li>
<li><p>测量输入信号的脉冲宽度（输入捕获）</p>
</li>
<li><p>产生输出波形（输出比较，PWM 和单脉冲模式）</p>
</li>
<li><p>对应不同事件（捕获，比较，溢出，刹车，触发）的中断</p>
</li>
<li><p>与 TIM5/TIM6 或者外部信号（外部时钟，复位信号，触发和使能信号）同步</p>
</li>
</ul>
<p>高级控制定时器广泛适用各种控制应用，包括那些需要中间对齐模式 PWM 的应用，该模式支持互补输出和死区时间控制。</p>
<p>高级控制定时器的时钟可以是内部信号，也可以是外部信号，通过寄存器配置来选择。</p>
<hr>
<h3 id="二、主要特性"><a href="#二、主要特性" class="headerlink" title="二、主要特性"></a>二、主要特性</h3><p>TIM1的特性包括：</p>
<ul>
<li><p>16 位向上、向下、向上/下自动装载计数器</p>
</li>
<li><p>允许在指定数目的计数器周期之后更新定时器寄存器的重复计数器</p>
</li>
<li><p>16 位可编程（可实时修改）预分频器，计数器时钟频率的分频系数为 1~65536 间的任意数值</p>
</li>
<li><p>同步电路，用于使用外部信号控制定时器以及定时器互联</p>
</li>
<li><p>多达四个独立通道可以配置成：</p>
<ul>
<li>输入捕获</li>
<li>输出比较</li>
<li>PWM 生成（边缘或中间对齐模式）</li>
<li>六步 PWM 输出</li>
<li>单脉冲模式输出</li>
<li>三个支持带互补输出，并且死区时间可编程的通道</li>
</ul>
</li>
<li><p>刹车输入信号可以将定时器输出信号置于复位状态或一个已知状态</p>
</li>
<li><p>产生中断的事件包括：</p>
<ul>
<li>更新：计数器向上/向下溢出，计数器初始化（通过软件或内部/外部触发）</li>
<li>触发事件（计数器启动、停止、初始化或由内部/外部触发计数）</li>
<li>输入捕获</li>
<li>输出比较</li>
<li>刹车信号输入</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/03/04/5c7c7c9c8156d.png" alt="Image.png"></p>
<hr>
<h3 id="三、时基单元"><a href="#三、时基单元" class="headerlink" title="三、时基单元"></a>三、时基单元</h3><p>时基单元包含：</p>
<ul>
<li><p>16位向上/向下计数器</p>
</li>
<li><p>16位自动重载寄存器</p>
</li>
<li><p>重复计数器</p>
</li>
<li><p>预分频器</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/03/04/5c7c7cb4a5bd5.png" alt="Image.png"></p>
<p>16 位计数器，预分频器，自动重载寄存器和重复计数器都可以通过软件读写。自动重载寄存器由预装载寄存器和影子寄存器组成。</p>
<p>可在两种模式下写自动重载寄存器：</p>
<ul>
<li><p>自动预装载已使能（TIM1_CR1 寄存器的 ARPE 位置位）。在此模式下，写入自动重载寄存器的数据将被保存在预装载寄存器中，并在下一个更新事件（UEV）时传送到影子寄存器。</p>
</li>
<li><p>自动预装载已禁止（TIM1_CR1 寄存器的 ARPE 位清除）。在此模式下，写入自动重载寄存器的数据将立即写入影子寄存器。</p>
</li>
</ul>
<p>更新事件的产生条件：</p>
<ul>
<li><p>计数器向下或向下溢出</p>
</li>
<li><p>软件置位了 TIM1_EGR 寄存器的 UG 位</p>
</li>
<li><p>时钟/触发控制器产生了触发事件</p>
</li>
</ul>
<p>在预装载使能时（ARPE=1），如果发生了更新事件，预装载寄存器中的数值（TIM1_ARR）将写入影子寄存器中，并且 TIM1_PSCR 寄存器中的值将写入预分频器中。</p>
<p>置位 TIM1_CR1 寄存器的 UDIS 位将禁止更新事件（UEV）。</p>
<p>计数器由预分频器的输出 CK_CNT 驱动，而 CK_CNT 仅在 IM1_CR1 寄存器的计数器使能位（CEN）被置位时才有效。</p>
<p>在使能了 CEN 位的一个时钟周期后，计数器才开始计数。</p>
<h4 id="1、读写-16-位计数器"><a href="#1、读写-16-位计数器" class="headerlink" title="1、读写 16 位计数器"></a>1、读写 16 位计数器</h4><p>写计数器的操作没有缓存，并且可以在任何时候写 TIM1_CNTRH 和 TIM1_CNTRL 寄存器，因此建议不要再计数器运行时写入新的数值，以免写入错误的数值。</p>
<p>读计数器的操作带有 8 位缓存。在用户读了高位（MS）字节后，低位（LS）字节将被自动缓存，缓存的数据在 16 位的读操作完成之前不会有变化。</p>
<p>注意：不要使用 LDW 指令来读取 16 位计数器的值，因为此指令先读低位（LS）字节，这样读出的数值是错误的。</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c7ccdcafc7.png" alt="Image.png"></p>
<h4 id="2、16-位-TIM1-ARR-寄存器的写操作"><a href="#2、16-位-TIM1-ARR-寄存器的写操作" class="headerlink" title="2、16 位 TIM1_ARR 寄存器的写操作"></a>2、16 位 TIM1_ARR 寄存器的写操作</h4><p>通过预装载寄存器向 TIM1_ARR 寄存器中写入 16 位的值。此操作由两条指令完成，每条指令写入 1 个字节，高位（MS）字节是必须先写入的。</p>
<p>影子寄存器在高位（MS）字节写入后被锁定，并保持到低位（LS）字节写完。不要使用 LDW 指令，因为此指令先写低位（LS）字节，这将导致写入的数值错误。</p>
<h4 id="3、预分频器"><a href="#3、预分频器" class="headerlink" title="3、预分频器"></a>3、预分频器</h4><p>TMI1 的预分频器基于一个由 16 位寄存器（TIM1_PSCR）控制的 16 位计数器。由于这个控制寄存器带有缓冲器，因此它能够在运行时被改变。预分频器可以将计数器的时钟频率按 1 到 65536 之间的任意值分频。</p>
<p>计数器的频率可以由下式计算：</p>
<p>fCK_CNT = fCK_PSC/（PSCR[15:0] + 1）</p>
<p>预分频值由预装载寄存器写入，保存了当前使用值的影子寄存器在低位（LS）写入后被载入。</p>
<p>需两次单独的写操作来写 16 位寄存器，高位（MS）先写。不要使用先写低位的 LDW 指令。</p>
<p>新的预分频器的值在下一次更新事件到来时被采用。</p>
<p>对 TIM1_PSCR 寄存器的读操作通过预装载寄存器完成，因此不需要特别的关注。</p>
<h4 id="4、向上计数模式"><a href="#4、向上计数模式" class="headerlink" title="4、向上计数模式"></a>4、向上计数模式</h4><p>计数器从 0 计数到用户定义的比较值（TIMx_ARR 寄存器的值），然后重新从 0 开始计数并产生一个计数器溢出事件，同时，如果 TIM1_CR1 寄存器的 UDIS 位是 0，将会产生一个更新事件（UEV）。</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c7cecf2195.png" alt="Image.png"></p>
<p>置位 TIMx_EGR 寄存器的 UG 位（通过软件方式或使用从模式控制器）同样可产生一个更新事件。</p>
<p>使用软件置位 TIMx_CR1 寄存器的 UDIS 位，可以禁止更新事件，这样可避免在更新预装载寄存器时更新影子寄存器。在 UDIS 位被清除之前，将不产生更新事件。但是在应该产生更新事件 时，计数器仍会被清 0，同时预分频器的计数也被清 0（但预分频器的数值不变）。此外，如果设置了 TIMx_CR1 寄存器中的 URS 位（选择更新请求），设置 UG 位将产生一个更新事件 UEV，但硬件不设置 UIF 标志（即不产生中断请求）。这是为了避免在捕获模式下清除计数器时，同时产生更新和捕获中断。</p>
<p>当发生一个更新事件时，所有的寄存器都被更新，硬件同时（依据 URS 位）设置更新标志位（TIMx_SR 寄存器的 UIF 位）：</p>
<ul>
<li><p>自动装载影子寄存器被重新置入预装载寄存器的值（TIMx_ARR）</p>
</li>
<li><p>预分频器的缓存器被置入预装载寄存器的值（TIMx_PSC 寄存器的内容）</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/03/04/5c7c7d028d058.png" alt="Image.png"></p>
<p><img src="https://i.loli.net/2019/03/04/5c7c7d11772c7.png" alt="Image.png"></p>
<h4 id="5、向下计数模式"><a href="#5、向下计数模式" class="headerlink" title="5、向下计数模式"></a>5、向下计数模式</h4><p>计数器从自动装载的值（TIMx_ARR 寄存器的值）开始向下计数到 0，然后再从自动装载的值重新开始计数，并产生一个计数器向下溢出时间。如果 TIM1_CR1 寄存器的 UDIS 位被清除，还会产生一个更新事件（UEV）。</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c7d28e89d1.png" alt="Image.png"></p>
<p>置位 TIMx_EGR 寄存器的 UG 位（通过软件方式或者使用从模式控制器）也同样可以产生一个更新事件。</p>
<p>置位 TIMx_CR1 寄存器的 UDIS 位可以禁止 UEV 事件。这样可以避免在更新预装载寄存器时更新影子寄存器。因此 UDIS 位清除之前不会产生更新事件。然而，计数器仍会从当前自动加载值重新开始计数，并且预分频器的计数器重新从 0 开始（但预分频器不能被修改）。</p>
<p> 此外，如果设置了 TIMx_CR1 寄存器中的 URS 位（选择更新请求），设置 UG 位将产生一个更新事件 UEV 但不设置 UIF 标志（因此不产生中断），这是为了表面在发生补货时间并清除计数器时，同时产生更新和捕获中断。</p>
<p>当发生更新事件时，所有的寄存器都被更新，并且（根据 URS 位的设置）更新标志位（TIMx_SR 寄存器中的 UIF 位）也被设置：</p>
<p>预分频器的缓存器被存入预装载的值（TIMx_PSC 寄存器的值）。</p>
<p>当前的自动加载寄存器被更新为预装载值（TIMx_ARR 寄存器中的内容）。要注意自动装载寄存器在计数器重载入之前被更新，因此下一个周期才是预期的值。</p>
<p>以下是一些当 TIMx_ARR = 0x36 时，计数器在不同时钟频率下的图表。</p>
<p>下图描述了在向下计数模式下，预装载不使能时新的数值在下个周期时被写入。</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c7d487f1d4.png" alt="Image.png"></p>
<h4 id="6、中央对齐模式（向上-向下计数）"><a href="#6、中央对齐模式（向上-向下计数）" class="headerlink" title="6、中央对齐模式（向上/向下计数）"></a>6、中央对齐模式（向上/向下计数）</h4><p>在中央对其模式。计数器从 0 开始计数到自动加载的值（TIMx_ARR寄存器）-1，产生一个溢出事件，然后向下计数到 0 并且产生一个计数器下溢事件，然后再从 0 开始重新计数。</p>
<p>在此模式下，不能写入 TIMx_CR1中 的 DIR 方向位。它由硬件更新并指示当前的计数方向。</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c7d5c4e2f3.png" alt="Image.png"></p>
<p>如果定时器带有重复计数器（如 TIM1），在重复了指定次数（TIM1_RCR 的值）的向上和向下溢出之后会产生更新事件（UEV）。否则每一次的向上向下溢出都会产生更新事件。</p>
<p>置位 TIMx_EGR 寄存器的 UG 位（通过软件方式或者使用从模式控制器）也同样可以产生一个更新事件。此时，计数器重新从 0 开始计数，预分频器也重新从 0 开始计数。</p>
<p>设置 TIMx_CR1 寄存器中的 UDIS 位可以禁止 UEV 事件。这样可以避免在更新预装载寄存器时更新影子寄存器。因此 UDIS 位被清 0 之前不会产生更新事件。然而，计数器仍会根据当前自动重加载的值，继续向上或向下计数。如果定时器带有重复计数器，由于重复寄存器没有双重的缓冲，新的重复数值将立刻生效，因此在修改时需要小心。</p>
<p>此外，如果设置了 TIMx_CR1 寄存器中的 URS 位（选择更新请求），设置 UG 位将产生一个更新事件 UEV 但不设置 UIF 标志（因此不产生中断），这是为了避免在发生捕获事件并清除计数器时，同时产生更新和捕获中断。</p>
<p>当发生更新事件时，所有的寄存器都被更新，并且（根据 URS 位的设置）更新标志位（TIMx_SR 寄存器中的 UIF 位）也被设置。</p>
<p>预分频器的缓存器被加载为预装载（TIMx_PSC 寄存器）的值。</p>
<p>当前的自动加载寄存器被更新为预装载值（TIMx_ARR 寄存器中的内容）。要注意到如果因为计数器溢出而产生更新，自动重装载寄存器将在计数器重载入之前被更新，因此下一个周期才是预期的值（计数器被装载位新的值）。以下是一些计数器在不同时钟频率下的操作的例子：</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c7d7479a01.png" alt="Image.png"></p>
<p>使用中央对齐模式的提示：</p>
<ul>
<li>启动中央对齐模式时，计数器将按照原有的向上/向下的配置计数。也就是说 TIM1_CR1 寄存器中的 DIR 位将决定计数器时向上还是向下计数。此外，软件不能同时修改 DIR 和 CMS 位的值。</li>
</ul>
<ul>
<li>不推荐在中央对齐模式下，计数器正在计数时写计数器的值，这将导致不能预料的后果。具体的说：<ul>
<li>向计数器写入了比自动装载值更大的数值时（TIM1_CNT &gt; TIM1_ARR），但计数器的技术方向不发生改变。例如计数器已经向上溢出，但计数器仍然向上计数。</li>
<li>向计数器写入了 0 或者 TIM1_ARR 的值，但更新事件不发生。</li>
</ul>
</li>
</ul>
<ul>
<li>安全使用中央对齐模式的计数器的方法是在启动计数器之前先用软件（置位 TIM1_EGR 寄存器的 UG 位）产生一个更新事件，并且不在计数器计数时修改计数器的值。</li>
</ul>
<h4 id="7、重复计数器"><a href="#7、重复计数器" class="headerlink" title="7、重复计数器"></a>7、重复计数器</h4><p>时基单元一节解释了计数器向上/向下溢出时更新事件（UEV）是如何产生的，然而事实上它只能在重复计数器的值达到 0 的时候产生。这个特性对产生 PWM 信号非常有用。</p>
<p>这意味着在每 N 次计数上溢或下溢时，数据从预装载寄存器传输到影子寄存器（TIMx_ARR 自动重载入寄存器，TIMx_PSC 预装载寄存器，还有在比较模式下的捕获/比较寄存器 TIMx_CCRx），N 是 TIMx_RCR 重复计数寄存器中的值。</p>
<p>重复计数器在下述任一条件成立时递减：</p>
<ul>
<li><p>向上计数模式下每次计数器向上溢出时</p>
</li>
<li><p>向下计数模式下每次计数器向下溢出时</p>
</li>
<li><p>中央对齐模式下每次上溢和下溢时</p>
</li>
</ul>
<p>虽然这样限制了 PW 的最大循环周期为 128，但它能够在每个 PWM 周期 2 次更新占空比。在中央对齐模式下，因为波形是对称的，如果每个 PWM 周期中仅刷新一次比较寄存器，则最大的分辨率为 2*tCK_PSC。</p>
<p>重复计数器是自动加载的，重复速率由 TIMx_RCR 寄存器的值定义。当更新事件由软件产生（通过设置 TIMx_EGR 中的 UG 位）或者通过硬件的从模式控制器产生，则无论重复计数器的值是多少，立即发生更新事件，并且 TIMx_RCR 寄存器中的内容被重载到重复计数器。</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c7d8ca3063.png" alt="Image.png"></p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM8</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8S 自动唤醒 AWU</title>
    <url>//blog/2019/03/04/STM8S-%E8%87%AA%E5%8A%A8%E5%94%A4%E9%86%92-AWU/</url>
    <content><![CDATA[<hr>
<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>AWU 是用来当 MCU 进入低功耗的 Active Halt 模式时提供一个内部的唤醒时间基准。该时间基准的时钟是由内部的低速 RC 振荡器时钟（LSI）或通过预分频的 HSE 晶振时钟来提供的。</p>
<a id="more"></a>
<p><strong>LSI 时钟测量</strong></p>
<p>在使用 LSI 低速内部时钟时，为了确保最好的精度，它的频率可以通过 TIM3 的输入捕获 1 来测定。</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c75c9bab66.png" alt="Image.png"></p>
<p>注意：LS 低速时钟源的选择是通过编程 CKAWUSEL 选项位来实现的。</p>
<hr>
<h3 id="二、AWU-功能描述"><a href="#二、AWU-功能描述" class="headerlink" title="二、AWU 功能描述"></a>二、AWU 功能描述</h3><h4 id="1、AUW-操作"><a href="#1、AUW-操作" class="headerlink" title="1、AUW 操作"></a>1、AUW 操作</h4><p>为了使用 AWU 功能，按顺序执行如下步骤：</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c75eb5d4df.png" alt="Image.png"></p>
<p><strong>空闲模式</strong></p>
<p>如果不使用 AWU，必须载入‘0000’值到 AWU_TBR 的 AWUTB[3:0] 来降低功耗。</p>
<h4 id="2、时基选择"><a href="#2、时基选择" class="headerlink" title="2、时基选择"></a>2、时基选择</h4><p><img src="https://i.loli.net/2019/03/04/5c7c760388799.png" alt="Image.png"></p>
<h4 id="3、LSI-低速内部时钟频率检测"><a href="#3、LSI-低速内部时钟频率检测" class="headerlink" title="3、LSI 低速内部时钟频率检测"></a>3、LSI 低速内部时钟频率检测</h4><p>在经过出厂校验后，在全温度范围内低速内部 RC（LSI）振荡器的频率离散性是 128kHz±12.5%。为了获得精确的 AWU 时间间隔或蜂鸣器输出，必须精确测量 LSI 频率。</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c761d6ced8.png" alt="Image.png"></p>
<hr>
<h3 id="三、AWU寄存器"><a href="#三、AWU寄存器" class="headerlink" title="三、AWU寄存器"></a>三、AWU寄存器</h3><p>控制/状态寄存器     AWU_CSR</p>
<p>异步预分频寄存器   AWU_APR</p>
<p>时基选择寄存器      AWU_TBR</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM8</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8S 通用 IO</title>
    <url>//blog/2019/03/04/STM8S-%E9%80%9A%E7%94%A8-IO/</url>
    <content><![CDATA[<hr>
<p>一、简介</p>
<p>一个 GPIO 端口可以包括多达 8 个引脚，每个引脚可独立编程为数字输入或数字输出口。部分口可能会有模拟输入，外部中断，片上外设的输入输出等复用功能。但是同一时刻只有一个复用功能可以映射到引脚上。复用功能的映射是通过选项字节控制的。</p>
<a id="more"></a>
<hr>
<p>二、GPIO 主要功能</p>
<ul>
<li><p>浮空输入和上拉输入</p>
</li>
<li><p>推完输出和开漏输出</p>
</li>
<li><p>输入输出有各自的寄存器</p>
</li>
<li><p>外部中断可单独使能和关闭</p>
</li>
<li><p>输出摆率可单独使能和关闭</p>
</li>
<li><p>输出摆率控制用以较少 EMC 噪声</p>
</li>
<li><p>片上外设的 IO 功能复用</p>
</li>
<li><p>当作为模拟输入时可以关闭输入施密特触发器来降低功耗</p>
</li>
<li><p>数据输出锁存时支持 读-修改-写</p>
</li>
<li><p>输入兼容 5V</p>
</li>
<li><p>IO 口工作电压范围为 1.6V 到 VDDIOmax</p>
</li>
</ul>
<p><img src="https://i.loli.net/2019/03/04/5c7c73c48bcea.png" alt="Image.png"></p>
<p>输出级在选择模拟输入时是禁止的。</p>
<hr>
<p>三、IO 的配置和使用</p>
<p>每一个端口都有一个输出数据寄存器（ODR），一个引脚输入寄存器（IDR）和一个数据方向寄存器（DDR）总是同相关的。</p>
<p>控制寄存器 1（CR1）和控制寄存器 2（CR2）用于对输入/输出进行配置。任何一个 IO 引脚可以通过对 DDR，ODR，CR1 和 CR2 寄存器的相应位进行编程来配置。</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c7445f18b3.png" alt="Image.png"></p>
<p>在真正的漏极开路硅片引脚上不存在连接到 VDD 的二极管，在硅片引脚和 VOL 之间集成了局部保护，以保护设备免受 positive stress。</p>
<p>复位之后，所有引脚都是悬浮输入模式。个别引脚可能有其他动作。</p>
<p>没有使用的 IO 引脚不能保持悬空以避免额外的电流消耗，必须从以下配置选一个：</p>
<ul>
<li><p>通过外部上拉或下拉电阻连接到 VDD 或 VSS，并设为悬空输入。</p>
</li>
<li><p>配置为输入，使用内部上下拉电阻</p>
</li>
<li><p>配置为推完输出低</p>
</li>
</ul>
<p>小封装中有些 IO 端口的引脚数不足 8 个，对这些端口的寄存器进行写操作不会有任何影响，输入寄存器中相应位的读出值是 0。</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c74660b2bd.png" alt="Image.png"></p>
<p>如果 PA1/PA2 被用来连接外部谐振器，为了确保在 HALT 模式下有最低功耗，必须配置 PA1 和 PA2 为上拉输入。</p>
<hr>
<p>三、输入模式详述</p>
<p>1、复用功能输入</p>
<p>部分 IO 口可以用作复用功能输入。例如：可以被用来作为输入到定时器的输入捕获口。复用的输入功能使不会自动选择的，用户可以通过写相应的外设寄存器的控制位来选择复用功能。</p>
<p>对于复用功能的输入，用户必须通过配置 DDR 和 CR1 寄存器设置将对应的 IO 口设为悬空或上拉输入。</p>
<p>2、中断功能</p>
<p>每一个中断向量都可以独立编程为上升沿或下降沿触发。</p>
<p>外部中断只有在对应 IO 口被设置为输入模式时才有效。</p>
<p>3、模拟通道</p>
<p><img src="https://i.loli.net/2019/03/04/5c7c748fd9cc9.png" alt="Image.png"></p>
<p>4、施密特触发器</p>
<p>部分 IO 口包括一个内嵌的输入施密特触发器，可以通过 ADC_TDR 施密特触发器来禁止寄存器来使能/禁止施密特触发器。</p>
<hr>
<p>四、输出模式详述</p>
<p>1、复用功能输出</p>
<p>复用功能使能时，复用功能模块接管了输出锁存寄存器（Px_ODR）并强制 Px_ODR 相应的位为 1。</p>
<p>复用输出功能可以是上拉或者开漏输出，取决于外设本身和控制寄存器（Px_CR1），输出摆率取决于控制寄存器 2（Px_CR2）的值。</p>
<p>例如：</p>
<p>考虑到要达到最佳性能，SPI 输出引脚必须设置为上拉，快速摆率。 UART_Tx 可以被配置为上拉或开漏输出（带外部上拉）来实现多从机的配置。</p>
<p>2、摆率控制</p>
<p>输出摆率可以使用 CR2 的相应位通过软件控制。置位 CR 相应位选择为 10MHz 的输出频率。该功能既可以用在开漏也可以用在带上拉的输出模式 IO 口，输出类型为 O3 或 O4。</p>
<hr>
<p>五、GPIO 寄存器</p>
<p>输出数据寄存器     Px_ODR</p>
<p>输入数据寄存器     Px_IDR</p>
<p>数据方向寄存器     Px_DDR</p>
<p>控制寄存器1          Px_CR1</p>
<p>控制寄存器2          Px_CR2</p>
]]></content>
      <tags>
        <tag>硬件拾忆</tag>
        <tag>STM8</tag>
      </tags>
  </entry>
  <entry>
    <title>Win7 下 Cadence Capture 窗口最小化无法打开问题解决办法</title>
    <url>//blog/2019/03/04/Win7-%E4%B8%8B-Cadence-Capture-%E7%AA%97%E5%8F%A3%E6%9C%80%E5%B0%8F%E5%8C%96%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<hr>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>打开 Capture 时，软件一直最小化到下方任务栏，点击后无反应。</p>
<a id="more"></a>
<hr>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>直接删除 capture.ini</p>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>先关闭软件。</p>
<p>打开 capture.ini，找到 [Window Placement] 配置选项，将窗口大小改为默认大小。</p>
<p><em>[Window Placement]</em></p>
<p><em>Max Position…=(-1,-1)</em></p>
<p><em>Min Position…=(-32000,-32000)</em></p>
<p><em>Normal Position=(138,105,1176,877)</em></p>
<p><em>Show………..=ShowNormal</em></p>
]]></content>
      <tags>
        <tag>软件使用</tag>
      </tags>
  </entry>
  <entry>
    <title>算法复杂度分析</title>
    <url>//blog/2019/03/08/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<hr>
<p>《数据结构（C++语言版）》（邓俊辉编著）笔记</p>
<hr>
<h3 id="一、高效解"><a href="#一、高效解" class="headerlink" title="一、高效解"></a>一、高效解</h3><h4 id="1、常数复杂度（constant-time-algorithm）-O-1"><a href="#1、常数复杂度（constant-time-algorithm）-O-1" class="headerlink" title="1、常数复杂度（constant-time algorithm） O(1)"></a>1、常数复杂度（constant-time algorithm） O(1)</h4><p>运行时间可表示和度量为 <font color="#FF0000">  T(n) = O(1)</font> 的算法。通常不含循环、分支、子程序调用等。</p>
<p>仅需常数规模辅助空间的算法，称为就地算法（in-place algorithm）。</p>
<a id="more"></a>
<h4 id="2、对数复杂度（logarithmic-time-algorithm）-O-logn"><a href="#2、对数复杂度（logarithmic-time-algorithm）-O-logn" class="headerlink" title="2、对数复杂度（logarithmic-time algorithm） O(logn)"></a>2、对数复杂度（logarithmic-time algorithm） O(logn)</h4><ul>
<li>常底数无所谓<ul>
<li>log a n = log a b · log b n = Θ( log b n )</li>
</ul>
</li>
<li>常数次幂无所谓<ul>
<li>log n^c = c log n = Θ( log n )</li>
</ul>
</li>
<li><font color="#FF0000">对数多项式</font>（ploy-log function）<ul>
<li>T( n ) = O( (logn)^c )</li>
<li>忽略低次项</li>
</ul>
</li>
</ul>
<p>此类算法非常有效，复杂度无限接近于常数</p>
<ul>
<li>任意 c&gt;0，log n = O( n^c )</li>
<li>低于任何一个多项式的复杂度</li>
</ul>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int countones(unsigned int n)&#123;//统计整数n的二进制展开中数位1的总数：0（1ogn）</span><br><span class="line">	int ones = e；</span><br><span class="line">	while(e&lt;n)&#123;</span><br><span class="line">		ones += (1&amp;n)；</span><br><span class="line">		n &gt;&gt;= 1；</span><br><span class="line">	return ones；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二、有效解"><a href="#二、有效解" class="headerlink" title="二、有效解"></a>二、有效解</h3><h4 id="1、线性复杂度（linear-time-algorithm）-O-n"><a href="#1、线性复杂度（linear-time-algorithm）-O-n" class="headerlink" title="1、线性复杂度（linear-time algorithm） O(n)"></a>1、线性复杂度（linear-time algorithm） O(n)</h4><p>所有 O( n ) 类算法。</p>
<p>如迭代累加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sumI(int A[]，int n)&#123;</span><br><span class="line">	int sum = e；</span><br><span class="line">	for(inti=e；i&lt;n；i++)</span><br><span class="line">		sum += A[i]；</span><br><span class="line">	return sum；</span><br><span class="line">&#125;  //0（1）+0（n）*O（1）+0（1）=0（n+2）=0（n）`</span><br></pre></td></tr></table></figure>
<h4 id="2、多项式复杂度（polynomial-time-algorithm）-O-polynomial-n"><a href="#2、多项式复杂度（polynomial-time-algorithm）-O-polynomial-n" class="headerlink" title="2、多项式复杂度（polynomial-time algorithm） O( polynomial(n) )"></a>2、多项式复杂度（polynomial-time algorithm） O( polynomial(n) )</h4><p>O( n^c ) 类算法，低次项可忽略。</p>
<p>多项式复杂度被视作一个具有特殊意义的复杂度级别，实际应用中一般认为是可接受的。</p>
<hr>
<h3 id="三、难解"><a href="#三、难解" class="headerlink" title="三、难解"></a>三、难解</h3><h4 id="1、指数复杂度（exponential-time-algorithm）-O-c-n"><a href="#1、指数复杂度（exponential-time-algorithm）-O-c-n" class="headerlink" title="1、指数复杂度（exponential-time algorithm） O( c^n )"></a>1、指数复杂度（exponential-time algorithm） O( c^n )</h4><p>运行时间可以表示和度量为 T(n) = O(a^n) 形式的算法。</p>
<p>通常认为，指数复杂度算法无法真正应用于实际问题中，它们不是有效算法，甚至不能称作算法。</p>
<hr>
<h3 id="四、复杂度层次"><a href="#四、复杂度层次" class="headerlink" title="四、复杂度层次"></a>四、复杂度层次</h3><p>典型的复杂度层次包括：</p>
<p>O( 1 )</p>
<p>O( log * n )</p>
<p>O( loglogn )</p>
<p>O( logn )</p>
<p>O( sqrt(n) )</p>
<p>O( n )</p>
<p>O( nlog * n )</p>
<p>O( nloglogn )</p>
<p>O( nlogn )</p>
<p>O( n^2 )</p>
<p>O( n^3 )</p>
<p>O( n^c )</p>
<p>O( 2^n )</p>
<hr>
<h3 id="五、输入规模"><a href="#五、输入规模" class="headerlink" title="五、输入规模"></a>五、输入规模</h3><p>待计算问题的输入规模，应严格定义为：用以描述输入所需的空间规模。</p>
<p>有些情况下，以输入参数 n 本身的数值作为基准而得出的 O( logn ) 和 O( n ) 复杂度，应分别称为伪对数的（pseudo-logarithmic）和伪线性的（pseudo-linear）复杂度。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int4 power2BF_I(int n)&#123;</span><br><span class="line">	__int64 pow = 1；</span><br><span class="line">    while（e&lt;n--）</span><br><span class="line">        pow &lt;&lt;= 1;</span><br><span class="line">	return pow；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此程序如果以 n 本身数值作为基准，复杂度为 O( n )。但如果以输入参数 n 的二进制展开的宽度 r 作为输入规模，则为 O( 2^r )，这样也更为合理。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法复杂度度量</title>
    <url>//blog/2019/03/08/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%BA%A6%E9%87%8F/</url>
    <content><![CDATA[<hr>
<p>《数据结构（C++语言版）》（邓俊辉编著）笔记</p>
<hr>
<h3 id="一、时间复杂度"><a href="#一、时间复杂度" class="headerlink" title="一、时间复杂度"></a>一、时间复杂度</h3><p>在规模为 n 的所有输入中，选择执行时间最长者作为 T(n)，并以 T(n) 度量算法的时间复杂度。</p>
<a id="more"></a>
<hr>
<h3 id="二、渐进复杂度"><a href="#二、渐进复杂度" class="headerlink" title="二、渐进复杂度"></a>二、渐进复杂度</h3><h4 id="1、渐进分析（asymptotic-analysis）"><a href="#1、渐进分析（asymptotic-analysis）" class="headerlink" title="1、渐进分析（asymptotic analysis）"></a>1、渐进分析（asymptotic analysis）</h4><p>着眼长远、更为注重时间复杂度的总体变化趋势和增长速度的策略与方法。</p>
<h4 id="2、大-O-记号（big-O-notation）"><a href="#2、大-O-记号（big-O-notation）" class="headerlink" title="2、大 O 记号（big-O notation）"></a>2、大 O 记号（big-O notation）</h4><p>若存在正的常数 c 和函数 f(n)，使得对任何 n &gt;&gt; 2 都有 T(n) ≤ c · f(n)，则可认为在 n 足够大之后，f(n) 给出了 T(n) 增长速度的一个<font color="#FF0000">  渐进上界</font>。记为 T(n) = O( f(n) )。</p>
<p>性质：</p>
<p>（1）对任一常数 c&gt;0，有 O( f(n) ) = O( c · f(n) )</p>
<p>（2）对任意常数 a&gt;b&gt;0，有 O( n^a + n^b ) = O( n^a )</p>
<font color="#FF0000">  以大 O 记号形式表示的时间复杂度，实质上是对算法执行时间的一种保守估计（最坏情况）。   </font>



<h4 id="3、大-Ω-记号"><a href="#3、大-Ω-记号" class="headerlink" title="3、大 Ω 记号"></a>3、大 Ω 记号</h4><p>若存在正的常数 c 和函数 g(n)，使得对任何 n &gt;&gt; 2 都有 T(n) ≥ c · g(n)，则可认为在 n 足够大之后，g(n) 给出了 T(n) 的一个<font color="#FF0000">  渐进下界</font>。记为 T(n) = Ω( g(n) )。</p>
<font color="#FF0000">  大 Ω 记号是对算法执行效率的一种乐观估计。</font>



<h4 id="4、大-Θ-记号"><a href="#4、大-Θ-记号" class="headerlink" title="4、大 Θ 记号"></a>4、大 Θ 记号</h4><p>若存在正的常数 c1 &lt; c2 和函数 h(n)，使得对任何 n &gt;&gt; 2 都有 c1 · h(n) ≤ T(n) ≤ c · h(n)，则可认为在 n 足够大之后，h(n) 给出了 T(n) 的一个<font color="#FF0000">确界</font>。记为 T(n) = Θ( h(n) )。</p>
<font color="#FF0000">  大 Θ 记号是对算法复杂度的一种准确估计。</font>



<p>三种渐进复杂度记号之间的联系与区别</p>
<p><img src="https://i.loli.net/2019/03/09/5c831cc1926dc.png" alt="1552096391930"></p>
<hr>
<h3 id="三、空间复杂度"><a href="#三、空间复杂度" class="headerlink" title="三、空间复杂度"></a>三、空间复杂度</h3><p>空间复杂度通常并不计入原始输入本身所占用的空间。其它（如转储、中转、索引、映射、缓冲等）各个方面所消耗的空间，都应计入。</p>
<p>任一算法的任何一次运行过程汇总所消耗的存储空间，都不会多于其间所执行基本操作的累计次数。</p>
<p>时间复杂度本身就是空间复杂度的一个天然上界。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>递归算法</title>
    <url>//blog/2019/03/09/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>《数据结构（C++语言版）》（邓俊辉编著）笔记</p>
<hr>
<p>〇、概念</p>
<p>递归 —— 允许函数和过程进行<font color="#FF0000">  自我调用 </font>的一种特殊形式。</p>
<p>递归基 —— 保证递归能够结束（有穷性）的平凡情况，可以有多种，至少有一种，且迟早必然会出现。递归基可能是隐含的。</p>
<a id="more"></a>
<hr>
<h3 id="一、常用递归算法"><a href="#一、常用递归算法" class="headerlink" title="一、常用递归算法"></a>一、常用递归算法</h3><h4 id="1、线性递归"><a href="#1、线性递归" class="headerlink" title="1、线性递归"></a>1、线性递归</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>每一层次上至多只有一个实例，且构成一个线性的次序关系，称为线性递归（linear recursion）。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sum (int A[]，int n)&#123; // 数组求和算法（线性递归版）</span><br><span class="line">	if (1&gt;n)// 递归基</span><br><span class="line">		return 0;</span><br><span class="line">	else</span><br><span class="line">		return sum (A，n-1) + A[n-1]; // 减而治之</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="减而治之-（decrease-and-conquer）策略"><a href="#减而治之-（decrease-and-conquer）策略" class="headerlink" title="  减而治之 （decrease-and-conquer）策略"></a><font color="#FF0000">  减而治之 </font>（decrease-and-conquer）策略</h5><p>递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡的简单问题。</p>
<p>问题划分为两个子问题：</p>
<ul>
<li>平凡的子问题</li>
<li>规模缩减的子问题</li>
</ul>
<h4 id="2、二分递归（多路递归）"><a href="#2、二分递归（多路递归）" class="headerlink" title="2、二分递归（多路递归）"></a>2、二分递归（多路递归）</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>将一个大规模的问题划分为若干（通常两个）规模大体相当的子问题，分别求解子问题，由子问题的解，得到原问题的解。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sum(int A[]，int lo，int hi)&#123; // 数组求和算法(二分递归版)</span><br><span class="line">    if(lo == hi) // 递归基</span><br><span class="line">        return A[lo];</span><br><span class="line">    else&#123; </span><br><span class="line">        int mi = (lo+hi)&gt;&gt;1;</span><br><span class="line">        return sum(A，lo，mi) + sum(A，mi+1，hi); // 分而治之</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分而治之-（divide-and-conquer）策略"><a href="#分而治之-（divide-and-conquer）策略" class="headerlink" title=" 分而治之 （divide-and-conquer）策略"></a><font color="#FF0000"> 分而治之 </font>（divide-and-conquer）策略</h5><p>将问题分解为若干规模更小的子问题，再通过递归机制分别求解。</p>
<h4 id="3、多向递归（多分支递归）"><a href="#3、多向递归（多分支递归）" class="headerlink" title="3、多向递归（多分支递归）"></a>3、多向递归（多分支递归）</h4><p>每一递归实例虽有多个可能的递归方向，但只能从中选择其一。</p>
<p>各层次上的递归实例依然构成一个线性次序关系，这种情况本质上仍属于线性递归。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline_int64 sqr(_int64 a)&#123; return a*a;&#125;</span><br><span class="line">int64 power2(int n)&#123; //幂函数 2^n 算法(优化递归版)</span><br><span class="line">    if(e==n)return 1;// 递归基</span><br><span class="line">    return(n&amp;1) ？sqr(power2(n&gt;&gt;1))&lt;&lt;1 : sqr(power2(n&gt;&gt;1));// 多分支递归</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对输入参数 n 为奇数或偶数两种可能，分别设有不同的递归方向。</p>
<hr>
<h3 id="二、递归分析"><a href="#二、递归分析" class="headerlink" title="二、递归分析"></a>二、递归分析</h3><h4 id="1、递归跟踪（recursion-trace）"><a href="#1、递归跟踪（recursion-trace）" class="headerlink" title="1、递归跟踪（recursion trace）"></a>1、递归跟踪（recursion trace）</h4><p>将算法的执行过程整理成图的形式，可以直观的分析递归算法的运行时间与空间。</p>
<h4 id="2、递推方程"><a href="#2、递推方程" class="headerlink" title="2、递推方程"></a>2、递推方程</h4><p>通过对递归模式的数学归纳，导出复杂度定界函数的递推方程（组）及其边界条件，从而将复杂度的分析，转化为递归方程（组）的求解。</p>
<p>边界条件往往可以分析递归基获得。</p>
<hr>
<h3 id="三、递归消除"><a href="#三、递归消除" class="headerlink" title="三、递归消除"></a>三、递归消除</h3><p>递归程序往往需要较多的空间，并进而影响实际的运行速度，因此，往往应将递归算法改写成等价的非递归版本。</p>
<p>可以借助栈来消除递归。对于单向递归和尾递归，也可利用迭代的方式进行递归消除。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>送给2019</title>
    <url>//blog/2019/03/12/%E9%80%81%E7%BB%992019/</url>
    <content><![CDATA[<hr>
<p>菩提本无树</p>
<p>明镜亦非台</p>
<p>本来无一物</p>
<p>何处惹尘埃</p>
]]></content>
      <tags>
        <tag>心花路放</tag>
      </tags>
  </entry>
  <entry>
    <title>对数复杂度的常底数不需要写具体数值的原因</title>
    <url>//blog/2019/03/13/%E5%AF%B9%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E5%B8%B8%E5%BA%95%E6%95%B0%E4%B8%8D%E9%9C%80%E8%A6%81%E5%86%99%E5%85%B7%E4%BD%93%E6%95%B0%E5%80%BC%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<hr>
<p>设某函数的上界可以表示为 f(x) = O(logaN)，a&gt;1 为常数。</p>
<p>对任一常数 b&gt;1，因 lna/lnb 为常数，则由大 O 记号的性质有：</p>
<p>f(n) = O(logaN) = O(lnb/lna * logbN) = O(logbN)</p>
<p>所以无论常底数更换为任意常数，都只会影响常系数，而在大 O 记号中，常系数又可忽略，因此在用大 O 记号表示对数复杂度的时候，无需写常底数。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>统计字符串中的回文子串长度</title>
    <url>//blog/2019/03/19/%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<hr>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>子串：字符串中连续的长度大于0的一段。 </p>
</li>
<li><p>回文串：若字符串的倒序与此字符串相同，则称这个字符串为回文串。  </p>
</li>
</ul>
<a id="more"></a>
<hr>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>输入输出均没有特殊格式，使用 C++ 输入输出流。</p>
<p>分别用函数切分子串和判断是否是回文串。</p>
<p>切分子串时使用 string 类型的 .substr() 方法。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool IsPalindromeStr(string str) &#123;</span><br><span class="line">	for (int i = 0; i &lt; str.size()/2; i++) &#123;</span><br><span class="line">		if (str[i] != str[str.size()-1-i]) return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int CountPalindromeStrNum(string str) &#123;</span><br><span class="line">	int count = 0;</span><br><span class="line">	for (int i = 0; i&lt;str.size(); i++) &#123;</span><br><span class="line">		for (int j = 1; j &lt; str.size()-i+1; j++) &#123;</span><br><span class="line">			string substrs = str.substr(i, j);</span><br><span class="line">			if (IsPalindromeStr(substrs)) count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">​	string input_str;</span><br><span class="line">​	cin &gt;&gt; input_str;</span><br><span class="line">​	cout &lt;&lt; CountPalindromeStrNum(input_str) &lt;&lt; endl;</span><br><span class="line">​	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ string 转换为 int</title>
    <url>//blog/2019/04/11/C-string-%E8%BD%AC%E6%8D%A2%E4%B8%BA-int/</url>
    <content><![CDATA[<hr>
<h4 id="方法一、使用-stringstream"><a href="#方法一、使用-stringstream" class="headerlink" title="方法一、使用 stringstream"></a>方法一、使用 stringstream</h4><p>需要包含 <sstream> 头文件。</sstream></p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int val;</span><br><span class="line">string str = &quot;123&quot;;</span><br><span class="line">stringstream ss(str);</span><br><span class="line">ss &gt;&gt; val；</span><br></pre></td></tr></table></figure>
<h4 id="方法二、"><a href="#方法二、" class="headerlink" title="方法二、"></a>方法二、</h4><p>未完待续。。。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 文件流输入输出</title>
    <url>//blog/2019/04/04/C-%E6%96%87%E4%BB%B6%E6%B5%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<hr>
<p>头文件 fstream 定义了三个类来支持文件 IO：</p>
<ul>
<li>ifstream 从一个给定文件读取数据</li>
<li>ofstream 向一个给定文件写入数据</li>
<li>fstream 读写给定文件</li>
</ul>
<a id="more"></a>
<hr>
<h4 id="一、创建对象及打开文件"><a href="#一、创建对象及打开文件" class="headerlink" title="一、创建对象及打开文件"></a>一、创建对象及打开文件</h4><h5 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br></pre></td></tr></table></figure>
<p>fstream 文件使用 std 命名空间。</p>
<h5 id="创建文件流"><a href="#创建文件流" class="headerlink" title="创建文件流"></a>创建文件流</h5><p>读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。每个文件流类都定义了一个名为 open 的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifstream input(ifile); // 构造一个 ifstream 并打开给定文件</span><br><span class="line">ofstream output;    // 输出文件流未关联任何文件</span><br></pre></td></tr></table></figure>
<p>对象名字可以是任意有效名称，如以上的 input、output。</p>
<h5 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h5><p>以下两种打开方式是等效的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifstream fin(&quot;in_test.txt&quot;);</span><br><span class="line"></span><br><span class="line">ifstream fin;</span><br><span class="line">fin.open(&quot;in_test.txt&quot;);</span><br></pre></td></tr></table></figure>
<p>如果文件在其他文件夹中，可以使用绝对路径。注意绝对路径中的 ‘\‘ 要转义替换成 ‘\\‘。</p>
<p>使用 open 方法时，共可以设置三个参数：filename，mode，access。</p>
<p>mode 即打开方式，有以下常用值：<br>ios::app：　　　以追加的方式打开文件 　　<br>ios::ate：　　　文件打开后定位到文件尾，ios:app就包含有此属性 　　<br>ios::binary：　以二进制方式打开文件，缺省是文本方式　<br>ios::in：　　　 文件以输入方式打开(文件数据输入到内存)<br>ios::out：　　　文件以输出方式打开(内存数据输出到文件) 　<br>ios::nocreate： 不建立文件，所以文件不存在时打开失败 　　<br>ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败 　　<br>ios::trunc：　　如果文件存在，把文件长度设为0</p>
<p>access 即打开文件的属性，有以下常用值：<br>0：普通文件，打开访问<br>1：只读文件<br>2：隐含文件<br>3：系统文件</p>
<h5 id="关闭文件流"><a href="#关闭文件流" class="headerlink" title="关闭文件流"></a>关闭文件流</h5><p>使用 close() 方法关闭文件流。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifstream fin(&quot;in_test.txt&quot;);</span><br><span class="line">fin.close();</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二、读写文本文件"><a href="#二、读写文本文件" class="headerlink" title="二、读写文本文件"></a>二、读写文本文件</h4><h5 id="读文本文件"><a href="#读文本文件" class="headerlink" title="读文本文件"></a>读文本文件</h5><p>1、使用插入器（&lt;&lt;）</p>
<p>因为 istream/ostream 类分别是 ifstream/ofstream 类的基类，所以可以直接使用它们的方法。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifstream fin(&quot;in_test.txt&quot;);</span><br><span class="line">string str;</span><br><span class="line">fin &gt;&gt; str;</span><br></pre></td></tr></table></figure>
<p>注：cin</p>
<p>上面的代码可以读取一行数据到字符串 str 中。如果出现空格，将读取到该行的空格位置。</p>
<p>2、使用文件流的 getline() 成员函数</p>
<p>ifstream 也有 getline() 成员函数，有两种重载形式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">istream&amp; getline (char* s, streamsize n ); //读取最多 n 个字符保存在 s 对应的数组中，即使大小不够 n</span><br><span class="line">istream&amp; getline (char* s, streamsize n, char delim ); //读取最多 n 个字符保存在s对应的数组中，遇到 delim，或者读完一行，或字数达到限制则终止</span><br></pre></td></tr></table></figure></p>
<p>最多读取 n 个字符，这 n 个字符包括结束符，如果 n 是 1，将只会得到一个 ‘\0’，而不会获取文件中的内容。</p>
<p>字符内容只能读到 char 型数组中。遇到空格或回车将结束读取，即使还没有到达设置的数量，即此方法只能读取一个 C 语言意义上的字符串。</p>
<p>3、使用 string 类的 getline() 成员函数</p>
<p>getline() 是 string 类的一种成员函数，共三个参数：流对象，string 对象，终止字符。一般如果终止字符不写，默认以回车符中止，能接受字符串中的空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string str;</span><br><span class="line">ifstream input(&quot;in_test.txt&quot;);</span><br><span class="line">getline(input, str);</span><br></pre></td></tr></table></figure>
<p>需要包含 <string> 头文件。</string></p>
<h5 id="写文本文件"><a href="#写文本文件" class="headerlink" title="写文本文件"></a>写文本文件</h5><p>写文本文件常用析取器（&gt;&gt;），遇到空格即停止。</p>
<hr>
<h4 id="三、读写二进制文件"><a href="#三、读写二进制文件" class="headerlink" title="三、读写二进制文件"></a>三、读写二进制文件</h4><h5 id="读二进制文件"><a href="#读二进制文件" class="headerlink" title="读二进制文件"></a>读二进制文件</h5><p>1、使用 get() 函数读字符</p>
<p>有多种重载形式，可以读单字符，也可以读到字符串中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifstream &amp;get(char &amp;ch);  // 将字符保存到 ch 中，遇文件尾返回空字符</span><br><span class="line"></span><br><span class="line">int get();  // 返回字符，与文件尾返回 EOF</span><br><span class="line"></span><br><span class="line">ifstream &amp;get(char *buf,int num,char delim=&apos;\n&apos;);  // 将字符串保存到 buf 数组中，遇 delim 结束读取</span><br></pre></td></tr></table></figure>
<p>2、使用 read() 函数读数据块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read(unsigned char *buf,int num);</span><br></pre></td></tr></table></figure>
<p>读 num 个字符到 buf 数组中。</p>
<h5 id="写二进制文件"><a href="#写二进制文件" class="headerlink" title="写二进制文件"></a>写二进制文件</h5><p>1、使用 put() 函数写字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ofstream &amp;put(char ch)；</span><br></pre></td></tr></table></figure>
<p>2、使用 write() 函数写数据块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">write(const unsigned char *buf,int num);</span><br></pre></td></tr></table></figure>
<p>从 buf 指向的位置，写 num 个字符到文件中，buf 的类型是 unsigned char*。</p>
<h5 id="可能用到的函数"><a href="#可能用到的函数" class="headerlink" title="可能用到的函数"></a>可能用到的函数</h5><p>可使用 streamsize gcount() 返回在对象上执行的最后一个未格式化输入操作提取的字符数。若未进行任何操作，则返回 0。若提取了一行 6 个字符，将返回 7（因为有换行符），若提取的是最后一行 6 个字符，将返回 6。</p>
<p>可使用 bool eof() 检测是否到达文件尾。</p>
<p>可使用 bool bad() 检测读写过程中是否发生错误。如文件未打开，或者设备无写入空间。</p>
<p>可使用 bool fail() 检测格式错误。也能检测 bad() 包含的错误类型。</p>
<p>可使用 bool good() 检测文件流状态。</p>
<p>可使用 clear() 重置其他状态检测成员函数。</p>
<hr>
<h4 id="四、文件指针移动"><a href="#四、文件指针移动" class="headerlink" title="四、文件指针移动"></a>四、文件指针移动</h4><p>C++ 中文件流指针分为读指针和写指针，用于改变指针位置的成员函数是 seekg() 和 seekp()。</p>
<p>seekg() 和 seekp() 有两种重载形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\\ 指向绝对位置，通常用于文本文件，也可用于二进制文件</span><br><span class="line">seekg ( pos_type ab_pos );</span><br><span class="line">seekp ( pos_type ab_pos );</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\\ 使用 origin+origin 实现相对位置，最好只用于二进制文件</span><br><span class="line">istream &amp;seekg(off_type offset,seekdir ab_pos);</span><br><span class="line">ostream &amp;seekp(off_type offset,seekdir ab_pos);</span><br></pre></td></tr></table></figure>
<p>streamoff 定义偏移量 offset 所能取得的最大值。</p>
<p>seek_dir 表示移动的基准位置，有以下枚举值：<br>ios::beg：　　文件开头　　<br>ios::cur：　　文件当前位置　　<br>ios::end：　　文件结尾</p>
<p>tellg() 和 tellp() 用于返回当前输入流或者输出流指针的位置。返回值类型是 pos_type。</p>
<hr>
<h4 id="五、缓存同步"><a href="#五、缓存同步" class="headerlink" title="五、缓存同步"></a>五、缓存同步</h4><p>C++ 中对流对象进行操作时，不是直接将流对象与设备（如键盘、屏幕、存储器）直接联系起来，而是通过一个 streambuf 类型的缓存将二者联系起来。</p>
<p>将缓存中的内容输出到指定设备的过程称为同步（synchronization），同步发生在以下几种情况：</p>
<ul>
<li>遇到流中特定的控制符时，如 endl 和 flush。二者都可以用在析取器语句中，flush 还可单独作为成员函数使用。</li>
<li>缓存区满时将自动同步。</li>
<li>文件关闭时，缓存将同步。</li>
<li>调用成员函数 sync()，缓存将同步。</li>
</ul>
<hr>
<h4 id="六、各种流类之间的关系"><a href="#六、各种流类之间的关系" class="headerlink" title="六、各种流类之间的关系"></a>六、各种流类之间的关系</h4><p><img src="https://i.loli.net/2019/04/04/5ca5c9f50056b.png" alt="1554368740541"></p>
<p>basic_ios 是所有流类的基类 ios_base 的模板类。</p>
<p>在 ios_base 的基础上派生出 ios，又在 ios 基础上派生出其他类，详见上图。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 字符串、向量和数组</title>
    <url>//blog/2019/04/11/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<hr>
<p>《C++ primer》笔记</p>
<hr>
<h3 id="一、命名空间的-using-声明"><a href="#一、命名空间的-using-声明" class="headerlink" title="一、命名空间的 using 声明"></a>一、命名空间的 using 声明</h3><p>1、若不用 using 声明命名空间 std，使用库函数需要 std::cin 的形式。</p>
<p>2、头文件不应包含 using 声明。</p>
<a id="more"></a>
<p>3、using 的两种形式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std // 可使用命名空间的所有对象</span><br><span class="line">using std::cin // 只能使用 cin，其他仍加 std::</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="二、标准库类型-string"><a href="#二、标准库类型-string" class="headerlink" title="二、标准库类型 string"></a>二、标准库类型 string</h3><p>1、标准库类型 string 表示可变长的字符序列，使用 string 类型必须先包含 string 头文件。</p>
<p>2、初始化 string 对象的方式<br>拷贝初始化<br>直接初始化<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string s1     // 默认初始化，s1 是一个空串</span><br><span class="line">string s2(s1)  // s2 是 s1 的副本</span><br><span class="line">strings2=s1  // 等价于 s2(s1)，s2 是 s1 的副本 </span><br><span class="line">string s3(&quot;value&quot;) // s3 是字面值“value”的副本，除了字面值最后的那个空字符外</span><br><span class="line">string s3=&quot;value&quot;  // 等价于 s3(&quot;value&quot;)，s3 是字面值&quot;value&quot;的副本</span><br><span class="line">string s4(n，&apos;c&apos;) // 把 s4 初始化为由连续 n 个字符 c 组成的串</span><br></pre></td></tr></table></figure></p>
<p>3、string对象上的操作</p>
<table>
<thead>
<tr>
<th>os &lt;&lt; s</th>
<th>将 s 写到输出流 os 当中，返回 os</th>
</tr>
</thead>
<tbody>
<tr>
<td>is &gt;&gt; s</td>
<td>从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is</td>
</tr>
<tr>
<td>getline(is, s)</td>
<td>从 is 中读取一行赋给 s，返回 is</td>
</tr>
<tr>
<td>s.empty()</td>
<td>s 为空返回 true，否则返回 false</td>
</tr>
<tr>
<td>s.size()</td>
<td>返回 s 中字符的个数</td>
</tr>
<tr>
<td>s[n]</td>
<td>返回 s 中第 n 个字符的引用，位置 n 从 0 计起</td>
</tr>
<tr>
<td>s1 + s2</td>
<td>返回 s1 和 s2 连接后的结果</td>
</tr>
<tr>
<td>s1 = s2</td>
<td>用 s2 的副本代替 s1 中原来的字符</td>
</tr>
<tr>
<td>s1 == s2</td>
<td>如果 s1 和 s2 中所含的字符完全一样，则它们相等；</td>
</tr>
<tr>
<td>s1 != s2</td>
<td>string 对象的相等性判断对字母的大小写敏感</td>
</tr>
<tr>
<td>&lt;，&lt;=，&gt;，&gt;=</td>
<td>利用字符在字典中的顺序进行比较，且对字母的大小写敏感</td>
</tr>
</tbody>
</table>
<p>4、string 会自动忽略输入流开头的空白，从第一个真正的字符开始读起，直到遇见下一处空白为止。</p>
<p>5、使用 getline 可以保留输入流中的空白符。getline 遇到换行符才结束。结果中并不包含换行符。</p>
<p>6、size 函数返回一个 string::size_type 类型的值。size_type 是一个无符号整型数，因此不能在表达式中混用带符号数和无符号数。</p>
<p>7、string 对象可比较大小。</p>
<p>8、标准库允许把字符字面值和字符串字面值转换成 string。string 和字面值可以相加，但两个字符串字面值无法相加。</p>
<p>9、cctype 头文件中定义的一组标准库函数可以判断 string 中的单个字符。</p>
<p>10、C++ 兼容 C 语言的 &lt;name.h&gt; 头文件命名形式为 <cname>，<cname> 中定义的名字从属于 std 命名空间。</cname></cname></p>
<p>11、范围 for 语句可以处理 string对象中的单个元素。</p>
<p>12、访问 string 对象的单个字符有两种方式：下标，和迭代器。</p>
<hr>
<h3 id="三、标准库类型-vector"><a href="#三、标准库类型-vector" class="headerlink" title="三、标准库类型 vector"></a>三、标准库类型 vector</h3><p>1、vector 表示对象的集合，其中所有对象的类型都相同。因为 vector “容纳着”其他对象，所以也叫容器。</p>
<p>2、使用 vector，必须包含 <vector>。</vector></p>
<p>3、vector 是一个类模板。模板本身不是类或函数，可以将模板看作为编译器生成类或函数编写的一份说明。</p>
<p>4、编译器根据模板创建类或函数的过程称为实例化，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。</p>
<p>5、引用不是对象，所以不存在包含引用的 vector。</p>
<p>6、某些编译器可能仍需以老式的声明语句来处理元素为vector的vector对象，如vector&lt;vector<int> &gt;。（两个&gt;&gt;之间有空格）</int></p>
<p>7、初始化 vector 对象的方法<br>| vector<t> v1              | v1 是一个空 vector，它潜在的元素是 T 类型的，执行默认初始化 |<br>| ————————- | ———————————————————– |<br>| vector<t> v2(v1)          | v2 中包含有 v1 所有元素的副本                               |<br>| vector<t> v2=v1           | 等价于v2（v1），v2中包含有v1所有元素的副本                  |<br>| vector<t> v3(n，val)      | v3 包含了 n 个重复的元素，每个元素的值都是 val              |<br>| vector<t> v4(n)           | v4 包含了 n 个重复地执行了值初始化的对象                    |<br>| vector<t> v5{a, b, c…}  | v5包含了初始值个数的元素，每个元素被赋予相应的初始值        |<br>| vector<t> v5={a, b, c…} | 等价于v5{a, b, c…}                                        |</t></t></t></t></t></t></t></p>
<p>8、用花括号 {} 表示列表初始化，用 () 表示数量初始化</p>
<p>9、利用 vector 对象的 push_back 成员函数向其中添加元素。</p>
<p>10、不能使用下标形式添加元素。可用下标访问已存在元素。</p>
<p>确保下标合法的一种有效手段就是尽可能使用范围 for 语句。</p>
<hr>
<h3 id="四、迭代器"><a href="#四、迭代器" class="headerlink" title="四、迭代器"></a>四、迭代器</h3><p>1、所有标准库容器都可以使用迭代器。string 也支持。</p>
<p>2、迭代器提供了对对象的间接访问。</p>
<p>3、有迭代器的类型都有返回迭代器的成员，分别是 begin 和 end。end 返回指向“尾后”元素的迭代器（尾元素的下一位置）。</p>
<p>4、标准迭代器的运算符。</p>
<p>5、拥有迭代器的标准库使用 iterator 和 const_iterator 来表示迭代器的类型。</p>
<p>6、迭代器运算。</p>
<hr>
<h3 id="五、数组"><a href="#五、数组" class="headerlink" title="五、数组"></a>五、数组</h3><p>1、与 vector 不同的是，数组的大小确定不变。</p>
<p>2、定义数组必须制定类型，不能用 auto。</p>
<p>3、不存在引用的数组。</p>
<p>4、不允许用于拷贝和赋值的右值。</p>
<p>5、理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。</p>
<p>6、使用数组下标的时候，通常将其定义为 size_t 类型。</p>
<p>7、使用数组时，编译器一般会把它转换成指针。</p>
<p>8、指针也是迭代器。</p>
<p>9、C 风格的字符串尽量不要在 C++ 中使用，因为不方便，且容易引发程序漏洞。</p>
<p>10、允许使用以空字符结束的字符数组来初始化 string 对象或为 string 对象赋值。</p>
<p>在 string 对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在 string 对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。</p>
<p>11、在 C++ 程序中应尽量使用 vector 和迭代器，避免使用内置数组和指针。尽量使用 string，避免使用 C 风格的基于数组的字符串。</p>
<hr>
<h3 id="六、多维数组"><a href="#六、多维数组" class="headerlink" title="六、多维数组"></a>六、多维数组</h3><p>1、多维数组，即数组的数组。</p>
<p>2、要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。</p>
<p>3、可用类型别名简化多维数组的指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using int_array = int[4];</span><br><span class="line">typedef int int_array[4];</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 数据类型</title>
    <url>//blog/2019/04/11/C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<hr>
<p>《C++ primer》笔记</p>
<hr>
<h3 id="一、基本内置类型"><a href="#一、基本内置类型" class="headerlink" title="一、基本内置类型"></a>一、基本内置类型</h3><p>1、long long 是在 C++11 中新定义的。</p>
<p>2、char 和 signed char 并不一样。</p>
<a id="more"></a>
<p>3、long 一般和 int 有一样的尺寸。</p>
<p>4、算术表达式中不要使用 char 或 bool。char 跨平台容易出问题，要用也明确指明 signed 或 unsigned。</p>
<p>5、浮点运算通常选 double，float 通常精度不够，且二者计算代价相差无几。</p>
<p>6、无符号类型赋值时如果超范围，将取模后赋值。有符号类型赋值时如果超范围，结果是未定义的。</p>
<p>7、不要混用有符号类型和无符号类型，计算时有符号类型会转换成无符号类型。</p>
<p>8、指定常量（字面值）的类型</p>
<p>字面值即常量，每种字面值都有对应的数据类型。</p>
<table>
<thead>
<tr>
<th>L’a’</th>
<th>宽字符型字面值，类型是 wchar_t</th>
</tr>
</thead>
<tbody>
<tr>
<td>u8”hi”</td>
<td>utf-8字符串字面值（utf-8 用 8 位编码一个 Unicode 字符）</td>
</tr>
<tr>
<td>42ULL</td>
<td>无符号整型字面值，类型是 unsigned long long</td>
</tr>
<tr>
<td>1E-3F</td>
<td>单精度浮点型字面值，类型是 float</td>
</tr>
<tr>
<td>3.14159L</td>
<td>扩展精度浮点型字面值，类型是 long double</td>
</tr>
</tbody>
</table>
<p>字符和字符串常量（字面值）<br>| 前缀 | 含义                    | 类型     |<br>| —- | ———————– | ——– |<br>| u    | Unicode 16 字符         | char16_t |<br>| U    | Unicode 32 字符         | char32_t |<br>| L    | 宽字符                  | wchar_t  |<br>| u8   | UTF-8(仅用于字符串常量) | char     |</p>
<p>整型字面值<br>| 后缀     | 最小匹配类型 |<br>| ——– | ———— |<br>| u or U   | unsigned     |<br>| l or L   | long         |<br>| ll or LL | long long    |</p>
<p>浮点型字面值<br>| 后缀   | 类型        |<br>| —— | ———– |<br>| f or F | float       |<br>| l or L | long double |</p>
<p>布尔字面值 和 指针字面值<br>true 和 flase<br>nullptr</p>
<hr>
<h3 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h3><p>1、对 C++ 程序员来说，变量 和 对象 一般可以互换使用。</p>
<p>2、一般情况下，对象指一块能存储数据并具有某种类型的内存空间。</p>
<p>3、C++ 中初始化和赋值是两个完全不同的概念。初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p>
<p>4、四种初始化语句：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int units sold=0; </span><br><span class="line">int units_sold=&#123;0]; </span><br><span class="line">int units_sold&#123;0&#125;;</span><br><span class="line">int units sold(0);</span><br></pre></td></tr></table></figure></p>
<p>使用花括号（列表初始化）的好处是若初始值存在丢失信息的风险，则编译器将报错。如将 long double 型的常量赋给 int 型变量。</p>
<p>5、未初始化的变量将被默认初始化，默认值由变量类型决定，同时定义变量的位置也会对此有影响。<br>内置类型的变量未初始化时，全局变量将被初始化为 0，局部变量将不被初始化。<br>每个类各自决定其初始化对象的方式。</p>
<p>6、变量声明和定义的关系<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern int i;  // 只声明</span><br><span class="line">extern int i = 1;  // 声明并定义</span><br><span class="line">int j;           // 声明并定义</span><br></pre></td></tr></table></figure></p>
<p>函数内部初始化一个由 extern 标记的变量，将引发错误。</p>
<p>7、标识符对大小写敏感。<br>必须以字母或下划线开头，不能数字开头。<br>不能出现两个连续的下划线。<br>不能下划线紧连大写字母开头。<br>定义在函数体外的标识符不能以下划线开头。</p>
<p>8、C++ 关键字</p>
<p>9、C++ 操作符替代名</p>
<p>10、名字的作用域<br>名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。</p>
<p>全局作用域、块作用域。</p>
<p>作用域可嵌套，内层作用域可以重新定义外层作用域已有的名字。</p>
<p>使用全部变量的函数不应再在内部定义同名局部变量。</p>
<hr>
<h3 id="三、复合类型"><a href="#三、复合类型" class="headerlink" title="三、复合类型"></a>三、复合类型</h3><p>1、一条声明语句由一个基本数据类型和一个紧随其后的声明符列表组成。</p>
<p>2、引用，有左值引用和右值引用，通常单说“引用”是指左值引用。符号为“&amp;”。</p>
<p>出现在表达式中，&amp; 是取地址符。<br>出现在声明中，且紧跟在 数据类型之后，&amp; 是引用符。（若出现在初始化的表示式右侧，仍是取地址符）</p>
<p>引用即别名。</p>
<p>引用必须被初始化，因为程序把应用和它的初始值绑定在一起，而不是拷贝，无法令应用重新绑定到另外一个对象。</p>
<p>不能定义引用的引用，因为引用不是一个对象，只是一个别名。</p>
<p>引用只能绑定在对象上，不能与某个常量或表达式的值绑定在一起。</p>
<p>3、指针<br>指针本身是一个对象，允许赋值和拷贝，且在生命周期内可以指向不同对象，可以不初始化。</p>
<p>不能定义指向引用的指针，因为引用不是对象，没有实际地址。</p>
<p>被指针指向的对象，可通过解引用符（*）来访问。解引用符适用于有效指针。</p>
<p>4、空指针的生成方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p1 = nullptr;  // 等价于 int *p1 = 0;</span><br><span class="line">int *p2 = 0;   // 直接将 p2 初始化为字面常量 0</span><br><span class="line">// 需要包含 cstdlib 头文件</span><br><span class="line">int *p3 = NULL;  // 等价于 int *p3 = 0;</span><br></pre></td></tr></table></figure>
<p>尽量用 nullptr，避免用 NULL。</p>
<p>5、void* 指针<br>可用于存放任意对象的地址。</p>
<p>能进行的操作有限：与其他指针比较、作为函数的输入或输出、赋值给另一个 void* 指针。</p>
<p>不能直接操作 void* 指针所指的对象，因为不知道所指对象的类型。</p>
<p>6、<code>int* p, q;</code> 只将 p 声明为 int 型指针，而 q 是 int 型变量，因为该声明的实质是 <code>int *p, q;</code> 基本数据类型是 int，而非 int*。</p>
<p>7、可以定义指向指针的引用。</p>
<p>8、面对一条比较复杂的指针或引用的声明语句，从右向左阅读有助于弄清其真实含义。</p>
<hr>
<h3 id="四、const-限定符"><a href="#四、const-限定符" class="headerlink" title="四、const 限定符"></a>四、const 限定符</h3><p>1、const 对象必须初始化，且不能再做修改。</p>
<p>默认状态下，const 对象仅在文件内有效。在其他文件中使用需声明。也可以加上 extern，并在头文件中声名。</p>
<p>2、对 const 对象引用后，不能（通过引用）修改所绑定的对象。</p>
<p>3、指向 const 对象的指针，不能（通过指针）改变其所指对象的值。</p>
<p>4、<em> const 是 指针常量。<br>const </em> 是 常量指针。<br>从右往左看。</p>
<p>5、顶层 const 表示指针本身是个常量。更一般的，顶层 const 可以表示任意的对象是常量，适用于任何数据类型。<br>底层 const 表示指针所指的对象是一个常量。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int &amp;r = ci;  // 用于声明引用的 const 都是底层 const</span><br></pre></td></tr></table></figure></p>
<p>执行对象的拷贝操作时，常量是顶层 const 还是底层 const 区别明显。</p>
<p>6、如果认定变量是一个常量表达式，可以声明成 constexpr 类型。</p>
<p>7、常量表达式 和 constexpr 变量。</p>
<p>8、在 constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int *p=nullptr； // p是一个指向整型常量的指针constexpr int *q=nullptr； // q是一个指向整数的常量指针</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="五、处理类型"><a href="#五、处理类型" class="headerlink" title="五、处理类型"></a>五、处理类型</h3><p>1、两种定义类型别名的方法</p>
<ul>
<li><p>关键字 typedef：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef double wages；// wages 是 double 的同义词typedef wages base，*p；// base 是 double 的同义词，p 是 double* 的同义词</span><br></pre></td></tr></table></figure>
</li>
<li><p>别名声明（关键字 using）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using SI = Sales_item；// SI 是 Sales_item 的同义词</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2、将类型别名替换成本来的样子再理解语句是错误的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef char *pstring；// pstring 是 char * 的别名</span><br><span class="line">const pstring cstr = 0；// cstr 是指向 char 的常量指针</span><br></pre></td></tr></table></figure></p>
<p>替换后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const char *cstr = 0；// 是对 const pstring cstr 的错误理解，此处 cstr 是指向 char 型常量的指针</span><br></pre></td></tr></table></figure></p>
<p>前者 const 修饰 *，后者 const 修饰 char。</p>
<p>3、auto 类型说明符可根据表达式的运算结果分析变量的类型，用 auto 定义的变量必须有初始值。</p>
<p>auto 一般会忽略掉顶层 const，而保留底层 const。如果希望推断出的 auto 类型是一个顶层 const，需要明确指出。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const auto f=ci；//ci的推演类型是int，f是const int</span><br></pre></td></tr></table></figure></p>
<p>设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。</p>
<p>4、decltype 与 auto 类似，但它值分析表达式并得到类型，却不实际计算表达式的值，也就不用表达式的值初始化变量。</p>
<p>decltype 处理顶层 const 和引用的方式与 auto 有些许不同。如果 decltype 使用的表达式是一个变量，则 decltype 返回该变量的类型（包括顶层 const 和引用在内）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int ci = 0，&amp;cj = ci；</span><br><span class="line">decltype（ci）x = 0；// x 的类型是 const int </span><br><span class="line">decltype（cj）y = x；// y 的类型是 const ints，y 绑定到变量 x </span><br><span class="line">decltype（cj）z；// 错误：z 是一个引用，必须初始化</span><br></pre></td></tr></table></figure>
<p>decltype 后不加括号，得到的是该变量的类型，如果加了括号，将被当成一个表达式。<br><strong>decltype（（variable））（注意是双层括号）的结果永远是引用，而decltype（variable）结果只有当variable本身就是一个引用时才是引用。</strong></p>
<hr>
<h3 id="六、自定义数据结构"><a href="#六、自定义数据结构" class="headerlink" title="六、自定义数据结构"></a>六、自定义数据结构</h3><p>1、类内部定义的名字必须唯一，但可以与类外部定义的名字重复。类的花括号形成了一个新的作用域。</p>
<p>2、一般不要把对象的定义和类的定义放在一起。</p>
<p>3、string 类型是字符的序列，操作有 &gt;&gt;、&lt;&lt; 和 ==，代表读入、写出和比较字符串。</p>
<p>4、类通常被定义在头文件中，且类所在头文件的名字应与类的名字一样。</p>
<p>5、预处理变量无视 C++ 语言中关于作用域的规则。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 数组内容初始化</title>
    <url>//blog/2019/04/11/C-%E6%95%B0%E7%BB%84%E5%86%85%E5%AE%B9%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<hr>
<p><strong>使用 memset 函数</strong></p>
<p>需要包含 <cstring> 或 &lt;string.h&gt; 或 &lt;memory.h&gt;</cstring></p>
<p>原型：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memset(void *s,int ch,size_t n);</span><br></pre></td></tr></table></figure>
<ul>
<li>void *s 传入数组名或某指针</li>
<li>ch 传入欲初始化的内容</li>
<li>n 传入欲初始化的地址范围（以字节为单位）</li>
</ul>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memset(bucket, 0, len*sizeof(ElemType_SqList));</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 查看数据类型</title>
    <url>//blog/2019/04/11/C-%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<hr>
<h4 id="使用-typeid-查看数据类型"><a href="#使用-typeid-查看数据类型" class="headerlink" title="使用 typeid() 查看数据类型"></a>使用 typeid() 查看数据类型</h4><p>使用 typeid() 需要包含 <typeinfo> 头文件 </typeinfo></p>
<p>使用方法：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">extern const char test_set_path[] = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">int avc = 0;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; typeid(avc).name() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; typeid(test_set_path).name() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; typeid(int).name() &lt;&lt; endl;	   </span><br><span class="line">    cout &lt;&lt; typeid(char).name() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; typeid(float).name() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; typeid(double).name() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; typeid(char[]).name() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; typeid(char[][2]).name() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; typeid(int[]).name() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; typeid(int[][2]).name() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; typeid(char*).name() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; typeid(int*).name() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; typeid(typeid(char).name()).name() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; typeid(typeid(int).name()).name() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; typeid(string).name() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i </span><br><span class="line">A4_c   </span><br><span class="line">i          </span><br><span class="line">c         </span><br><span class="line">f           </span><br><span class="line">d</span><br><span class="line">A_c</span><br><span class="line">A_A2_c</span><br><span class="line">A_i</span><br><span class="line">A_A2_i</span><br><span class="line">Pc</span><br><span class="line">Pi</span><br><span class="line">PKc</span><br><span class="line">PKc</span><br><span class="line">Ss</span><br></pre></td></tr></table></figure>
<p>可见，typeid().name() 的返回值类型是 PKC，即 <code>const char*</code>。</p>
<p>如果只需要对类型进行对比，可以直接 <code>if(typeid(a) == typeid(b))</code>。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 类的写法</title>
    <url>//blog/2019/04/11/C-%E7%B1%BB%E7%9A%84%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<hr>
<h4 id="一、类的声明"><a href="#一、类的声明" class="headerlink" title="一、类的声明"></a>一、类的声明</h4><p>类的声明可以放在头文件中，如：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    // 成员变量</span><br><span class="line">    char *name;</span><br><span class="line">    string stu_num;   // 学号</span><br><span class="line">    int age;</span><br><span class="line">    float score;</span><br><span class="line">    </span><br><span class="line">    // 成员函数</span><br><span class="line">    void Print_Info();  // 输出该生的信息</span><br><span class="line"></span><br><span class="line">&#125;; // 要加分号</span><br></pre></td></tr></table></figure>
<p>使用 class 关键字定义类。类的内部包括成员变量和成员函数。</p>
<p>类只是一个模板（Template），编译后不占用内存，因此不能在声明或定义时对成员变量进行初始化，必须创建对象后才能赋值。</p>
<p>根据成员的属性，可分为三类：</p>
<ul>
<li>public 公有，外部可访问</li>
<li>pravite 私有，外部不可访问，不可在派生类中使用</li>
<li>protected 受保护，外部不可访问，可在派生类中使用</li>
</ul>
<p>以上三种修饰符都只能修饰类成员，不能修饰类，且可以在类中多次出现，但为了直观简洁，最好每种只出现一次。</p>
<p>在类的内部，三种类型的成员都可以互相访问，但在类的外部，只能通过对象访问 public 属性的成员。基类中的 protected 成员可以在派生类中使用。访问权限由高到低：public &gt; protected &gt; private。</p>
<p>private 关键字的作用在于隐藏类的内部实现，不希望外部知道、只在类内使用或对外部没有影响的成员都建议声明为 private。需要对外暴露的接口都声明为 public。如果没有写 public 和 private，则默认 private。</p>
<p>另外，类的声明和定义可以写在一起，即在声明时就定义成员函数，也可以把成员函数的定义放在类声明之外，声明中只对成员函数做声明，而不做定义。</p>
<hr>
<h4 id="二、类的定义"><a href="#二、类的定义" class="headerlink" title="二、类的定义"></a>二、类的定义</h4><p>类的定义通常即指成员函数的定义，一般可以放在放在 .cpp 文件中。成员函数定义在类外时，必须加上 <code>::</code>（域解析符，或作用域限定符），用来连接类名和函数名，指明当前函数属于哪个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Student::Print_Info()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;姓名&quot; &lt;&lt; &quot;: &quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;学号&quot; &lt;&lt; &quot;: &quot; &lt;&lt; stu_num &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;年龄&quot; &lt;&lt; &quot;: &quot; &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;成绩&quot; &lt;&lt; &quot;: &quot; &lt;&lt; score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即便成员函数定义在类外，也必须在类中作声明，且类的位置应在函数定义之前。</p>
<p>若将成员函数定义在类内，则默认其位内联函数（将函数调用处用函数体替代），若想将定义在类外的成员函数变成内联函数，则在函数前加 <code>inline</code> 即可。</p>
<hr>
<h4 id="三、创建对象"><a href="#三、创建对象" class="headerlink" title="三、创建对象"></a>三、创建对象</h4><h5 id="1、对象声明-定义"><a href="#1、对象声明-定义" class="headerlink" title="1、对象声明/定义"></a>1、对象声明/定义</h5><p>类可以看做是一种数据类型，类似于 C 语言中声明了一个新的结构体类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student LiLei;             // 创建单个对象</span><br><span class="line">Student HanMeimei;           // 创建单个对象，class 可省略</span><br><span class="line">Student students[100];        // 创建对象数组</span><br></pre></td></tr></table></figure>
<h5 id="2、访问成员"><a href="#2、访问成员" class="headerlink" title="2、访问成员"></a>2、访问成员</h5><p>对象的访问与结构体成员访问类似，使用 <code>.</code> 来访问：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    Student LiLei;</span><br><span class="line">    class Student HanMeimei;</span><br><span class="line">    Student students[100];</span><br><span class="line"></span><br><span class="line">    LiLei.name = (char*)&quot;LiLei&quot;;</span><br><span class="line">    LiLei.stu_num = &quot;010013&quot;;</span><br><span class="line">    LiLei.age = 23;</span><br><span class="line">    LiLei.score = 90.5;</span><br><span class="line"></span><br><span class="line">    LiLei.Print_Info();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3、使用对象指针"><a href="#3、使用对象指针" class="headerlink" title="3、使用对象指针"></a>3、使用对象指针</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 静态分配，即指向栈中已创建的对象</span><br><span class="line">Student LiLei;</span><br><span class="line">Student *pStu = &amp;LiLei;</span><br><span class="line"></span><br><span class="line">//动态分配，即通过 new 在堆上动态创建对象</span><br><span class="line">Student *pStu1 = new Student; // 需匹配相应的 delete 进行回收</span><br></pre></td></tr></table></figure>
<p>栈中的对象都有名字，且栈内存由程序进行管理，不是必须使用指针指向它。而堆内存由程序员管理，且创建出来的对象没有名字，所以必须有指针指向它，才能进行操作。</p>
<p>动态分配的对象使用完毕后必须用 delete 进行回收释放。</p>
<p>通过指针访问成员：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student HanMeimei;</span><br><span class="line">Student *pStu = &amp;HanMeimei;</span><br><span class="line"></span><br><span class="line">pStu -&gt; name = (char*)&quot;HanMeimei&quot;;</span><br><span class="line">pStu -&gt; stu_num = &quot;010014&quot;;</span><br><span class="line">pStu -&gt; age = 23;</span><br><span class="line">pStu -&gt; score = 91.5;</span><br><span class="line">pStu -&gt; Print_Info();</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="四、类的封装"><a href="#四、类的封装" class="headerlink" title="四、类的封装"></a>四、类的封装</h4><p>实际项目开发中，成员变量以及只在类内部使用的成员函数都建议声明为 private，而只将允许通过对象调用的成员函数声明为 public。</p>
<p>一般约定，private 的成员变量以 m_ 开头，以区别于成员函数的变量。private 的成员变量的作用域是整个类内部。</p>
<p>则相应的可将上面的类修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	void Set_Name(char *name);</span><br><span class="line">	void Set_StuNum(string m_stu_num);</span><br><span class="line">	void Set_Age(int age);</span><br><span class="line">	void Set_Score(float score);</span><br><span class="line">    void Print_Info();  // 输出该生的信息</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	char *m_name;</span><br><span class="line">    string m_stu_num;   // 学号</span><br><span class="line">    int m_age;</span><br><span class="line">    float m_score;</span><br><span class="line"></span><br><span class="line">&#125;; // 要加分号</span><br><span class="line"></span><br><span class="line">void Student::Set_Name(char *name)&#123;</span><br><span class="line"></span><br><span class="line">	m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Student::Set_StuNum(string stu_num)&#123;</span><br><span class="line"></span><br><span class="line">	m_stu_num = stu_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Student::Set_Age(int age)&#123;</span><br><span class="line"></span><br><span class="line">	m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Student::Set_Score(float score)&#123;</span><br><span class="line"></span><br><span class="line">	m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Student::Print_Info()&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;姓名&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;学号&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_stu_num &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;年龄&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;成绩&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_score &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	Student LiLei;</span><br><span class="line">	class Student HanMeimei;</span><br><span class="line">	Student students[100];</span><br><span class="line"></span><br><span class="line">	Student *pStu = &amp;HanMeimei;</span><br><span class="line">	// Student *pStu1 = new Student;</span><br><span class="line">	// delete pStu1;</span><br><span class="line"></span><br><span class="line">	LiLei.Set_Name((char*)&quot;LiLei&quot;);</span><br><span class="line">	LiLei.Set_StuNum(&quot;010013&quot;);</span><br><span class="line">	LiLei.Set_Age(23);</span><br><span class="line">	LiLei.Set_Score(90.5);</span><br><span class="line"></span><br><span class="line">	pStu -&gt; Set_Name((char*)&quot;HanMeimei&quot;);</span><br><span class="line">	pStu -&gt; Set_StuNum(&quot;010014&quot;);</span><br><span class="line">	pStu -&gt; Set_Age(23);</span><br><span class="line">	pStu -&gt; Set_Score(91.5);</span><br><span class="line"></span><br><span class="line">	LiLei.Print_Info();</span><br><span class="line">	pStu -&gt; Print_Info();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里因为成员变量的属性改为了 private，不能通过对象从外部修改，因此增加了 public 属性的 set 函数来修改其值，相应的可以定义 get 函数来获取相应的成员变量值。</p>
<p>另外也可以通过定义构造函数来初始化成员变量。</p>
<hr>
<h4 id="五、构造函数"><a href="#五、构造函数" class="headerlink" title="五、构造函数"></a>五、构造函数</h4><h5 id="1、构造函数"><a href="#1、构造函数" class="headerlink" title="1、构造函数"></a>1、构造函数</h5><p>可通过定义构造函数，使得类在实例化为对象时，可以通过传参来初始化。构造函数没有返回值，且必须是 public 属性的。</p>
<p>构造函数没有返回值，也没有 return 语句，且构造函数名应与类名同名。</p>
<p>在栈上创建对象时，实参位于对象名之后，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student LiLei((char *)&quot;LiLei&quot;, &quot;010013&quot;, 23, 90.5);</span><br></pre></td></tr></table></figure>
<p>在堆上创建对象时，实参位于类名之后，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student *pStu1 = new Student(&quot;LiHua&quot;, &quot;010015&quot;, 23, 92.5);</span><br></pre></td></tr></table></figure></p>
<p>构造函数支持重载，可以重载多个构造函数，创建对象时根据实参判断调用哪一个构造函数。</p>
<p>一旦在类中定义了构造函数，构造函数的调用将是强制性的，创建时一定会调用，否则将是错误的。</p>
<p>如果用户没有定义构造函数，编译器会自动生成一个默认的构造函数。</p>
<p>如果定义了没有参数的构造函数，在创建对象时，可以不用写括号（用户不定义构造函数时即是这样调用了默认构造函数），例如，如果定义了 <code>Student::Student();</code>，则创建对象时，可以写成 <code>Student stu();</code> 或 <code>Student stu;</code>。</p>
<p>例程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Student&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	Student(char* name, string stu_num, int age, float score);</span><br><span class="line">	Student();</span><br><span class="line">	void Set_Name(char *name);</span><br><span class="line">	void Set_StuNum(string m_stu_num);</span><br><span class="line">	void Set_Age(int age);</span><br><span class="line">	void Set_Score(float score);</span><br><span class="line">	void Print_Info();  // 输出该生的信息</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	char *m_name;</span><br><span class="line">	string m_stu_num;   // 学号</span><br><span class="line">	int m_age;</span><br><span class="line">	float m_score;</span><br><span class="line"></span><br><span class="line">&#125;; // 要加分号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Student::Student(char* name, string stu_num, int age, float score)&#123;</span><br><span class="line"></span><br><span class="line">	m_name = name;</span><br><span class="line">	m_stu_num = stu_num;</span><br><span class="line">	m_age = age;</span><br><span class="line">	m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student::Student()&#123;</span><br><span class="line"></span><br><span class="line">	m_name = NULL;</span><br><span class="line">	m_stu_num = &quot;NULL&quot;;</span><br><span class="line">	m_age = 0;</span><br><span class="line">	m_score = 0.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Student::Set_Name(char *name)&#123;</span><br><span class="line"></span><br><span class="line">	m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Student::Set_StuNum(string stu_num)&#123;</span><br><span class="line"></span><br><span class="line">	m_stu_num = stu_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Student::Set_Age(int age)&#123;</span><br><span class="line"></span><br><span class="line">	m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Student::Set_Score(float score)&#123;</span><br><span class="line"></span><br><span class="line">	m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Student::Print_Info()&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;姓名&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_name &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;学号&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_stu_num &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;年龄&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;成绩&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_score &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	Student LiLei((char *)&quot;LiLei&quot;, &quot;010013&quot;, 23, 90.5);</span><br><span class="line">	class Student HanMeimei((char *)&quot;HanMeimei&quot;, &quot;010014&quot;, 23, 91.5);</span><br><span class="line">	//Student students[100]; //此处将报错，因为没有调用构造函数</span><br><span class="line"></span><br><span class="line">	Student *pStu = &amp;HanMeimei;</span><br><span class="line">	// Student *pStu1 = new Student(&quot;LiHua&quot;, &quot;010015&quot;, 23, 92.5);</span><br><span class="line">	// delete pStu1;</span><br><span class="line"></span><br><span class="line">	LiLei.Print_Info();</span><br><span class="line">	pStu -&gt; Print_Info();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2、参数初始化表"><a href="#2、参数初始化表" class="headerlink" title="2、参数初始化表"></a>2、参数初始化表</h5><p>构造函数除了可以像正常函数一样使用函数体对成员变量一一赋值，还可以通过参数初始化表进行初始化。这种方法书写方便，效率上并无提升。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student::Student(char* name, string stu_num, int age, float score)</span><br><span class="line">: m_name(name), m_stu_num(stu_num), m_age(age), m_score(score)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数初始化表可以用于全部成员变量，也可以只用于部分成员变量。参数初始化表的初始化顺序只与类中成员变量的顺序有关。</p>
<p><strong>const 成员变量只能用参数初始化表的方式来初始化。</strong></p>
<hr>
<h4 id="六、析构函数"><a href="#六、析构函数" class="headerlink" title="六、析构函数"></a>六、析构函数</h4><p>析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要显示调用（也无法显示调用），而是在销毁对象时自动执行。</p>
<p>与构造函数类似，析构函数的函数名与类名相同，但要在类名前加一个 <code>~</code> 符号。</p>
<p>析构函数没有参数，不能被重载，一个类只能有一个析构函数。如果用户不定义，编译器会自动生成一个默认析构函数。</p>
<p>例如在构造函数中分配了堆内存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m_array = new int[len];</span><br></pre></td></tr></table></figure>
<p>则在析构函数中需要释放相应的内存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete[] m_array;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="七、this-指针"><a href="#七、this-指针" class="headerlink" title="七、this 指针"></a>七、this 指针</h4><p>this 是一个 C++ 关键字，用于指向当前对象，通过它可以访问当前对象的所有成员。</p>
<p>this 是一个 const 指针，只能用在类的内部。通常可用在成员变量与成员函数的参数重名时。</p>
<p>用 <code>this -&gt; 成员变量</code>  表示该变量是成员变量，而不是函数参数。</p>
<p>this 其实是存在对象内部的存放对象地址的 const 指针变量，所以只能用在内部，只有通过对象调用成员函数时才给 this 赋值。</p>
<p>成员函数最终会被变异成与对象无关的普通函数，对象只保留成员变量，因此通过 this 将成员函数与成员变量进行关联。</p>
<hr>
<h4 id="八、静态成员变量"><a href="#八、静态成员变量" class="headerlink" title="八、静态成员变量"></a>八、静态成员变量</h4><p>不同对象之间的相同成员变量是相互独立的，若想要不同的对象共享数据，可使用 static 定义静态成员变量。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">public:</span><br><span class="line">    static string m_teacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态成员变量必须在类声明的外部进行初始化（放在构造函数中也不行），且必须带上数据类型，形式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Student::m_teacher = &quot;Miss Wang&quot;;</span><br></pre></td></tr></table></figure>
<p>静态成员变量有三种访问方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过类访问</span><br><span class="line">Student::m_teacher = &quot;Mr Li&quot;;</span><br><span class="line"></span><br><span class="line">// 通过对象访问</span><br><span class="line">Student LiLei((char *)&quot;LiLei&quot;, &quot;010013&quot;, 23, 90.5);</span><br><span class="line">LiLei.m_teacher = &quot;Miss Zhao&quot;;</span><br><span class="line"></span><br><span class="line">// 通过对象指针访问</span><br><span class="line">Student *pStu = new Student(&quot;HanMeimei&quot;, &quot;010014&quot;, 23, 92.5);</span><br><span class="line">pStu -&gt; m_teacher = &quot;Mr Gao&quot;;</span><br></pre></td></tr></table></figure>
<p>static 静态成员变量不属于某个对象，而属于类，因此不占用对象内存，而在所有对象外部（内存中的全局数据区）开辟内存，不创建对象也可以访问。</p>
<p>静态成员变量的访问需要遵循 public、private、protected 关键字的访问权限限制，如果属性设为 private，将不能在外部进行访问，只能通过成员函数访问。</p>
<hr>
<h4 id="九、静态成员函数"><a href="#九、静态成员函数" class="headerlink" title="九、静态成员函数"></a>九、静态成员函数</h4><p>在类中，除了静态成员变量，还可以声明静态成员函数。</p>
<p>静态成员函数只能访问静态成员，</p>
<p>静态成员函数没有 this 指针，不知道指向哪个对象，可以通过类来直接调用（也可以通过对象调用）。同时，无法访问对象的（普通）成员变量和调用对象的（普通）成员函数，只能访问静态成员变量和调用静态成员函数。</p>
<p>和静态成员变量类似，静态成员函数在声明时要加 static，在定义时不能加 static。</p>
<p><strong>静态成员函数的主要目的就是访问静态成员。</strong>（当然普通成员函数也可以访问静态成员，但是加上 static 意义更明确）</p>
<hr>
<h4 id="十、类中的-const-关键字"><a href="#十、类中的-const-关键字" class="headerlink" title="十、类中的 const 关键字"></a>十、类中的 const 关键字</h4><p>如果不希望数据被修改，可以用 const 修饰，包括成员变量、成员函数和对象。</p>
<h5 id="1、const-成员变量"><a href="#1、const-成员变量" class="headerlink" title="1、const 成员变量"></a>1、const 成员变量</h5><p>const 成员变量的初始化只能通过参数初始化表。初始化之后不能修改。</p>
<h5 id="2、const-成员函数"><a href="#2、const-成员函数" class="headerlink" title="2、const 成员函数"></a>2、const 成员函数</h5><p>const 成员函数<strong>可以使用类中的所有成员变量，但是不能修改它们的值</strong>。</p>
<p>const 成员函数<strong>定义和声明时都要在函数头部的结尾处加上 const 关键字</strong>，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float Get_Score() const;  // 声明</span><br><span class="line"></span><br><span class="line">float Student::Get_Score() const&#123;  // 定义</span><br><span class="line">    return m_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3、const-对象"><a href="#3、const-对象" class="headerlink" title="3、const 对象"></a>3、const 对象</h5><p>const 对象也叫常对象，常对象只能访问类的 const 成员。</p>
<p>定义常对象时，const 关键字和类名谁前谁后都可以，通常把 const 放在前。</p>
<hr>
<h4 id="十一、friend-友元函数和友元类"><a href="#十一、friend-友元函数和友元类" class="headerlink" title="十一、friend 友元函数和友元类"></a>十一、friend 友元函数和友元类</h4><p>通过对象可以访问 public 成员，只有本类中的函数可以访问本类的 private 成员。</p>
<p>通过友元（friend），可以让其他类中的成员函数以及全局范围的函数访问当前类的 private 成员。</p>
<p>友元的关系是单向的。友元的关系不能传递。</p>
<p>一般不建议声明友元类，声明友元函数更为安全。</p>
<h5 id="1、友元函数"><a href="#1、友元函数" class="headerlink" title="1、友元函数"></a>1、友元函数</h5><p>在当前类以外定义的、不属于当前类的函数，也可以在本类中声名，但要在前面加 friend 关键字，以构成友元函数。友元函数可以访问当前类中的所有成员，包括 public、private、protected 属性的。</p>
<p>调用友元函数时，不需要通过对象，直接按照普通函数的方式调用即可。</p>
<p>友元函数不能直接访问成员，需要通过对象或对象的指针来访问。</p>
<p>类 A 使用其他类 B 的成员函数作为友元函数的时候，需要提前声明类 A。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">friend void Get_Info(Student *pStu);  // 将全局函数作为友元函数</span><br><span class="line"></span><br><span class="line">friend string Student::Get_Teacher();  // 将 Student 类 的 Get_Teacher 函数作为友元函数</span><br></pre></td></tr></table></figure>
<p>一个函数可以被多个类声明为友元函数。</p>
<h5 id="2、友元类"><a href="#2、友元类" class="headerlink" title="2、友元类"></a>2、友元类</h5><p>友元类中的所有成员函数都是另一个类的友元函数。</p>
<p>友元类声明语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">friend class Student;</span><br></pre></td></tr></table></figure>
<h4 id="十二、类和结构体的区别"><a href="#十二、类和结构体的区别" class="headerlink" title="十二、类和结构体的区别"></a>十二、类和结构体的区别</h4><p>相比较 C 语言而言，C++ 对 struct 进行了扩充，使其可以定义成员函数，因此也具备定义一个类的能力。但是在 C++ 中，最好还是使用 class 来定义类。</p>
<p>class 的成员默认是 private 属性，struct 的成员默认是 public 属性。</p>
<p>class 继承默认是 private 继承，struct 的继承默认是 public继承。</p>
<p>class 可使用模板，struct 不能使用模板。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫网页基础</title>
    <url>//blog/2019/04/12/%E7%88%AC%E8%99%AB%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<hr>
<p>《Python 网络爬虫开发实战（崔庆才著）》笔记</p>
<hr>
<h4 id="一、HTTP-基本原理"><a href="#一、HTTP-基本原理" class="headerlink" title="一、HTTP 基本原理"></a>一、HTTP 基本原理</h4><h5 id="1、URI-和-URL"><a href="#1、URI-和-URL" class="headerlink" title="1、URI 和 URL"></a>1、URI 和 URL</h5><a id="more"></a>
<ul>
<li>URI（Uniform Resource Identifier，统一资源标志符）</li>
<li>URL（Universal Resource Locator，统一资源定位符）</li>
</ul>
<p>URI 包括 URL 和 URN（Universal Resource Name，统一资源名称），URL 是 URI 的子集。</p>
<p>URN 用的较少，所以几乎所有的 URI 都是 URL。</p>
<p>URL/URI 唯一指定一个资源，包括：</p>
<ul>
<li>访问协议</li>
<li>访问路径（根目录）</li>
<li>资源名称</li>
</ul>
<h5 id="2、超文本"><a href="#2、超文本" class="headerlink" title="2、超文本"></a>2、超文本</h5><p>网页的源代码就可以称作超文本。</p>
<h5 id="3、HTTP-和-HTTPS"><a href="#3、HTTP-和-HTTPS" class="headerlink" title="3、HTTP 和 HTTPS"></a>3、HTTP 和 HTTPS</h5><p>常见协议类型：</p>
<ul>
<li>http（Hyper Text Transfer Protocol）</li>
<li>https（Hyper Text Transfer Protocol over Secure Socket Layer）</li>
<li>ftp</li>
<li>sftp</li>
<li>smb</li>
</ul>
<p>爬虫主要爬取 http 或 https 协议。</p>
<p>http 协议用于从网络传输超文本数据到本地浏览器的传送协议，能保证高效而准确地传送超文本文档。</p>
<p>https 协议是以安全为目标的 HTTP 通道，在 HTTP 下加入 SSL 层，是 HTTP 的安全版。</p>
<p>SSL 的主要作用有两种：</p>
<ul>
<li>建立一个信息安全通道来保证数据传输的安全</li>
<li>确认网站的真实性，使用 HTTPS 的网站，都可以点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可通过 CA 机构颁发的安全签章来查询</li>
</ul>
<p>某些网站虽使用了 HTTPS 协议，但证书不是被 CA 机构认证的，爬取时需要设置忽略证书的选项，否则会提示 SSL 连接错误。</p>
<h5 id="4、HTTP-请求过程"><a href="#4、HTTP-请求过程" class="headerlink" title="4、HTTP 请求过程"></a>4、HTTP 请求过程</h5><p>浏览器中输入一个 URL，按下回车之后，浏览器向网站所在的服务器发送一个请求，网站服务器接收到请求后进行解析和处理，然后返回对应的响应，接着传回给浏览器。响应里包含了页面的源代码等内容。</p>
<h5 id="5、请求"><a href="#5、请求" class="headerlink" title="5、请求"></a>5、请求</h5><p>请求由客户端向服务器发出，可分为 4 部分内容：</p>
<ul>
<li>请求方法（Request Method）</li>
<li>请求的网址（Request URL）</li>
<li>请求头（Request Headers）</li>
<li>请求体（Request Body）</li>
</ul>
<p><strong>（1）请求方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>请求页面，并返回页面内容</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似 GET 请求，但返回的响应中没有具体内容，用于获取报头</td>
</tr>
<tr>
<td>POST</td>
<td>大多用于提交表单或上传文件，数据包含在请求体中</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定文档中的内容</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的页面</td>
</tr>
<tr>
<td>CONNECT</td>
<td>把服务器当跳板，让服务器代替客户端访问其他网页</td>
</tr>
<tr>
<td>OPTINONS</td>
<td>允许客户端查看服务器的性能</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
</tbody>
</table>
<p>其中常用的是 GET 和 POST。</p>
<p>在浏览器直接输入 URL 并回车，发起的是 GET 请求。</p>
<p>POST 请求大多在表单提交时发起。如登录时需要提交用户名和密码，如果用 GET 方法，密码将暴露在 URL 中，又或者上传文件时，由于文件内容较大，也会选用 POST 方式。</p>
<p>GET 和 POST 请求方法的区别为：</p>
<ul>
<li>GET 请求中的参数包含在 URL 里，数据可以在 URL 中看到。POST 请求的 URL 不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中</li>
<li>GET 请求提交的数据最多只有 1024 字节，而 POST 方式没有限制。</li>
</ul>
<p><strong>（2）请求的网址</strong></p>
<p>即 URL，唯一确定欲请求的资源。</p>
<p><strong>（3）请求头</strong></p>
<p>用于说明服务器要使用的附加信息。常用的头信息有：</p>
<ul>
<li>Accept：请求报头域，用于指定客户端可接受哪些类型的信息</li>
<li>Accept-Language：指定客户端可接受的语言类型</li>
<li>Accept-Encoding：指定客户端可接受的内容编码</li>
<li>Cookies：网站为了辨别用户进行会话跟踪而存储在用户本地的数据，主要功能是维持当前访问对话</li>
<li>Referer：用于标识这个请求是从哪个页面发来的，服务器可拿到这一信息并做相应处理，如做来源统计、防盗链处理等</li>
<li>User-Agent：用户代理（UA），可使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。做爬虫时加上此信息，可伪装成浏览器</li>
<li>Content-Type：也叫互联网媒体类型或者 MIME 类型，在 HTTP 协议消息头中，用来表示具体请求中的媒体类型信息</li>
</ul>
<p><strong>（4）请求体</strong></p>
<p>一般承载的内容是 POST 请求中的表单数据，GET 请求的请求体为空</p>
<p>Content-Type 和 POST 提交数据方式的关系</p>
<table>
<thead>
<tr>
<th>Content-Type</th>
<th>提交数据的方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>application/x-www-form-urlencoded</td>
<td>表单数据</td>
</tr>
<tr>
<td>multipart/form-data</td>
<td>表单文件上传</td>
</tr>
<tr>
<td>application</td>
<td>序列化 JSON 数据</td>
</tr>
<tr>
<td>text/xml</td>
<td>XML 数据</td>
</tr>
</tbody>
</table>
<h5 id="6、响应"><a href="#6、响应" class="headerlink" title="6、响应"></a>6、响应</h5><p>响应由服务器端返回给客户端，可分为三部分：</p>
<ul>
<li>响应状态码（Response Status Code）</li>
<li>响应头（Response Headers）</li>
<li>响应体（Response Body）</li>
</ul>
<p>（1）响应状态码</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td></td>
<td></td>
</tr>
<tr>
<td>100</td>
<td>继续</td>
<td>请求者应当继续提出请求。服务器已收到请求的一部分，正在等待其余部分</td>
</tr>
<tr>
<td>101</td>
<td>切换协议</td>
<td>请求者已要求服务器切换协议，服务器已确认并准备切换</td>
</tr>
<tr>
<td>2XX</td>
<td></td>
<td></td>
</tr>
<tr>
<td>200</td>
<td>成功</td>
<td></td>
</tr>
<tr>
<td>201</td>
<td>已创建</td>
<td></td>
</tr>
<tr>
<td>202</td>
<td>已接受</td>
<td></td>
</tr>
<tr>
<td>203</td>
<td>非授权信息</td>
<td></td>
</tr>
<tr>
<td>204</td>
<td>无内容</td>
<td></td>
</tr>
<tr>
<td>205</td>
<td>重置内容</td>
<td></td>
</tr>
<tr>
<td>206</td>
<td>部分内容</td>
<td></td>
</tr>
<tr>
<td>3XX</td>
<td></td>
<td></td>
</tr>
<tr>
<td>300</td>
<td>多种选择</td>
<td></td>
</tr>
<tr>
<td>301</td>
<td>永久移动</td>
<td></td>
</tr>
<tr>
<td>302</td>
<td>临时移动</td>
<td></td>
</tr>
<tr>
<td>303</td>
<td>查看其他位置</td>
<td></td>
</tr>
<tr>
<td>304</td>
<td>未修改</td>
<td></td>
</tr>
<tr>
<td>305</td>
<td>使用代理</td>
<td></td>
</tr>
<tr>
<td>307</td>
<td>临时重定向</td>
<td></td>
</tr>
<tr>
<td>4XX</td>
<td></td>
<td></td>
</tr>
<tr>
<td>400</td>
<td>错误请求</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td>未授权</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td>禁止访问</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td>未找到</td>
<td></td>
</tr>
<tr>
<td>405</td>
<td>方法禁用</td>
<td></td>
</tr>
<tr>
<td>406</td>
<td>不接受</td>
<td></td>
</tr>
<tr>
<td>407</td>
<td>需要代理授权</td>
<td></td>
</tr>
<tr>
<td>408</td>
<td>请求超时</td>
<td></td>
</tr>
<tr>
<td>409</td>
<td>冲突</td>
<td></td>
</tr>
<tr>
<td>410</td>
<td>已删除</td>
<td></td>
</tr>
<tr>
<td>411</td>
<td>需要有效长度</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td>未满足前提条件</td>
<td></td>
</tr>
<tr>
<td>413</td>
<td>请求实体过大</td>
<td></td>
</tr>
<tr>
<td>414</td>
<td>请求 URI 过长</td>
<td></td>
</tr>
<tr>
<td>415</td>
<td>不支持类型</td>
<td></td>
</tr>
<tr>
<td>416</td>
<td>请求范围不符</td>
<td></td>
</tr>
<tr>
<td>417</td>
<td>未满足期望值</td>
<td></td>
</tr>
<tr>
<td>5XX</td>
<td></td>
<td></td>
</tr>
<tr>
<td>500</td>
<td>服务器内部错误</td>
<td>服务器遇到错误，无法完成请求</td>
</tr>
<tr>
<td>501</td>
<td>未实现</td>
<td>服务器不具备完成请求的功能</td>
</tr>
<tr>
<td>502</td>
<td>错误网关</td>
<td>服务器作为网关或代理，从上游服务器收到无效响应</td>
</tr>
<tr>
<td>503</td>
<td>服务不可用</td>
<td>服务器目前无法使用</td>
</tr>
<tr>
<td>504</td>
<td>网关超时</td>
<td>服务器作为网关或代理，但是没有及时从上游服务器收到请求</td>
</tr>
<tr>
<td>505</td>
<td>HTTP 版本不支持</td>
</tr>
</tbody>
</table>
<p>（2）响应头</p>
<p>响应头包含了服务器对请求的应答信息，如 Content-Type、Server、Set-Cookie 等。常用的响应头信息：</p>
<ul>
<li>Date：标识响应产生的时间</li>
<li>Last-modified：指定资源的最后修改时间</li>
<li>Content-Encoding：指定响应内容的编码</li>
<li>Server：包含服务器的信息，比如名称、版本号等</li>
<li>Content-Type：文档类型，指定返回的数据类型，text/html 代表返回 HTML 文档，application/x-javascript 代表返回 JavaScript 文件，image/jpeg 代表返回图片</li>
<li>Set-Cookie：设置 Cookies。响应头中的 Set-Cookie 告诉浏览器需要将此内容放在 Cookies 中，下次请求携带 Cookies 请求</li>
<li>Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间</li>
</ul>
<p>（3）响应体</p>
<p>存放响应的正文数据。比如请求网页时，响应体就是网页的 HTML 代码；请求图片时，响应体就是图片的二进制数据。</p>
<p>爬虫请求网页后，要解析的内容就是响应体。</p>
<hr>
<h4 id="二、网页基础"><a href="#二、网页基础" class="headerlink" title="二、网页基础"></a>二、网页基础</h4><h5 id="1、网页的组成"><a href="#1、网页的组成" class="headerlink" title="1、网页的组成"></a>1、网页的组成</h5><p>网页可分为三大部分</p>
<ul>
<li>HTML，定义网页的内容和结构</li>
<li>CSS，描述网页的布局</li>
<li>JavaScript，定义网页的行为</li>
</ul>
<p>（1）HTML</p>
<p>Hyper Text Markup Language，即超文本标记语言。HTML 定义了网页的结构。</p>
<p>不同类型的元素通过不同类型的标签来表示，如图片用 img，视频用 video，段落用 p。各种类型之间的布局又通过布局标签 div 嵌套组合而成。</p>
<p>（2）CSS</p>
<p>Cascading style Sheets，即层叠样式表。“层叠”是指当在 HTML 中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等格式。</p>
<p>在网页中，一般统一定义整个网页的样式规则，并写入 CSS 文件中。在 HTML 中，只需要用 link 标签即可引入写好的 CSS 文件，这样整个页面就会变得美观、优雅。</p>
<p>（3）JavaScript</p>
<p>简称 JS，是一种脚本语言。HTML 和 CSS 配合使用，提供给用户的只是一种静态信息，缺乏交互性。JS 的出现使得用户与信息之间不只是一种浏览与现实的关系，而是实现了一种实时、动态、交互的页面功能。</p>
<p>在 HTML 中通过 script 标签即可引入 .js 文件。</p>
<h5 id="2、网页的结构"><a href="#2、网页的结构" class="headerlink" title="2、网页的结构"></a>2、网页的结构</h5><p>一个网页的标准形式是 html 标签内嵌套 head 和 body 标签，head 内定义网页的配置和引用，body 内定义网页的正文。</p>
<h5 id="3、节点树及节点间的关系"><a href="#3、节点树及节点间的关系" class="headerlink" title="3、节点树及节点间的关系"></a>3、节点树及节点间的关系</h5><p>在 HTML 中，所有标签定义的内容都是结点，它们构成了一个 HTML DOM 树。DOM 是 Document Object Model 即文档对象类型，它定义了访问 HTML 和 XML 文档的标准。</p>
<p>W3C DOM 标准被分为 3 个不同的部分：</p>
<ul>
<li>核心 DOM：针对任何结构化文档的标准模型</li>
<li>XML DOM：针对 XML 文档的标准模型</li>
<li>HTML DOM：针对 HTML 文档的标准模型</li>
</ul>
<p>根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：</p>
<ul>
<li>整个文档是一个文档节点</li>
<li>每个 HTML 元素是元素节点</li>
<li>HTML 元素内的文本是文本节点</li>
<li>每个 HTML 属性是属性节点</li>
<li>注释是注释节点</li>
</ul>
<p>通过 HTML DOM，树中的所有节点均可通过 JavaScript 访问，所有 HTML 节点元素均可被修改，也可被创建或删除。</p>
<h5 id="4、选择器"><a href="#4、选择器" class="headerlink" title="4、选择器"></a>4、选择器</h5><p>网页由一个个节点组成，CSS 选择器会根据不同的节点设置不同的样式规则。</p>
<p>在 CSS 中，使用 CSS 选择器来定位节点。</p>
<p>还有一种比较常用的选择器是 XPath。</p>
<hr>
<h4 id="三、爬虫的基本原理"><a href="#三、爬虫的基本原理" class="headerlink" title="三、爬虫的基本原理"></a>三、爬虫的基本原理</h4><h5 id="1、爬虫概述"><a href="#1、爬虫概述" class="headerlink" title="1、爬虫概述"></a>1、爬虫概述</h5><p>（1）获取网页</p>
<p>使用请求库获取网页的源代码。</p>
<p>（2）提取信息</p>
<p>从 Body 部分提取需要的数据，最通用的方法是采用正则表达式提取。</p>
<p>另外由于网页的结构有一定规则，所以还有一些根据网页节点属性、CSS 选择器或者 Xpath 来提取网页信息的库，如 BeautifulSoup、pyquery、lxml 等。</p>
<p>（3）保存数据</p>
<p>可以简单保存为 TXT 文本或 JSON 文本，也可以保存到数据库，如 MySQL 或 MongoDB 等，也可以保存到远程服务器，如借助 SFTP 进行操作等。</p>
<p>（4）自动化程序</p>
<p>即爬虫可以替代人来完成这些操作。</p>
<h5 id="2、能抓怎样的数据"><a href="#2、能抓怎样的数据" class="headerlink" title="2、能抓怎样的数据"></a>2、能抓怎样的数据</h5><p>只要在浏览器里可以访问到的文件，都可以抓取下来。</p>
<h5 id="3、JavaScript-渲染页面"><a href="#3、JavaScript-渲染页面" class="headerlink" title="3、JavaScript 渲染页面"></a>3、JavaScript 渲染页面</h5><p>很多网页可能是由 JavaScript 渲染出来的，原始的 HTML 代码就是一个空壳。</p>
<p>JavaScript 会改变 HTML 中的节点，向其添加内容，最后得到完整的页面。</p>
<p>对于使用 JavaScript 渲染的网页，有时候得到的源代码和浏览器看到的不一样，因此使用基本 HTTP 请求库得到的源代码可能跟浏览器中的页面源代码不太一样，可以分析其后台 Ajax 接口，也可以使用 Selenium、Splash 这样的库来模拟 JavaScript 渲染。</p>
<hr>
<h4 id="四、会话和-Cookies"><a href="#四、会话和-Cookies" class="headerlink" title="四、会话和 Cookies"></a>四、会话和 Cookies</h4><h5 id="1、静态网页和动态网页"><a href="#1、静态网页和动态网页" class="headerlink" title="1、静态网页和动态网页"></a>1、静态网页和动态网页</h5><ul>
<li>静态网页 —— 由 HTML 代码编写，文字、图片等内容均通过写好的 HTML 代码来指定。</li>
<li>动态网页 —— 可以动态解析 URL 中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。</li>
</ul>
<p>动态网站可还以实现用户登录和注册的功能。</p>
<h5 id="2、无状态-HTTP"><a href="#2、无状态-HTTP" class="headerlink" title="2、无状态 HTTP"></a>2、无状态 HTTP</h5><p>HTTP 的无状态是指 HTTP 协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。于是出现了两个用于保持 HTTP 连接状态的技术：</p>
<ul>
<li>会话<ul>
<li>在服务器端，用来保存用户的会话信息</li>
<li>会话对象用于存储特定用户会话所需的属性及配置信息</li>
<li>用户在应用程序的 Web 页之间跳转时，存储在会话对象中的变量不会丢失</li>
<li>用户请求 Web 页时，如果还没有会话，Web 服务器将自动创建一个会话对象，当会话过期或被放弃后，服务器将终止该会话</li>
</ul>
</li>
<li>Cookies<ul>
<li>在客户端，是某些网站为了辨别用户身份、进行会话跟踪而存储在用户本地终端上的数据。</li>
<li>浏览器在下次访问网页时会自动附带上 Cookies 发送给服务器，服务器通过识别 Cookies 并鉴定出是哪个用户，在判断用户是否是登录状态，然后返回对应的响应</li>
<li>Cookies 是客户第一次请求服务器时，由服务器返回一个请求头中带有 Set-Cookie 字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把 Cookies 保存起来。</li>
</ul>
</li>
</ul>
<p>会话 Cookie 和持久 Cookie：</p>
<ul>
<li>会话 Cookie 就是把 Cookie 放在浏览器内存里，浏览器在关闭之后该 Cookie 即失效</li>
<li>持久 Cookie 则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态<br>-严格来说，没有会话 Cookie 和持久 Cookie 之分，只是有 Cookie 的 Max Age 或 Expires 字段决定了过期的时间</li>
</ul>
<h5 id="3、常见误区"><a href="#3、常见误区" class="headerlink" title="3、常见误区"></a>3、常见误区</h5><p>关闭浏览器不会导致会话消失，所以需要服务器为会话设置一个失效时间。</p>
<hr>
<h4 id="五、代理的基本原理"><a href="#五、代理的基本原理" class="headerlink" title="五、代理的基本原理"></a>五、代理的基本原理</h4><h5 id="1、基本原理"><a href="#1、基本原理" class="headerlink" title="1、基本原理"></a>1、基本原理</h5><p>代理指代理服务器，英文叫作 proxy server，它的功能是代理网络用户去取得网络信息，是网络信息的中转站。</p>
<p>这个过程中 Web 服务器识别出的真实 IP 就不再是我们本机的 IP 了，就成功实现了 IP 伪装。</p>
<h5 id="2、代理的作用"><a href="#2、代理的作用" class="headerlink" title="2、代理的作用"></a>2、代理的作用</h5><ul>
<li>突破自身 IP 访问限制，访问一些平时不能访问的站点</li>
<li>访问一些单位或团体内部资源</li>
<li>提高访问速度</li>
<li>隐藏真实 IP</li>
</ul>
<h5 id="3、爬虫代理"><a href="#3、爬虫代理" class="headerlink" title="3、爬虫代理"></a>3、爬虫代理</h5><p>使用代理隐藏真实的 IP，让服务器误以为是代理服务器在请求自己，这样在爬取过程中通过不断更换代理，就不会被封锁，可以达到很好的爬取效果。</p>
<h5 id="4、代理分类"><a href="#4、代理分类" class="headerlink" title="4、代理分类"></a>4、代理分类</h5><p>根据协议区分：</p>
<ul>
<li>FTP 代理服务器</li>
<li>HTTP dialing服务器</li>
<li>SSL/TLS 代理</li>
<li>RTSP 代理</li>
<li>Telnet 代理。主要用于 telnet 远程控制（黑客入侵计算机时常用于隐藏身份），端口一般为23</li>
<li>POP3/SMTP 代理</li>
<li>SOCKS 代理。只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般有缓存功能，端口一般为 1080</li>
</ul>
<p>根据匿名程度区分：</p>
<ul>
<li>高度匿名代理</li>
<li>普通匿名代理</li>
<li>透明代理。除了能用缓存技术提高浏览速度，能用内容过滤提高安全性之外，无其他显著作用，最常见的例子是内网中的硬件防火墙</li>
<li>间谍代理</li>
</ul>
<h5 id="5、常见代理设置"><a href="#5、常见代理设置" class="headerlink" title="5、常见代理设置"></a>5、常见代理设置</h5><ul>
<li>使用网上的免费代理，最好使用高匿代理</li>
<li>使用付费代理服务，质量好</li>
<li>ADSL 拨号，拨一次号换一次 IP，稳定性高</li>
</ul>
]]></content>
      <tags>
        <tag>CS基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 模板</title>
    <url>//blog/2019/04/13/C-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<hr>
<h4 id="一、函数模板（Function-Template）"><a href="#一、函数模板（Function-Template）" class="headerlink" title="一、函数模板（Function Template）"></a>一、函数模板（Function Template）</h4><p>值的参数化：</p>
<a id="more"></a>
<ul>
<li>在函数定义时形参数据的值是未知的，只有等到函数调用时接收了实参才能确定其值。</li>
</ul>
<p>类型的参数化：</p>
<ul>
<li>在 C++ 中，数据类型也可以通过参数来传递，在函数定义时不指明具体数据类型，函数调用时，编译器可以根据传入的实参自动推断数据类型。</li>
</ul>
<p>函数模板：</p>
<ul>
<li>建立一个函数的模板，其用到的数据类型（返回值、形参、局部变量的类型）用一个虚拟的类型代替。</li>
</ul>
<p>函数模板的语法：（模板头 + 使用新定义的类型参数的函数定义）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename 类型参数1 , typename 类型参数2 , ...&gt; </span><br><span class="line">返回值类型  函数名(形参列表)&#123;</span><br><span class="line">	…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt; void Swap(T &amp;a, T &amp;b)&#123;</span><br><span class="line"></span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数模板也可以先声明后定义，但是声明的时候也必须带上模板头。</p>
<p>可以用多个 typename 声明多种不同的类型参数。</p>
<p>typename 关键字也可以使用 class 关键字代替。</p>
<hr>
<h4 id="二、类模板（Class-Template）"><a href="#二、类模板（Class-Template）" class="headerlink" title="二、类模板（Class Template）"></a>二、类模板（Class Template）</h4><p>类模板的定义与函数模板类似，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename 类型参数1, typename 类型参数2 , …&gt; class 类名&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类的成员函数的定义时，语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename 类型参数1, typename 类型参数2,  …&gt;</span><br><span class="line"></span><br><span class="line">返回值类型 类名&lt;类型参数1, 类型参数2, … &gt; :: 函数名(参数表)&#123;</span><br><span class="line">	…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类名之后，需带上该类全部的类型参数表（不需要写 typename），函数的参数表中，用到了哪个类型参数写哪个就可以。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt; class Operation&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Operation(T a, T b) :m_a(a), m_b(b)&#123;&#125;</span><br><span class="line">	T Sum();</span><br><span class="line">	bool SetValue(T a, T b);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">	T m_a;</span><br><span class="line">	T m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">T Operation&lt;T&gt;::Sum()&#123;</span><br><span class="line"></span><br><span class="line">	T c = m_a + m_b;</span><br><span class="line">	return c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">bool Operation&lt;T&gt;::SetValue(T a, T b)&#123;</span><br><span class="line"></span><br><span class="line">	m_a = a;</span><br><span class="line">	m_b = b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">	Operation&lt;float&gt; ope(2.3, 3.4);</span><br><span class="line">	float sum = ope.Sum();</span><br><span class="line">	cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用类模板创建对象时，需显示指明类型参数，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Operation&lt;float&gt; ope(2.3, 3.4);</span><br></pre></td></tr></table></figure>
<p>如果是创建对象指针，赋值时两边都要指明具体类型，且要保持一致：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Operation&lt;float&gt; *ope = new Operation&lt;float&gt;(1.2, 2.3);</span><br></pre></td></tr></table></figure>
<p>另外，也可以仿造类模板定义结构体模板。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 模板的编译问题</title>
    <url>//blog/2019/04/14/C-%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<hr>
<h4 id="一、C-对模板的编译"><a href="#一、C-对模板的编译" class="headerlink" title="一、C++ 对模板的编译"></a>一、C++ 对模板的编译</h4><p>使用普通函数和类的时候，编译器只需掌握函数或类的声明即可，所以声明和定义通常分别放在 .h 和 .cpp 文件中。</p>
<a id="more"></a>
<p>而模板和模板的成员函数都是在用到的时候才会实例化，这就导致如果按照普通函数或类的方法去定义和声明模板类，在链接阶段，链接器将找不到模板函数或模板类成员函数的定义，因为它们所在的 .cpp 文件并未被编译。为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，因此<strong>模板的头文件通常既包括声明，也包括定义</strong>。</p>
<p>事实上，C++对想要将声明和定义分别放在两个文件中进行编译提供了两种方式：</p>
<ul>
<li>包含编译</li>
<li>分离编译</li>
</ul>
<p>包含编译：<br>大部分内容与正常函数或类的定义和声明相同，只是文件包含有所区别，不需要 cpp 头部包含 .h 文件，而是<strong>用头文件包含源文件</strong>，在 .h 文件的末尾#include&lt;XXX.cpp&gt;。这样其实就相当于把所有内容都写在了头文件中，因为预编译阶段就是把 #include 的文件复制到包含位置。</p>
<p>分离编译：<br>仍是大部分内容与正常函数或类的定义和声明相同，在定义所在的 .cpp 文件中的函数定义的最前面加上 export 关键字，以告诉编译器该定义在哪里被引用。</p>
<p>然而在 codeblocks12.11 中使用上面两种方法时，均失败。分别报错说 .cpp 中的类名“does not name a type”，和 export 关键字没有被实现，因而将被忽略，进而导致实例化时该类模板“undefined reference”。</p>
<p>可见，以上两种方法虽理论上可行，但实际上由于编译器的原因，并不一定能使用。</p>
<hr>
<h4 id="二、Codeblocks-中使用模板的方法"><a href="#二、Codeblocks-中使用模板的方法" class="headerlink" title="二、Codeblocks 中使用模板的方法"></a>二、Codeblocks 中使用模板的方法</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>定义和声明放在同一个 .h 文件中。这是最可靠的方式，无论哪个编译器都不会出错。只是有可能在大规模项目中导致文件特别大。</p>
<h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>声明和定义放在不同的 .h 文件中，在声明文件的末尾（注意是末尾） #include 定义的 .h 文件。</p>
<p>这样做原理上与方法一是一致的，在预编译阶段通过复制使它们成为了一个文件。</p>
<h5 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h5><p>声明和定义分别放在 .h 和 .cpp 文件中，.cpp 文件包含 .h 文件，在 .cpp 文件中写一个函数，对该文件中涉及到的所有成员函数全部实例化一遍（如果只对部分成员函数实例化了，则剩余函数不会被编译）。</p>
<p>这种方法的原理在于：</p>
<ul>
<li>如果不在 .cpp 文件中进行实例化，编译阶段编译器遇到这个 .cpp 文件，一看里面全是模板，就会将这个文件忽略，这样在链接阶段，链接器就会因为找不到模板函数的定义文件而报错。</li>
<li>在 .cpp 文件中通过一个函数进行了实例化之后，编译阶段，编译器发现这个文件中有非模板函数，就会对其进行编译，由于它的内部对模板进行了实例化，所以，而这些模板的定义和声明又有迹可循，所以就能对它们进行编译。</li>
</ul>
<h5 id="方法四："><a href="#方法四：" class="headerlink" title="方法四："></a>方法四：</h5><p>声明和定义分别放在 .h 和 .cpp 文件中，.cpp 文件包含 .h 文件，在实例化模板的文件中，再统一包含这两个文件。</p>
<p>例如，在 main() 函数中对类模板及其中的成员函数进行了实例化，则在 main() 函数所在的文件头部包含 .cpp 和 .h 文件。此方法的原理类似于方法三。</p>
<hr>
<p>以上四种方法都是在 codeblocks12.11 中验证过的。总体来说，还是方法一和方法二更实用一些。但是在摸索这些方法的过程中，加深对程序编译和 C++ 语言特性的理解，还是颇有好处的。</p>
<p>参考博文及书籍：<br>《C++ primer（中文第 5 版）》<br><a href="https://blog.csdn.net/xiaoyaohuqijun/article/details/50558208" target="_blank" rel="noopener">https://blog.csdn.net/xiaoyaohuqijun/article/details/50558208</a><br><a href="https://blog.csdn.net/qq_41230365/article/details/80207842" target="_blank" rel="noopener">https://blog.csdn.net/qq_41230365/article/details/80207842</a><br><a href="https://blog.csdn.net/u012814856/article/details/84645963" target="_blank" rel="noopener">https://blog.csdn.net/u012814856/article/details/84645963</a><br><a href="https://blog.csdn.net/chenyiming_1990/article/details/9094593" target="_blank" rel="noopener">https://blog.csdn.net/chenyiming_1990/article/details/9094593</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeBlocks 不能编译或调试的解决办法</title>
    <url>//blog/2019/04/18/CodeBlocks-%E4%B8%8D%E8%83%BD%E7%BC%96%E8%AF%91%E6%88%96%E8%B0%83%E8%AF%95%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>今天新装了最新版的 Code::Blocks17.12，下载的时候选择了完整版（带了 MinGW），编译一切正常，但是 Debug 的时候报了错：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR: You need to specify a debugger program in the debuggers&apos;s settings.</span><br><span class="line">(For MinGW compilers, it&apos;s &apos;gdb.exe&apos; (without the quotes))</span><br><span class="line">(For MSVC compilers, it&apos;s &apos;cdb.exe&apos; (without the quotes))</span><br></pre></td></tr></table></figure>
<p>这是因为没有设置调试器（以前用的那个版本好像安装完就能直接调试）。</p>
<p>如果下载的是完整版的，就按照以下步骤添加调试器路径：<br>Settings -&gt; Debugger -&gt; Default -&gt; Executable path</p>
<p>路径为：CodeBlocks\MinGW\bin\gdb32.exe （也有可能是 gdb.exe）</p>
<p>如果路径下没有这个文件，就从 <a href="http://www.equation.com/servlet/equation.cmd?fa=gdb" target="_blank" rel="noopener">http://www.equation.com/servlet/equation.cmd?fa=gdb</a> 下载一个。</p>
<p>如果是没法编译，也是下载一个 MinGW ，安装，然后配置系统变量。最后在 CodeBlocks 软件中 Settings -&gt; Complier 选择 GUN GCC Compiler 编译器即可。</p>
]]></content>
      <tags>
        <tag>软件使用</tag>
        <tag>CodeBlocks</tag>
      </tags>
  </entry>
  <entry>
    <title>常用数学符号</title>
    <url>//blog/2019/04/29/%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<hr>
<h4 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h4><p>α β γ δ ε ζ η θ ι κ λ μ ν ξ ο π ρ σ τ υ φ χ ψ ω</p>
<p>Α Β Γ Δ Ε Ζ Η Θ Ι Κ Λ Μ Ν Ξ Ο Π Ρ Σ Τ Υ Φ Χ Ψ Ω</p>
<a id="more"></a>
<h4 id="逻辑关系"><a href="#逻辑关系" class="headerlink" title="逻辑关系"></a>逻辑关系</h4><p>≈ ≠ ≥ ≤ ∽ ≌ ∥</p>
<p>⊆ ⊂ ⊇ ⊃</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>∪ ∩ ∈</p>
<h4 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h4><p>∀ ∃ ⊥ ∽ △ ∠ ∩ ∪ ≠ ≡ ± ≥ ≤ ∈ § ∵ ∴</p>
<p>← ↑ → ↓ ↖ ↗ ↘ ↙ ∥ ∧ ∨</p>
<h4 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h4><p>∫ ∮ ∂ ∑ ∏ ▽</p>
<h4 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h4><p>⊥   ∥   ∠   ⌒   ⊙   ≡   ≌    △</p>
<h4 id="代数"><a href="#代数" class="headerlink" title="代数"></a>代数</h4><p>∝   ∧   ∨   ～   ∫   ≠    ≤   ≥   ≈   ∞   ∶</p>
<h4 id="离散数学符号"><a href="#离散数学符号" class="headerlink" title="离散数学符号"></a>离散数学符号</h4><p>├ 断定符（公式在L中可证）</p>
<p>╞ 满足符（公式在E上有效，公式在E上可满足）</p>
<p>┐ 命题的“非”运算</p>
<p>∧ 命题的“合取”（“与”）运算</p>
<p>∨ 命题的“析取”（“或”，“可兼或”）运算</p>
<p>→ 命题的“条件”运算</p>
<p>A&lt;=&gt;B 命题A 与B 等价关系</p>
<p>A=&gt;B 命题 A与 B的蕴涵关系</p>
<p>A* 公式A 的对偶公式</p>
<p>wff 合式公式</p>
<p>iff 当且仅当</p>
<p>↑ 命题的“与非” 运算（ “与非门” ）</p>
<p>↓ 命题的“或非”运算（ “或非门” ）</p>
<p>□ 模态词“必然”</p>
<p>◇ 模态词“可能”</p>
<p>φ 空集</p>
<p>∈ 属于（??不属于）</p>
<p>P（A） 集合A的幂集</p>
<p>|A| 集合A的点数</p>
<p>R^2=R○R [R^n=R^(n-1)○R] 关系R的“复合”</p>
<p>（或下面加 ≠） 真包含</p>
<p>∪ 集合的并运算</p>
<p>∩ 集合的交运算</p>
<p>-（～） 集合的差运算</p>
<p>〡 限制<br>[ A ](右下角R) 集合关于关系R的等价类</p>
<p>A/ R 集合A上关于R的商集</p>
<p>[a] 元素a 产生的循环群</p>
<p>I (i大写) 环，理想</p>
<p>Z/(n) 模n的同余类集合</p>
<p>r(R) 关系 R的自反闭包</p>
<p>s(R) 关系 的对称闭包</p>
<p>CP 命题演绎的定理（CP 规则）</p>
<p>EG 存在推广规则（存在量词引入规则）</p>
<p>ES 存在量词特指规则（存在量词消去规则）</p>
<p>UG 全称推广规则（全称量词引入规则）</p>
<p>US 全称特指规则（全称量词消去规则）</p>
<p>R 关系</p>
<p>r 相容关系</p>
<p>R○S 关系 与关系 的复合</p>
<p>domf 函数 的定义域（前域）</p>
<p>ranf 函数 的值域</p>
<p>f:X→Y f是X到Y的函数</p>
<p>GCD(x,y) x,y最大公约数</p>
<p>LCM(x,y) x,y最小公倍数</p>
<p>aH(Ha) H 关于a的左（右）陪集</p>
<p>Ker(f) 同态映射f的核（或称 f同态核）</p>
<p>[1，n] 1到n的整数集合</p>
<p>d(u,v) 点u与点v间的距离</p>
<p>d(v) 点v的度数</p>
<p>G=(V,E) 点集为V，边集为E的图</p>
<p>W(G) 图G的连通分支数</p>
<p>k(G) 图G的点连通度</p>
<p>△（G) 图G的最大点度</p>
<p>A(G) 图G的邻接矩阵</p>
<p>P(G) 图G的可达矩阵</p>
<p>M(G) 图G的关联矩阵</p>
<p>C 复数集</p>
<p>N 自然数集（包含0在内）</p>
<p>N* 正自然数集</p>
<p>P 素数集</p>
<p>Q 有理数集</p>
<p>R 实数集</p>
<p>Z 整数集</p>
<p>Set 集范畴</p>
<p>Top 拓扑空间范畴</p>
<p>Ab 交换群范畴</p>
<p>Grp 群范畴</p>
<p>Mon 单元半群范畴</p>
<p>Ring 有单位元的（结合）环范畴</p>
<p>Rng 环范畴</p>
<p>CRng 交换环范畴</p>
<p>R-mod 环R的左模范畴</p>
<p>mod-R 环R的右模范畴</p>
<p>Field 域范畴</p>
<p>Poset 偏序集范畴</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 语法</title>
    <url>//blog/2019/05/01/Markdown-%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p>Markdown 是一种轻量级标记语言，可以让人专注于文字内容而不是排版样式，可读性强，直观，入门简单。<br><a id="more"></a></p>
<h5 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><p>标题最多 6 级。# 与标题之间用一个空格隔开。</p>
<h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;123</span><br><span class="line">&gt;&gt; 234</span><br><span class="line">&gt;&gt;&gt; 345</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<blockquote>
<p>123</p>
<blockquote>
<p>234</p>
<blockquote>
<p>345</p>
</blockquote>
</blockquote>
</blockquote>
<h5 id="插入分割线"><a href="#插入分割线" class="headerlink" title="插入分割线"></a>插入分割线</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">***</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<hr>
<hr>
<h5 id="插入图片或链接"><a href="#插入图片或链接" class="headerlink" title="插入图片或链接"></a>插入图片或链接</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片文件名](图片链接)</span><br><span class="line">[显示的内容](链接)</span><br></pre></td></tr></table></figure>
<p>插入图片需要使用图床产生链接，例如使用 <a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS</a>。</p>
<h5 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 123 | 456 | 789 |</span><br><span class="line">| --- | --- | --- |</span><br><span class="line">| 111 | 111 | 111 |</span><br><span class="line">| 222 | 222 | 222 |</span><br><span class="line">| 333 | 333 | 333 |</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<table>
<thead>
<tr>
<th>123</th>
<th>456</th>
<th>789</th>
</tr>
</thead>
<tbody>
<tr>
<td>111</td>
<td>111</td>
<td>111</td>
</tr>
<tr>
<td>222</td>
<td>222</td>
<td>222</td>
</tr>
<tr>
<td>333</td>
<td>333</td>
<td>333</td>
</tr>
</tbody>
</table>
<p>Markdown 中的表格也可以换行、合并单元格等。</p>
<h5 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h5><p>使用 · 或 ··· 将代码上下括起来即可（注意不是单引号，是键盘中 Tab 键上方那个符号），通常 · 用于语句中内嵌代码，只能显示为一行，··· 用于插入代码块，可以按照输入格式显示为多行。</p>
<p>效果：</p>
<p>使用 · ：<br><code>print(123)
    123</code><br>使用 ··· ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(123)</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<h5 id="粗体、斜体、下划线、删除线"><a href="#粗体、斜体、下划线、删除线" class="headerlink" title="粗体、斜体、下划线、删除线"></a>粗体、斜体、下划线、删除线</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**粗体123**</span><br><span class="line">*斜体123*</span><br><span class="line">&lt;u&gt;下划线123&lt;/u&gt;</span><br><span class="line">~~删除线123~~</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><strong>粗体123</strong><br><em>斜体123</em><br><u>下划线123</u><br><del>删除线123</del></p>
<h5 id="字体、文字颜色、文字大小"><a href="#字体、文字颜色、文字大小" class="headerlink" title="字体、文字颜色、文字大小"></a>字体、文字颜色、文字大小</h5><p>通过内嵌 HTML，可以调整 Markdown 文本的字体、文字颜色、文字大小（有些编辑器内可能不支持）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;微软雅黑&quot;&gt;微软雅黑&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;STCAIYUN&quot;&gt;华文彩云&lt;/font&gt;</span><br><span class="line">&lt;font color=#0099ff size=10 face=&quot;黑体&quot;&gt;深蓝色黑体 10号&lt;/font&gt;</span><br><span class="line">&lt;font color=#00ffff size=10&gt;浅蓝色 10号&lt;/font&gt;</span><br><span class="line">&lt;font color=gray size=10&gt;灰色 10号&lt;/font&gt;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<font face="黑体">黑体</font><br><font face="微软雅黑">微软雅黑</font><br><font face="STCAIYUN">华文彩云</font><br><font color="#0099ff" size="10" face="黑体">深蓝色黑体 10号</font><br><font color="#00ffff" size="10">浅蓝色 10号</font><br><font color="gray" size="10">灰色 10号</font>

<p>常用文字颜色：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">红色：</span><br><span class="line">&lt;font color=&quot;#dd0000&quot;&gt;显示文字&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">绿色：</span><br><span class="line">&lt;font color=&quot;#00dd00&quot;&gt;显示文字&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">蓝色：</span><br><span class="line">&lt;font color=&quot;#0000dd&quot;&gt;显示文字&lt;/font&gt; </span><br><span class="line"></span><br><span class="line">黄色：</span><br><span class="line">&lt;font color=&quot;#dddd00&quot;&gt;显示文字&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">青色：</span><br><span class="line">&lt;font color=&quot;#00dddd&quot;&gt;显示文字&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">紫色：</span><br><span class="line">&lt;font color=&quot;#dd00dd&quot;&gt;显示文字&lt;/font&gt;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<font color="#dd0000">显示文字</font><br><font color="#00dd00">显示文字</font><br><font color="#0000dd">显示文字</font><br><font color="#dddd00">显示文字</font><br><font color="#00dddd">显示文字</font><br><font color="#dd00dd">显示文字</font> 

<p>其他颜色可查询：<br><a href="http://www.114la.com/other/rgb.htm" target="_blank" rel="noopener">RGB颜色查询对照表</a></p>
]]></content>
      <tags>
        <tag>编程语言</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy 中 linspace() 与 arange() 的区别</title>
    <url>//blog/2019/05/07/Numpy-%E4%B8%AD-linspace-%E4%B8%8E-arange-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<hr>
<p>从功能上，两者都是生成一个 numpy.ndarray 类型的等差数列。 </p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arange(start=None, stop=None, step=None, dtype=None)</span><br><span class="line">linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</span><br></pre></td></tr></table></figure>
<ul>
<li>numpy.arange() 的参数是 start，stop 和 step（步长）</li>
<li>numpy.linspace() 的参数是 start，stop 和 num（数量）</li>
</ul>
<p><strong>numpy.arange() 是将从 start 到 stop 的区间，按照步长 step 生成含 (stop-start)/step 个元素的向量，结果中不包含 stop。</strong></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v = np.arange(0, 1, 0.1)</span><br><span class="line">print(v)</span><br></pre></td></tr></table></figure></p>
<p>的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ 0.   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9]</span><br></pre></td></tr></table></figure>
<p><strong>numpy.linspace() 是将从 start 到 stop 的区间，按照步长 (stop-start)/(num-1) 生成含 num 个元素的向量，结果中包含 stop。</strong></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u = np.linspace(0, 1, 10)</span><br><span class="line">print(u)</span><br></pre></td></tr></table></figure></p>
<p>的结果是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ 0.          0.11111111  0.22222222  0.33333333  0.44444444  0.55555556</span><br><span class="line">  0.66666667  0.77777778  0.88888889  1.        ]</span><br></pre></td></tr></table></figure></p>
<p>其步长为 (1 - 0)/(10-1) = 0.111…，共 10 个元素。</p>
<p>而<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">u = np.linspace(0, 1, 11)</span><br><span class="line">print(u)</span><br></pre></td></tr></table></figure></p>
<p>的结果是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ 0.   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9  1. ]</span><br></pre></td></tr></table></figure></p>
<p>其步长为 (1 - 0)/(11-1) = 0.1，共 11 个元素。</p>
]]></content>
      <tags>
        <tag>编程语言</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>逆波兰表达式</title>
    <url>//blog/2019/09/27/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<hr>
<p>逆波兰表达式，即后缀表达式，常用于表达式求值中。相应的波兰表达式为前缀表达式。</p>
<p>后缀表达式的特点是事先考虑运算符的优先级，运算符在操作数之后，不需要处理括号。</p>
<p>正常的表达式为中缀表达式，可以通过几种方式由中缀表达式得到后缀表达式。</p>
<a id="more"></a>
<hr>
<h3 id="笔算"><a href="#笔算" class="headerlink" title="笔算"></a>笔算</h3><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>① 将两个直接操作数用括号括起来；</p>
<p>② 将操作符提到括号后；</p>
<p>③ 去掉括号。</p>
<p>例如：</p>
<p>​    1+3*2-6/2：</p>
<p>① ((1+(3*2))-(6/2))</p>
<p>② ((1(32)*)+(62)/)-</p>
<p>③ 132*+62/-</p>
<p>即 1+3*<em>2-6/2 → 132</em>+62/-</p>
<p>使用这种方法还可得到前缀表达式，即在第 ② 步将操作符提到括号前。</p>
<h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>写出表达式树（编程实现时，常用后缀表达式生成表达式树），然而进行后序遍历即可得到后缀表达式。</p>
<p>表达式树的特点是所有操作数都位于叶子结点上，所有的叶子结点的数据都是操作数，操作符位于分支结点上。</p>
<p>例如：</p>
<p>​    A+B*(C-D)-E/F：</p>
<p><img src="https://i.loli.net/2019/09/27/5Nw6RGC8vAZ3tFE.png" alt="123.png" style="zoom: 67%;"></p>
<p>经过后序遍历得到：ABCD-*+EF/-</p>
<hr>
<h3 id="程序算法"><a href="#程序算法" class="headerlink" title="程序算法"></a>程序算法</h3><p>从左到右遍历中缀表达式：</p>
<p>① 遇到操作数时就输出，加入后缀表达式；</p>
<p>② 遇到操作符时：</p>
<ul>
<li>若为 ‘(‘，入栈</li>
<li>若为 ‘)’，则依次把栈中的运算符加入后缀表达式，直到出现 ‘(‘，从栈中直接删除 ‘(‘</li>
<li>若为除括号外的其他操作符，当其优先级高于除 ‘(‘ 以外的栈顶运算符时，直接入栈。否则从栈顶开始，依次弹出比当前处理的操作符优先级高和优先级相等的操作符，直到一个比它优先级低的或遇到了一个左括号为止</li>
</ul>
<p>③ 遍历结束后，栈中剩下的操作符依次出栈加入后缀表达式。</p>
<p>根据以上原则，可以用数字对栈内和栈外的操作符优先级进行排序：</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">#</th>
<th style="text-align:center">(</th>
<th style="text-align:center">*，/</th>
<th style="text-align:center">+，-</th>
<th style="text-align:center">)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">isp</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">isp</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>其中，isp 表示栈内优先（in stack priority），icp 表示栈外优先（in coming priority）。</p>
<p>在表达式之后加上符号 ‘#’ 表示表达式结束，相应地，在遍历表达式之前，先入栈一个 ‘#’。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>//blog/2022/03/06/test/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
