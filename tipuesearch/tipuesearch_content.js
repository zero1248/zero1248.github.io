var tipuesearch = {"pages":[{"title":"Hexo 博客搭建（6）Hexo 写作","url":"/article/75cb4405.html","text":"本系列介绍如何使用 Hexo+github pages 搭建个人博客。本文中介绍如何用 Hexo 写博客正文。在 Hexo 工程根目录下打开 Git Bash 环境，输入：hexo n “博客标题”就会在 source&#x2F;_post 文件夹下生成相应的 md 文件，其内容与 scaffolds 文件夹下的 post.md 模板一致。例如输入：hexo n “test”则在 source&#x2F;_post 文件夹下生成了打开后的界面是：可以在 tags 下填写目录标签和普通标签。如果在 yilia 的 _config.yml 中设置了目录，则这里添加目录标签后，就会出现在页面中相应的目录下。另外也可以添加普通标签，会出现在所有文章列表中对应的标签下。例如：123tags： - 软件使用 - Hexo”-“ 前面空两格，”-“ 后面空一格。经过部署后，在最终页面里，点击目录中的 “软件使用” 就能看见这一篇文章。点击 “所有文章”，打开 tag 开关，可以点击 “Hexo” 标签看到这篇文章。如果不加设置，默认会将整篇文章显示出来，如果想要折叠文章，只显示前面几行，可以在正文里需要折叠的位置另起一行，输入&lt;!--more--&gt;例如：显示效果为：内容编辑方面参考 markdown 语法即可。","tags":"软件使用 hexo"},{"title":"Hexo 博客搭建（5）更换主题及设置","url":"/article/49030cf.html","text":"本系列介绍如何使用 Hexo+github pages 搭建个人博客。本文中介绍如何更换页面主题。在 Hexo 官网上提供了多种主题：Themes | Hexo可以从中选择合适的，下载相应的代码。一、Yilia 下载这里以 Yilia 为例：在 Hexo 工程根目录下打开 Git Bash 环境，输入：1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia这样就把 yilia 主题的相关文件放到了 Hexo 工程中的 themes 文件夹下。然后，打开 Hexo 工程根目录下的 _config.yml 文件，修改 theme 的值为 yilia：1theme: yilia这样就可以使用 yilia 主题了。关于主题的配置，可以根据自己的需求和个人爱好自由定制。","tags":"软件使用 hexo"},{"title":"Hexo 博客搭建（4）Hexo 部署到 Github","url":"/article/8464f732.html","text":"本系列介绍如何使用 Hexo+github pages 搭建个人博客。本文中介绍如何将 Hexo 工程部署到 github 上，并可以通过域名访问博客。Hexo 的优点在于，只要用户配置好各项参数，执行 hexo g（或者 hexo generate）就可以生成博客的静态页面，然后只需要执行一条 hexo d（或者 hexo deploy）就可以自动推送到绑定的 {github 用户名}.github.io 仓库中，然后就可以通过仓库同名的域名来访问博客了。打开 Hexo 工程根目录下的 _config.yml 全局配置文件，定位到 deploy 的位置，然后进行修改。1234567deploy: type: git repository: git@github.com:&#123;github 用户名&#125;/&#123;github 用户名&#125;.github.io.git branch: master注意缩进都是两个空格，另外冒号后面要有一个空格。然后安装 git 部署插件，在 git bash 中输入：npm install hexo-deployer-git --save最后，打开 git bash，输入hexo g -d就可以完成部署。如果已经单独执行过 hexo g，也可以只执行 hexo d。至此已经可以将静态页面（public 文件夹下的内容）推送到先前创建的 {github 用户名}.github.io 仓库了，并且可以使用这个名字作为域名来访问自己的博客页面。注意每次上传后需要等待一段时间，才能刷新出来最新的页面。关于主题修改、增加功能等的内容将在后续文章中写出。","tags":"软件使用 hexo"},{"title":"Hexo 博客搭建（3）Hexo 工程框架介绍","url":"/article/c6fb3751.html","text":"本系列介绍如何使用 Hexo+github pages 搭建个人博客。本文中整体介绍 Hexo 工程框架。Hexo 工程根目录如下图所示：其中：node_modules 文件夹用于存放 Hexo 需要的 node.js 模块，新安装的插件也存放在这里。scaffolds 文件夹存放了几个模板，通过 hexo new（或 hexo n） 命令来创建新文件时就调用这里相应的模板。source 文件夹用于存放源文件，即博客正文的 md 文件。_post 文件夹下存放正式发布的 md 源文件（对应命令 hexo new）_draft 文件夹存放 md 草稿，不会显示在发布的页面中（对应命令 hexo new draft）可以通过 hexo publish将草稿移动到 _post 文件夹下也可以通过 –draft 参数来预览草稿，即 hexo g -s –drafthexo new page 命令创建的文件直接存放在 source 文件夹下（与 _post 同级）,也可以通过 -p 指定路径thmes 文件夹用于存放主题文件_config.yml 是站点的全局配置文件db.json 是缓存文件package.json 是项目的依赖包信息执行 hexo g 命令生成页面后，工程根目录下会出现 public 文件夹里面存放着生成的静态页面的内容再输入 hexo s 即可通过浏览器预览页面了。更新 hexo 工程配置、更换主题、添加源文件等操作之后，通过 hexo g -s 命令即可在本地通过浏览器预览新生成的页面。此时，页面只是在本地显示，还不能通过 github.io 域名访问，后面将会介绍如何实现。","tags":"软件使用 hexo"},{"title":"Hexo 博客搭建（2）Hexo 安装和使用","url":"/article/861d0242.html","text":"本系列介绍如何使用 Hexo+github pages 搭建个人博客。本文中介绍 Hexo 的安装。安装 Hexo 需要使用 node.js，但不要下载最新版本，12.18.3 亲测可用。一、安装 node.js由于不同的开发环境需求不同的 node.js 版本，而且 Hexo 不能在太高的 node.js 版本下使用，所以可以使用 nvm 来管理和切换 node.js 和相应的 npm 的版本。具体可参考 使用 nvm 管理和切换不同版本的 node.js | Isaac前进4 (zero1248.github.io)。node.js 12.18.3 版本亲测可用。二、安装 Hexo首先确认 node.js 和 npm 安装成功，打开 git bash 工具（虽然 cmd 命令行工具也可以，但是最好都在 git bash 下进行，以避免不必要的麻烦），输入：12node -vnpm -v输出版本号即表示安装成功。安装 Hexo，在任意位置执行npm install -g hexo这样安装的 Hexo3.x 版本。目前 Hexo 官方版本已经更新到了 6.x（安装方式也稍有区别，可以从 Hexo 官网查看），但是为了待在舒适区里，不再重新踩一遍坑，本人打算还是用这个老版本。三、使用Hexo在准备存放代码的目录下打开 git bash，执行hexo inithexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：此时，可以在本地预览，执行hexo s -gs 指 server，g 指 generate。然后打开浏览器，输入 http://localhost:4000，就可以看到初始版本的 Hexo 博客界面。如果 4000 端口被占用了，可以更换端口，例如更换到 5000，执行：hexo s -p 5000至此就完成了 Hexo 的安装和初步使用。","tags":"软件使用 hexo"},{"title":"Hexo 博客搭建（1）github 设置","url":"/article/a926b62b.html","text":"本系列介绍如何使用 Hexo+github pages 搭建个人博客。本文中首先介绍 github 的相关设置。O、安装 git 客户端从 Git (git-scm.com) 下载并安装 git，具体安装过程不熟悉的话可以自行搜索。注意安装过程中勾选上 Git Bash Here，方便使用。安装成功后，鼠标右键菜单里会出现 Git Bash Here，即可从任意目录进入 git bash 环境。一、创建 github 仓库新建一个名为 {github 用户名}.github.io 的仓库。例如，github 用户名是 xyz，则新建仓库的名字为 xyz.github.io。这个地址就是用来访问博客的域名，每个 github 账户只能建一个这样的仓库作为域名。另外，如果不想使用这个默认域名，也可以绑定自己的其他域名，具体的绑定方法请自行搜索。二、配置 SSH keySSH key 用于连接 git 服务器。如果已经生成过，则在 C:\\Users{用户名}.ssh 目录下有密钥文件（id_rsa.pub）。如果此前没有配置过，直接打开 git bash 环境，输入ssh-keygen -t rsa -C &quot;邮件地址&quot; // 邮件地址是 github 账户连续按 3 次回车，最终会在用户目录（C:\\Users{用户名}\\）下生成 .ssh\\id_rsa.pub。打开这个文件，复制里面的内容。再打开 github 页面，点击右上角的头像，选择 Settings，点击左侧的 SSH and GPG keys，点击 New SSH key，将复制的内容粘贴到 Key 一栏，Title 一栏可以随意填写（最好能体现是自己哪一台电脑，方便管理）。添加完成后，在 git bash 环境下输入：ssh -T git@github.com收到提示：Are you sure you want to continue connecting (yes/no)?输入 yes，看到Hi {github 用户名}! You&#39;ve successfully authenticated, but GitHub does not provide shell access.说明配置成功。最后将 github 账户的配置级别设置为全局级别。12git config --global user.name \"github 注册用户名\" // 注意不是昵称git config --global user.email \"github 注册邮箱\"这样在任意位置进行 git 连接，都是指向 github 账户。如果有其他代码仓库的使用需求（例如 gitlab），可以将一个账户设置为全局，另一个设置为仓库级别（仓库级别的优先级最高）。至此，github 相关的设置就完成了。","tags":"软件使用 hexo"},{"title":"使用 nvm 管理和切换不同版本的 node.js","url":"/article/41c01573.html","text":"使用 Hexo 部署博客时，用到的 node.js 版本比较低，但是做其他开发可能会用到更高版本的 node.js。因此，为了方便在不同版本间切换，可以使用 nvm 来管理和切换不同版本的 node.js。Hexo 使用 12.18.3 亲测可行。参考链接：windows中如何将已安装的nodejs高版本降级为低版本一、删除本地安装的 node.js打开命令行，输入 where node，查看现有 node.js 的安装路径。如果用的是 windows terminal，就输入 whereis node。可以先从控制面板里卸载 node.js，卸载成功的话，这个 nodejs 文件夹应该会直接移除。如果没有，可以手动删除。二、安装 nvm从 Releases · coreybutler&#x2F;nvm-windows (github.com) 下载 nvm 安装包：任意位置解压后，运行解压出来的 nvm-setup.exe。选择 nvm 的安装位置：选择 node.js 的安装位置：安装完成后，在命令行中输入 nvm v，检验是否安装成功。三、安装 node.js这里以安装 12.18.3 和 18.14.0 两个版本为例。输入 nvm ls available 查看可用的 node.js 版本。这里只列出来一部分，完整版本可以查看图中给出的链接。先安装 12.18.3：nvm install 12.18.3安装完成后，首先输入nvm use 12.18.3这样会自动配置环境变量，否则看不到 node 和 npm 版本。然后用 node -v 和 npm -v 查看相应版本：但是出现以下错误：查看环境变量，发现 NODE_OPTIONS 环境变量的值为 –openssl-legacy-provider将其修改为一个空格即可正常显示：然后安装 18.14.0。nvm install 18.14.0安装完成后，首先输入 nvm ls 查看已安装版本：可以看到，两个版本都已安装上了，前面带星号表示正在使用的版本。想要切换到 18 版本，输入nvm use 18.14.0即可。如果想卸载某个版本，就使用 nvm uninstall {版本号}。例如：nvm uninstall 18.14.0","tags":"软件使用 hexo"},{"title":"Xilinx XDMA 驱动测试","url":"/article/b435e21.html","text":"Xilinx 对 XDMA IP 核提供了官方驱动及测试代码。下载地址为：Xilinx&#x2F;dma_ip_drivers: Xilinx QDMA IP Drivers (github.com)本文对生成的官方 demo 工程进行测试。测试环境：开发软件：Vivado2021.1FPGA 芯片：Kintex UltraScale+ XCKU5PPCIe 信息：gen3.0 X1 LanePC OS：Ubuntu 20.04一、驱动介绍1.1、驱动源文件在 Xilinx 官方 github 的 dma_ip_drivers 仓库中，共有三个驱动库：QDMA、XDMA 和 VSEC，我们只需要关注 XDMA 即可。1.2、驱动编译1.3、测试文件1.4、测试文件编译二、驱动测试2.1、使用脚本测试2.2、单独测试设备参考资源：Xilinx XDMA驱动代码分析及用法_疯狂的蕉尼基的博客-CSDN博客_xdma驱动","tags":"fpga xdma"},{"title":"Xilinx XDMA IP 核配置详细介绍","url":"/article/251a08fe.html","text":"本文介绍 Xilinx XDMA IP 核配置中的各项参数，以 Kintex UltraScale+ 器件 XCKU5P为例，使用 Vivado2021.1 软件。从 IP Catalog 中输入 PCI，可见 Kintex UltraScale+ 器件共支持三种 PCIE IP 核：其中，第三项 UltraScale+ Integrated Block（PCIE4）for PCI Express 是最基础的 PCIe IP 核，直接封装了 FPGA 中的 PCIe 硬核，需要用户自己封装数据包，使用较为复杂。前两项都是对第三项的进一步封装。第一项 DMA&#x2F;Bridge Subsystem for PCI Express 就是本文中的 XDMA。除 DMA 功能外，此 IP 还支持 AXI Bridge 功能。本文只详细介绍 DMA 功能的相关参数。以下介绍 XDMA 配置中的各项参数。1、Basic1.1、基本选项1.1.1、Functional ModeDMAAXI BridgeAXI Bridge 仅对 Ultrascale+器件，具体可查看 PG194。对于本文，应选择 DMA。1.1.2、ModeBasicAdvanced选择 Advanced 模式多出了以下设置选项：GT Selection：可以选择 PCIe 数据信号连接的 GT Bank。页面最下方的程序加载相关设置1.1.3、Device&#x2F;Port TypeDMA mode 下，只能选默认的 PCI Express Endpoint device；AXI Bridge mode 下，还可以选 Root Port of Express Root Complex。1.1.4、PCIe Block LocationXCKU5P 只能选 X0Y0。Block location 离 PCIe 硬核的位置越近越好，详细可查看 PG213 的附录 B。不同型号的器件支持的 Block Location 不同，有的器件有更多选择，可以查看 PG213 的 Chapter3。1.1.5、GT Selection此选项在 Mode 选择 Advanced 时才会出现，用于选择 PCIe 的通道 0 所在的 GT 四通道。勾选 Enable GT Quad Selection 后，可以选择GT Quad，否则默认使用 GTY Quad 227。根据实际连接情况，选择是否调整 GT Quad。如果连接在其他 Quad 上，就在这里做调整。关于硬件设计时 GT 位置如何选择的详细内容，可以参考 PG213 的附录 B。1.2、PCIe Interface1.2.1、Lane WidthUltraScale+ 系列都包含 PCIE4 块，在含 HBM（高带宽存储器）的 Virtex UltraScale+ 器件中同时包含 PCIE4 块和增强型的 PCIE4C 块。PCIE4 和 PCIE4C 都支持 x1、x2、x4、x8、x16（根据 PG213），但不同的配置可选宽度不同，如 XCKU5P 的 GT Quad 选择 GTY Quad 224 时，不支持 x8 和 x16。根据实际物理连接选择即可。1.2.2、Maximum Link Speed可选 2.5 GT&#x2F;s、5.0 GT&#x2F;s、8.0 GT&#x2F;s，分别对应 PCIe Gen1、Gen2、Gen3 的链路速度，根据实际链路情况选择即可。提供 PCIE4C 块的器件支持 Gen4 的链路速度。1.2.3、Reference Clock Frequency（MHz）可选 100、125、250MHz，需与实际的 PCIe 链路参考时钟一致（与 Tx&#x2F;Rx 信号一起输入到 GT Channel 的伴随时钟）。1.2.4、Reset SourceUser Reset（用户复位）Phy ready（物理就绪）建立链路后，用户复位来自于 PCIe 核。当 PCIe 链路中断时，“User Reset”会断言有效，且 XDMA 会转为复位模式。当链路恢复时，“User Reset”会断言无效。选中“Phy ready”选项时，XDMA 不受 PCIe 链路状态影响。1.2.5、GT DRP clock SelectionInternalexternal选择内部时钟时，将使用 Reference Clock 作为 GT DRP clock。选择外部时钟时，将使用外部自由时钟作为 GT DRP clock。DRP，Dynamic Reconfiguration Port，即动态可重配置端口。由于 GT 可以工作在不同的线速率下，用户可能需要更改内部配置，需要用到 DRP 时钟。通常选择默认的内部时钟即可。当选中 “外部 (External)”时，将从 300 MHz 的外部时钟源提供 DRP 时钟，并且在赛灵思顶层模块中，该时钟将被分割 为 100&#x2F;125 MHz。默认 GT DRP 时钟源为 Internal ，但在“附加调试选项 (Add. Debug Options)”页面 中启用“启用 In-System IBERT (Enable In System IBERT)”选项时，则默认为 external。（此段见 PG213 第五章）1.3、AXI Interface1.3.1、AXI Address width只能选 64。1.3.2、AXI Data Width与 Lane Width 和 Link Speed 的设置有关。例如，前面配置成 X1 8.0GT&#x2F;s 时，这里只能选择 64bit。有多个可选项时，需结合下面的 AXI Clock Frequency 来选择。1.3.3、AXI Clock Frequency与 Lane Width 和 Link Speed 的设置有关。当前面配置成 X1 8.0GT&#x2F;s 时，AXI Data Width 只能选择 64bit，此时 AXI Clock 可选 125MHz 或 250MHz，计算方式为：8Gb&#x2F;s x 1 &#x3D; 64b x 125MHz左边是 PCIe 通道的带宽，右边是 AXI 通道带宽，因此 AXI Clock 应设为 125MHz。1.3.4、DMA Interface optionAXI Memory MappedAXI Stream。二者只能选一种，不能不同的通道用不同的接口，需要慎重选择。AXI MM 用于对接 DDR、RAM 等有地址寻址的外设；AXIS 是流式接口，用于数据包、FIFO 流等。勾选 AXI-Lite Slave Interface 可以启用 AXI4-Lite 从接口，用户逻辑可通过此接口访问 XDMA 的寄存器（不是 PCIe 集成块的寄存器）。此接口不会生成发射到主机的请求。1.3.5、Data ProtectionNoneCheck ParityPropagate Parity启用“Check Parity”时，XDMA 在读取来自 PCIe 的数据时执行奇偶校验检查，并在将数据写入 PCIe 时生成奇偶校验。启用“Propagate Parity”时，XDMA 会将奇偶校验传输至用户 AXI 接口。用户负责在用户 AXI 接口上检查并生成奇偶校验。1.4、仿真调试相关设置1.4.1、Enable PIPE Simulation使能 PIPE 模式仿真，此模式可提升仿真速度。选中该选项时，可启用外部第三方总线功能模型 (BFM) 以连 接至 PCIe 的集成块的 PIPE 接口。欲知详情，请参阅《使用集成端点 PCI Express 块采用 Gen3 x8 和 Gen2 x8 配置 进行 PIPE 模式仿真》(XAPP1184)。（PG213）具体参考 PG195 Chapter5 的仿真部分，以及 PG213 的相关内容。使能后多了 pcie_ext_pipe_ep_usp 接口：1.4.2、Enable GT Channel DRP Ports使能后多了 pcie_ext_ch_gt 接口，PG213 的附录 C 中有简单介绍，具体可能需要查看 GT 通道的相关资料。1.4.3、Enable PCIe DRP PortsPCI Express 安全 IP 模型不支持对 DRP 接口进行仿真。使能后多了 drp 接口，PG213 的附录 C 中有简单介绍，详细使用方法暂未找到，可能需要查阅 IBERT、GT 的相关内容。1.4.4、Additional Transceiver Control and Status Ports这些端口可用于调试收发器相关问题和 PCIe 相关信号，需要根据相应的 GT 用户指南进行驱动。（PG213）使能后多了 pcie4_us_plus_transceiver_debug 接口：1.5、程序加载相关设置此部分内容需要将 Mode 设为 Advanced，才会在 Basic 页面的最下方显示。在 PG195 的第四章的串联配置部分和 PG213 的第四章的串联配置部分都有较为详细的资料。1.5.1、System Reset Polarity此参数用于将 sys_rst 的极性设置为 ACTIVE_HIGH 或 ACTIVE_LOW。通常设为低电平复位即可。1.5.2、Tandem Configuration or Dynamic Function eXchangePG213 第四章的串联配置部分有详细介绍，这里截取部分：PCI Express 属于即插即用协议，即上电时，PCIe 主机将枚举系统。在此流程中，主机将从每个器件读取请求的地址大小，然后向器件分配基址。因此，当主机查询 PCIe 接口时，这些接口必须处于就绪状态，否则不会为其分配基址。 PCI Express 规范声明，当系统电源正常的 100ms 后，PERST# 必须断言无效，并且在 PERST# 断言无效后的 20ms 内 PCI Express 端口必须准备好进行链路训练。这通常被称为 100ms 启动时间要求。串联配置 (Tandem Configuration) 使用 2 阶方法以支持 IP 满足 PCI Express 规范中所述的配置时间要求。此技术支持多种用例，如下所述：串联 PROM（Tandem PROM）：从闪存加载单一 2 阶比特流。串联 PCIe （Tandem PCIe）：从闪存加载第一阶段比特流，并通过 PCIe 链路将第二阶段比特流交付至 MCAP。含现场更新的串联 PCIe（Tandem PCIe with Field Updates）：完成串联 PCIe 初始配置后，在 PCIe 链路保持有效时更新整个用户设计。更新区域（布 局图）和设计结构均已预定义，并且已提供 Tcl 脚本。注释：在 UltraScale+™ 器件中，针对现场更新 (Field Updates)，必须使用串联 PCIe。串联 PROM 不支持现场更 新。串联 + Dynamic Function eXchange：这是较常用的用例，针对任意大小或任意数量的动态区域采用串联配置后接 Dynamic Function eXchange（DFX）。基于 PCIe 的 DFX （DFX over PCIe）：这是标准配置，后接 DFX，使用 PCIe&#x2F;MCAP 作为部分比特流的交付路径。1.5.3、MCAP Bitstream Version register value指定 MCAP 寄存器空间中的 MCAP 比特流版本寄存器的值。默认是 00000000，当在上一步的 Tandem Configuration 中使用了某一功能时，可以修改这个值。2、PCIe：ID如果没有特殊需要，这一页可以不变。尤其是Vendor ID、Device ID，尽量不修改，因为Xilinx提供的驱动是对应这些 VID，DID 的。2.1、ID Initial Values2.1.1、Vendor ID供应商编号，10EE 代表 Xilinx。Vendor ID 不要修改。2.1.2、Device ID器件编号。9031 表示 UltraScale+ 系列，EP 接口，GEn3，X1 Lane。第一位表示器件系列：9 —— UltraScale+8 —— UltraScale7 —— 7 系列第 2 位表示模式：0 —— EP1 —— RP第三位表示链路速度：1 —— Gen12 —— Gen23 —— Gen34 —— Gen4第四位表示链路宽度：1 —— x12 —— x23 —— x44 —— x8F —— x16在官方驱动代码的 XDMA&#x2F;linux-kernel&#x2F;xdma_mod.c （官方驱动地址：Xilinx&#x2F;dma_ip_drivers: Xilinx QDMA IP Drivers (github.com)）中有关于 Vendor ID 和 Device ID 的枚举。如果要新增自定义的 Device ID，除了在 Vivado 中设置，还要修改上述驱动文件中的 pci_ids[] 数组，增加相应的项。2.1.3、Revision ID表示器件或应用的版本；作为器件 ID 的扩展。默认值为 00h；针对应用输入相应的值。2.1.4、Subsystem Vendor ID子系统供应商 ID。进一步限定器件或应用的制造商。在此处输入子系统供应商 ID；默 认值为 10EEh。通常，该值与供应商 ID 相同。将该值设为 0000h 可能导致合规性测试出现问题。2.1.5、Subsystem ID子系统 ID。进一步限定器件或应用的制造商。该值通常与器件 ID 相同；默认值取决于所选通道宽度和链路速度。将该值设为 0000h 可能导致合规性测试出现问题。2.1.6、Enable PCIe-ID Interface如果选中该参数，那么根据选中的 PFx 数量，在核顶层边界处会显 示 PCIe ID 端口 cfg_vend_id、cfg_subsys_vend_id、cfg_dev_id_pf、cfg_rev_id_pf 和 cfg_subsys_id_pf*，并可供用户逻辑驱动。如未选中该参数，则不会在顶层显示这些端口，并根据自定义时设 置的值来驱动这些端口。在 PG213 中有关于 PF IDs 的详细介绍，可以设置多个 PF ID，但是在 XDMA 的配置页面没有关于 PF ID 的内容，貌似 PCIe ID 界面的各项 ID 就对应 PG213 中的 PF0。2.2、Class Code Lookup Assistant类代码（Class Code）用于识别器件的常规功能，ClassCode 寄存器可供系统软件识别当前PCI 设备的分类。分为以下 3 个字节大小的字段：基本类（Base Class）：用于广泛识别器件执行的功能类型，将设备分类为显卡、网卡、PCI 桥等设备子类（Sub-Class）：进一步具体识别器件功能接口 (Interface)：用于定义特定寄存器级别编程接口（如果有），允许不从属于器件的软件与器件进行连接。在 PCI-SIG 网站上提供了类代码编码。具体可以查看 PG213 的第五章的 PF IDs 选项卡，但是没有介绍的太详细。PG213 中可以配置多个 PF，但是 PG195 第二章关于功能的描述中提到，XDMA 只支持 1PF。作为非通用设备，这部分可以不做改动。如果需要使用，可能需要查阅 PCIe 的标准手册。以下不做具体介绍。2.2.1、Use Class Code Lookup Assistant勾选后看起来影响不大。2.2.2、Base Class Menu提供了多种设备类型，与 Base Class Value 一一对应。2.2.3、Base Class Value与 Base Class Menu一一对应，默认是 0x07（Simple communication controllers）。2.2.4、Sub Class Interface Menu提供了多种子类型，与 Sub Class Value 一一对应。2.2.5、Sub Class Value与 Sub Class Interface Menu 一一对应。修改 Base Class Value 时默认值会变。2.2.6、Interface Value与 Base Class Menu 和 Sub Class Interface Menu 有关，修改这两者默认值会变。2.2.7、Class Code由 Base Class Value、Sub Class Value 和 Interface Value 组合而成，共 6 位 16进制数，如默认的 0x070001。3、PCIe：BARsXDMA 最多支持三个 32 位或 64 位 BAR（PG195 第三章）：3.1、PCIe to AXI Lite Master InterfaceAXI-Lite Master 接口用于访问 32bit 位宽用户逻辑寄存器。有博客说这个接口的地址不是全给用户的，有一部分要给 XDMA 寄存器？？？3.1.1、64bit Enable打勾后 BAR 空间为 64 位。32 位 BAR 的地址空间最小可达 128 字节或者最大可达 2 千兆字节 (GB)。用于内存或 I&#x2F;O。64 位 BAR 的地址空间最小可达 128 字节或者最大可达 8 艾字节 (EB)。仅用于内存。当 BAR 设为 64 位时，它使用下一个 BAR作为扩展地址空间，并使下一个 BAR 不可访问。3.1.2、Prefetchable用于预取内存空间。每个 64 位 BAR 空间均可选择是否可预取。3.1.3、Size and ScaleSize 和 Scale 合起来表示 AXI-Lite master 接口的映射空间的大小。3.1.4、ValueValue 与 前面的 Size 和 Scale 是一一对应的，当修改空间大小时，Value 也会相应地改变。在生成的仿真代码中，找到 usp_pci_exp_usrapp_tx.v（不同的软件版本或硬件型号可能这里的明明不一样，找 usrapp_tx 相关的文件就行）：里面的函数 FNC_CONVERT_RANGE_TO_SIZE_32 就是用来完成从 Value 值到映射空间范围的转换。可以对照一下，Vivado 中设为 1M 大小时，Value 值自动变化为 FFF00000，与上述函数中的 33’h0010_0000（1M） 正好对应。3.1.5、PCIe to AXI Translation主机访问地址与 AXI 映射地址不同，PCIe to AXI Translation 用于主机访问地址与 AXI 地址之间的映射。AXI 地址 &#x3D; BAR 地址 + 这里设置的偏置。例如，PCIe to AXI Translation 设为 0xC0000000 时，主机向 0x0000008 地址写入数据时，AXI 接口实际写入 0xC0000008 地址。3.2、PCI to DMA Interface默认使能，因为是 XDMA 的主要功能，可实现最多 4 个 H2C&#x2F;C2H 通道。可以选择是否使能 64bit BAR 及预取功能。3.3、PCIe to DMA Bypass Interface到达 PCIe 到 DMA 旁路 BAR 的主机请求都将被发送到此模块。旁路主端口属于 AXI4 MM 接口，支持读写访问。可配置的内容与 3.1 中 AXI-Lite Master 接口的内容相同，这里不再重复。4、PCIe：MISCMISC 指 Miscellaneous（其它）。XDMA 的 IRQ 模块会接收到来自用户逻辑的中断连线，其数量可配置，每个 DMA 通道 1 条中断连线。此模块负责基于 PCIe 生成中断。可在 IP 配置期间指定对 MSI-X、MSI 和传统中断的支持：Legacy 中断，共享式MSI 中断，最多支持 32 个中断向量，且要求中断向量连续MSI-X 中断，可以支持更多中断请求，不要求中断向量连续主机可在 IP 配置期间从指定的受支持中断列表中启用 1 个或多个中断类型。IP 在任意给定时间仅生成 1 种类型的中断，即使启用多个中断类型也是如此。MSI-X 中断优先于 MSI 中断，MSI 中断优先于传统中断。当存在任一已断言有效或暂挂的中断时，主机软件不得切换（启用或禁用）中断类型。关于三种中断的信息，可以查阅 PG195 的第三章的 IRQ 模块和附录 A 的中断处理章节。对于7系列：MSI 中断和 MSI-X 中断只能选择一个，否则会报错。如果选择了 MSI 中断，可以选择 Legacy 中断。如果选择了 MSI-X 中断，则 Legacy 必须选择 None。UltraScale+ 系列没有这个限制。4.1、User Interrupts可选 1~16 个用户中断。调整这里的数量，usr_irq_req 和 usr_irq_ack 的位宽会相应变化，如设为 10 时：这里的用户中断是从用户逻辑产生的通知 CPU 的中断，不包含 XDMA 本身产生的中断。用户逻辑必须使 usr_irq_req 保持处于高电平有效状态（即使接收到 usr_irq_ack (acks) 后也是如此），以使中断暂挂寄存器保持断言有效。这样即可支持驱动程序内的中断服务例程 (ISR) 判定中断源。当驱动程序接收用户中断后，驱动程序或软件即可通过断言 usr_irq_req 无效来将硬件应响应的用户中断源复位。4.2、Legacy Interrupt Settings可以在四个传统中断 INTA、INTB、INTC 或 INTD 中任选一个，或都不选（None）。4.3、MSI Capabilities默认启用“MSI Capabilities”，并启用 1 个矢量。可选矢量最大数量为 32。一般情况下，Linux 针对 MSI 仅支持 1 个矢量，Xlinx 的 Linux 也仅支持 1 个 MSI 矢量。该选项可禁用。4.4、MSI-X Capabilities可以使能 MSI-X 事件。对于 MSI-X，DMA 支持最多 32 个不同中断源，MSI-X 由最多 16 个可用 DMA 中断矢量和最多 16 个可用用户中断矢量组成。4.5、Miscellaneous4.5.1、Finite Completion Credits有限完成信用值。在支持有限完成信用值的系统上，可启用该选项以改善性能。4.5.2、Extended Tag Field扩展标签字段。默认情况下使用 6 位完成标签。对于 UltraScale™ 和 Virtex®-7 器件，“扩展标签 (Extended Tag)”选项可提供 64 个标签。对于 UltraScale+™ 器件，“扩展标签 (Extended Tag)”选项可提供 256 个标签。如果不选中“Extended Tag”，DMA 会针对所有器件使用 32 个标签。4.5.3、Configuration Extend Interface配置扩展接口。可选择 PCIe 扩展接口以增加配置空间。选中“ConfigurationExtend Interface”时，由用户负责添加接口扩展逻辑以使其正常工作。4.5.4、Configuration Management Interface配置管理接口。选中该选项时，即可将 PCIe 配置管理接口置于顶层。4.6、Link Status Register链路状态寄存器。默认情况下，选中“Enable Slot Clock Configuration”。这意味着在链路状态寄存器中启用插槽配置位。5、PCIe：DMADMA 通道数、ID 等的选择。根据实际的业务来选择。例如有 4 路 ADC 数据传输，可以选择 C2H 为 4，当然，也可以 4 路ADC数据在 FPGA 内合并后成 1 路，然后只选择 C2H 为 1 。5.1、DMA 参数说明5.1.1、Number of DMA Read Channels（H2C）DMA 读取通道数，可选 1-4。选择 AXI 接口时，多个 DMA 通道共用一个 AXI 信道。选择 AXI-Stream 接口时，每个 DMA 通道都有一个独立的信道。DMA 读取指 DMA 从主机读取，所以是 H2C，AXI-Stream 接口为 master 接口。5.1.2、Number of DMA Write Channels（C2H）DMA 写入通道数，可选 1-4。5.1.3、Number of Request IDs for Read channel读取通道的请求 ID 数。选择每个通道未完成的请求的最大数量。可用选项范围为 2 到 64。5.1.4、Number of Request IDs for Write channel写入通道的请求 ID 数。选择每个通道未完成的请求的最大数量。可用选项范围为 2 到 32。5.1.5、Descriptor Bypass for Read（H2C）用 4 位 2 进制数表示，默认是 0000。对应读取的描述符旁路。可用于所有选定的读取通道。每个二进制数字均对应于 1 条通道。LSB 对应于通道 0。位元位置的值为 1 表示对应的通道已启用描述符旁路。5.1.6、Descriptor Bypass for Write（C2H）用 4 位 2 进制数表示，默认是 0000。可用于所有选定的写入通道。每个二进制数字均对应于 1 条通道。LSB 对应于通道 0。位元位置的值为 1 表示对应的通道已启用描述符旁路。5.1.7、AXI ID WidthAXI ID 宽度。默认位宽为 4 位。也可以选择 2 位。AXI ID 和前面的 Request IDs 的关系？？？？5.1.8、DMA Status port使能 DMA 状态端口，可用于所有通道。5.2、其他6、Debug Options6.1、调试参数说明6.1.1、JTAG Debugger该选项用于启用 JTAG 调试。6.1.2、LTSSM State Debug Logic该选项可显示从链路建立开始后执行的所有 LTSSM 状态转换。6.1.3、In-System IBERT该选项用于检查串行链路的眼图，确认该链路是否按期望的链路速度运行。如需了解有关 In-System IBERT 的更多信息，可参阅《In-System IBERT LogiCORE IP 产品指南》(PG246)。6.1.4、Add Mark Debug Utility该选项可通过 mark_debug 属性添加预定义的 PCIe 信号，以便在 ILA 中添加这些信号用于调试。6.1.5、Enable Descrambler该选项在 PCIe 核内集成解扰器模块的加密版本，用于对采用 Gen3 链路速度模式往来 PCIe 集成块的 PIPE 数据进行解扰。6.1.6、PCIe Debug Ports启用该选项后，下列端口即可用：6.2、其他7、Share logic以下复制于 PG213 第五章。7.1、GT Wizard Option可选择在设计示例中包含 GT Wizard，然后 GT Wizard IP 将被添加到设计示例区域中。用户可重新配置 IP 以便进一步进行测试。默认情况下，在 PCIe IP 核中，GT Wizard IP 将作为层级 IP 交付，用户无需对其进行重新自定义。如需获取信号描述及其它详细信息，可参阅《UltraScale 架构 GTY 收发器用户指南》(UG578) 或《UltraScale 架构 GTH 收发器用户指南》(UG576)。7.2、GT Common Option该选项用于共享设计中使用的 GT COMMON 块，前提是选中 Gen2 （对应 PLL 选择为“QPLL1”）和 Gen3 链路速度。当选中“Include GT COMMON in example design”时，将在支持封装中提供 GT COMMON 块实例，此支持封装位于赛灵思顶层文件内，并且可供核或外部逻辑使用。使用“Include GT COMMON inside GT Wizard”时，GT COMMON 可供外部逻辑共享。选中“No Sharing when inside GT Wizard and PCIe”时，不允许共享 GT COMMON 块。同时选中“Include GT COMMON in example design”和“Include GT Wizard in example design”时，必须使用来自相同配置的 GT Wizard IP 的设计示例工程的最新 GT COMMON 设置。此特定选项用于交付静态 GT COMMON 封装，其中包含仅适用于 2017.3 时间范围的最新设置。8、GT Settings8.1、GT 设置说明8.1.1、Enable Auto RxEq启用自动接收方均衡。当此参数设置为 True 时，它会自动选择“接收方均衡 (Receiver Equalization)”模式（LPM 或 DFE）。True：默认值为 DFE，但将根据信道特性更改为 LPM。False：默认值为 DFE 且可通过设置“外形尺寸驱动的插入损失调整 (Form Factor Driven Insertion Loss Adjustment)”来进行更改。8.1.2、Form Factor Driven Insertion Loss Adjustment表示根据外形尺寸选择，以奈奎斯特频率运行时发射器到接收器的插入损失。其中提供了 3 个选项：芯片到芯片 (Chip-to-Chip)：值为 5 dB。插卡 (Add-in Card)：这是默认选项，值为 15 dB。背板 (Backplane)：值为 20 dB。此插入损失值适用于 GT Wizard 子核。8.1.3、 Link Partner TX Preset链路合作伙伴 TX 预置。默认值为 4，不建议更改。对于部分系统，预置值 5 可能更适合。在“GT 设置 (GT Settings)”选项卡上提供了此参数以供使用。8.1.4、Disable GT Channel LOC Constraint这一参数手册中没有说明。从字面意思来看，勾选后将不对 GT Channel 做物理约束，此时用户应手动约束。8.2、其他参考资料：PG213PG195","tags":"fpga pcie xdma"},{"title":"Vivado 约束功能","url":"/article/68bf4f17.html","text":"Xilinx 的 Vivado 软件使用 XDC（Xilinx Design Constraints）文件进行约束，XDC 相当于在标准的 SDC（Synopsys Design Constraints）约束格式的基础上，增加了与 Xilinx 硬件相关的一些约束。一个工程可以建立多个约束集，一个约束集可以含多个 XDC 文件或 tcl 脚本文件。在 Sources 栏的 Constraints 目录上右键选择 Edit Constraints Sets，即可管理约束集，可以增加约束集，也可以为某一个约束集增加或删减约束文件。通常可以将物理约束和时序约束放在不同的 XDC 文件中，便于管理。在文件属性界面，可以选择 XDC 文件是否使能和作用阶段：","tags":"fpga vivado"},{"title":"Xilinx FPGA 物理约束","url":"/article/139b4946.html","text":"FPGA 设计中设计两种约束：物理约束和时序约束。其中，物理约束常用的是：I&#x2F;O 约束，包括位置和 I&#x2F;O 标准布局约束，例如单元位置布线约束，例如固定布线配置约束，例如配置模式以下参考官方文档 UG903，介绍 Vivado 中使用 XDC 文件或 Tcl 脚本进行约束时的语法。大多数物理约束写法为：1set_property &lt;property&gt; &lt;value&gt; &lt;object list&gt;1、I&#x2F;O 约束包括电平约束、引脚约束和驱动能力等。常用的约束命令有：12345678# 管脚约束set_property PACKAGE_PIN 管脚号 [get_ports &#123;引脚名称&#125;]# 电平约束set_property IOSTANDARD LVCMOS33 [get_ports &#123;引脚名称&#125;]# 上拉约束set_property PULLUP true [get_ports 引脚名称]# 下拉约束set_property PULLDOWN true [get_ports 引脚名称]其他命令：12345678910111213# 驱动能力约束set_property DRIVE &lt;2 4 6 8 12 16 24&gt; [get_ports &#123;引脚名称&#125;]# 抖动约束set_property SLEW &lt;SLOW|FAST&gt; [get_ports &#123;引脚名称&#125;]# IN_TERM# DIFF_TERM# KEEPER# PULLTYPE# DCI_CASCADE# INTERNAL_VREF# IODELAY_GROUP# IOB# IOB_TRI_REG8、网表约束网表约束设在网表对象上，例如 ports、pins、nets 或 cells，需要综合和实现以特殊的方式处理它们。网表约束包括：CLOCK_DEDICATED_ROUTEMARK_DEBUGDONT_TOUCHLOCK_PINS9、Vivado 中的约束在 Vivado 中，可以在设计流的任意阶段做 I&#x2F;O 和时钟规划。Pre-RTL I&#x2F;O PlanningRTL I&#x2F;O PlanningNetlist I&#x2F;O Planning","tags":"fpga"},{"title":"Xilinx XDMA IP 核使用与调试","url":"/article/827aef65.html","text":"通过官方例程和官方驱动初步测试 XDMA IP 核。测试软硬件环境：Vivado2021Kintex UltraScale+ FPGAPCIe3.0 x1本文简单介绍 XDMA 基于官方 demo 的仿真和使用。一、添加 IP 核新建工程，然后创建 block design，添加 XDMA IP 核，全称是DMA&#x2F;Bridge Subsystem for PCI Express。双击进入配置界面。二、配置 IP 核2.1、Basic这一界面需要根据实际也硬件连接来配置。如果需要调整 GT Quad，可以将 Mode 默认的 Basic 改为 Advanced。这里将 PCIe 接口选择成与物理设计一致的 8GT&#x2F;s、X1 lane。AXI 接口的设计可以根据 PCIe 的速率来设置。例如，PCIe 的速度是 8Gb&#x2F;s，而且 AXI 的Data Width 在当前 设置下只能选择 64bit，所以 AXI 时钟选为 125MHz，因为 64bit x 125MHz 刚好也是 8Gb&#x2F;s。DMA 的接口可以选择 AXI MM 或者 AXI Stream，这里先测试前者。2.2、PCIe ID这一页可以保持默认，因为会用到 Xilinx 官方驱动 。这里的设计与官方驱动是对应的，否则如果修改了这里，还需要修改驱动。2.3、PCIe: BARsBARs往往是用来存放一些配置信息的，在主机端和板卡端都有各自相对应的BAR空间，这两个BAR空间相互关联，即一方对自己的BAR空间写入数据时，另一方也会在自己的BAR空间中收到该数据，因此也要注意避免同时读写的问题。pcie to axi translation 是从 PCIe 地址（主机地址）到 AXI 地址的映射。例如，将 pcie to axi translation 设为 0x80000000 时，当主机写入到 0x00000004 时，实际写入 AXI 地址为 0x80000000 + 0x00000004 &#x3D; 0x80000004，反之做减法。Value 是对11应的 Size 的编码值，用于初始化时换算空间大小（从官方例程的仿真代码中的 usp_pci_exp_usrapp_tx.v 中的 FNC_CONVERT_RANGE_TO_SIZE_32 函数可以看到这一过程）。为了测试用于访问用户寄存器的 AXI Lite-Master 接口，这里勾选 PCIe to AXI Lite Master Interface，由于寄存器通常为 32bit，所以不勾选 64bit Enable。大小就用默认的 1M。其他的设置暂时先不修改。2.4、PCIe: MISC暂时不修改，只使用一个 User Interrupt。2.5、PCIe: DMA先使用单通道，剩下的不改。2.6、Debug Options暂时不改。2.7、Shared Logic暂时不改。2.8、GT Settings暂时不改。3、导出例程右键点击模块，选择 Open IP Example Design。会弹出对话框创建新的工程，选择目录即可。生成的新工程中，顶层文件 xilinx_dma_pcie_ep 主要完成以下功能：例化时钟 buffer例化复位 buffer例化前述配置的 XDMA IP 核例化 xdma_app 模块其中，xdma_app 模块的功能主要是为 XDMA 的 AXI-MM-Master 例化 64b x 512 的 BRAM，为 AXI-Lite-Master 接口例化 32b x 1024 的 BRAM。修改 xdc 文件：1）时钟2）复位未完待续。。。先写仿真再写硬件调试！","tags":"fpga pcie xdma"},{"title":"AXI Verification IP 的使用","url":"/article/8f32c91b.html","text":"Xlinx AXI Verification IP 核（下简称 AXI VIP）用于仿真用户设计的基于 AXI 的 IP 核。AXI VIP 支持的 AXI 协议版本包括 AXI3、AXI4 和 AXI4-Lite。AXI VIP 是未加密的 SystemVerilog 源码，由一个 SystemVerilog 类库和可综合的 RTL 组成。AXI VIP 综合为 wire，不会影响性能。1、三种工作模式AXI VIP 支持三种工作模式：1.1、AXI master VIP生成 AXI 命令和写负载，并将其写入 AXI 系统。1.2、AXI slave VIP响应 AXI 命令，并生成读负载和写响应。1.3、AXI pass-through VIP检查经过它的所有 AXI 传输，可被配置成三种模式：Monitor only、Master 和 Slave。2、使用连接方式2.1、AXI Master VIP 拓扑2.2、AXI Slave VIP 拓扑2.3、AXI Pass-Through VIP 拓扑3、IP 设置4、Test Bench 拓扑5、示例5.1、建立 BD 工程本例中，使用一个 AXI VIP master 模块连接一个 AXI 接口的 BRAM。整体框图如下：具体建立步骤：5.1.1、添加并配置 AXI Verification IP选择接口类型，其他保持默认。5.1.2、添加并配置 AXI BRAM Controller选择好接口类型和位宽，其他保持默认即可。5.1.3、运行自动连线点击 Run Connection Automation，选中所有可选内容，然后点 OK。生成的原理图与前文中差不多即可，主要引出时钟和复位信号就行。可以运行一下 Validate Design 来验证是否有明显问题。5.1.4、分配地址正常情况下，Address Editor 中地址已经分配好，如果没有，可以手动解决。5.1.5、导出工程分别在 bd 文件上右键运行 Generate Output Products 和 Create HDL Wrapper，前者选择 Out of context per IP。其中，生成的 design_1_wrapper.v 就是仿真的待测模块（DUT）。5.2、创建仿真文件对 AXI VIP IP 核进行仿真需要用 SystemVerilog 语言，因此在建立仿真文件时需要选择 SystemVerilog。5.3、导入需要的包需要导入两个包：12import axi_vip_pkg::*;import &lt;component_name&gt;_pkg::*;第一个 import 不需要更改。第二个 import 需要查询具体工程的信息。获取 **的方法：方法一：运行 get_ips *vip*：12get_ips *vip*design_1_axi_vip_0_0方法二：从 Vivado UI 界面中查找：故本设计中的为 design_1_axi_vip_0_0。5.4、创建代理（agent）1）首先根据 AXI VIP 的接口模式声明 agent，声明的形式为：因为这里对 Master VIP 进行仿真，所以声明为：1design_1_axi_vip_0_0_mst_t master_agent;2）然后对 master_agent 进行实例化，实例化方法为：1agent = new(\"my VIP agent\", &lt;hierarchy_path&gt;.IF)需要获得 IF 的 hierarchy path。建立含 AXI VIP 的 bd 工程，对一个空的 test bench 运行一次 Run Simulation 以获取 VIP 所在的层次路径。得到如下信息：123# run 1000nsBlock Memory Generator module top_tb.dut.design_1_i.axi_bram_ctrl_0_bram.inst.\\native_mem_mapped_module.blk_mem_gen_v8_4_4_inst is using a behavioral model for simulation which will not precisely model memory collision behavior.XilinxAXIVIP: Found at Path: top_tb.dut.design_1_i.axi_vip_0.inst因此 agent 实例化为：1master_agent = new(\"Master_AXI_VIP\", top_tb.dut.design_1_i.axi_vip_0.inst);然后启动 agent：1master_agent.start_master();实例化和启动的代码都要放在语句块中。5.5、创建 write transaction","tags":"fpga axi"},{"title":"Verilog 生成语句 generate","url":"/article/32a1b60b.html","text":"生成语句 generate 用于动态生成 Verilog 代码，便于生成参数化模块。生成语句能控制变量的声明、任务或函数的调用，还能对实例引用进行全面的控制。在以下场合使用生成语句可大大简化程序的编写过程：对矢量的多个位进行重复操作进行多个模块的实例引用的重复操作根据参数的定义来确定程序中是否应该包括某段 Verilog 代码Verilog 中有三种创建生成语句的方法：循环生成条件生成case 生成一、循环生成语句 generate-for循环生成语句允许对以下模块或模块项进行多次实例引用：变量声明模块用户定义原语、门级原语连续赋值语句initial 和 always 块对于 generate-for 语句：（1) 必须有genvar关键字定义for语句的变量。（2）for语句的内容必须加begin和end（即使就一句）。（3）for语句必须有个名字。示例：123456789101112131415161718module generate_for # ( parameter N = 32 ) ( output [N-1: 0] out, input [N-1: 0] i0, input [N-1: 0] i1 ); genvar j; generate for(j=0; j&lt;N; j=j+1) begin : xor_loop xor g1(out[j], i0[j], i1[j]); end endgenerateendmodule生成的模型为：展开后共 32 个 异或门。二、条件生成语句 generate-if条件生成语句类似于 if-else 结构，可以在设计模块中有条件地调用（实例引用）以下结构：模块用户定义原语、门级原语连续赋值语句initial 或 always 块if 的条件必须是常量表达式。根据条件，最多执行一个代码块，因为有可能一个都不执行。用法：123456generate if(常量表达式) 代码块; else 代码块;endgenerate三、case 生成语句 generate-casecase 生成语句可以在模块中根据条件调用多个结构中的一个，可以调用（实例引用）以下结构：模块用户定义原语、门级原语连续赋值语句initial 或 always 块用法：12345678generate case(N) 1: 代码块; 2: 代码块; ... default: 代码块; endcaseendgenerate","tags":"fpga verilog"},{"title":"Verilog 系统任务与函数","url":"/article/a8867a0b.html","text":"系统任务在 Verilog HDL 语言中属于行为级建模，系统任务的调用要出现在 initial 与 always 结构中，一般在仿真代码中使用。所有的任务都以 $ 开头。测试环境：Vivado2021.1 自带仿真器 XSIM。〇、总述根据 Verilog HDL 标准，共有十类系统任务（函数）：这里挑选常用的几类进行总结。一、显示任务（Display tasks）系统任务显示组分为三类：显示和写入任务、选通（strobed）监控任务和连续监控任务。1.1、$display 和 $write$display 和 $write 都是用来显示和输出信息，格式为：12$display(p1,p2,....pn);$write(p1,p2,....pn);p1 称为“格式控制”，p2,…pn 称为“输出表列”。参数 p2,…pn 按 p1 中给定的格式输出。两者的区别在于：$display 输出后自动换行$write 不换行，可以在一行中多次调用格式控制的内容包括在双引号中，由输出格式指定输出表列中的变量输出的形式，部分字符需要转义表示。具体见如下表格。输出格式描述%h or %H十六进制。%d or %D十进制。%o or %O八进制。%b or %B二进制。%c or %CASCII 码字符。%l or %LDisplay library binding information.%v or %V输出标量网络型数据的信号强度，例如Supply dirve、Pull drive 等。%m or %M输出等级层次的名字，不接受参数。%s or %S字符串。%t or %T以当前时间格式输出。%u or %UUnformatted 2 value data.%z or %ZUnformatted 4 value data.%e or %E指数形式输出实数。%f or %F十进制形式输出实数。%g or %G以指数或十进制形式输出实数，无论各种格式都以较短的结果输出其中 %l、%u、%z 是在 Verilog IEEE 标准中列出的。转义字符描述\\n换行\\t制表符\\\\反斜杠\\“双引号\\ddd1-3位八进制数表示的 ASCII 字符 (0 ≤ d ≤ 7)。%%百分号举例：12345678910111213141516171819202122232425262728293031module tb_display();reg [31: 0] in1;reg [31: 0] in2;reg [31: 0] out;wire wire_sgn;assign wire_sgn = out;initial begin in1 = 32'd33; in2 = 32'd34; out = 32'd35; $display(\"in1 = %b, in2 = %b and out = %b\", in1, in2, out); $display(\"in1 = %o, in2 = %o and out = %o\", in1, in2, out); $display(\"in1 = %d, in2 = %d and out = %d\", in1, in2, out); $display(\"in1 = %h, in2 = %h and out = %h\", in1, in2, out); $display(\"in1 = %c, in2 = %c and out = %c\", in1, in2, out); $display(\"in1 = %e, in2 = %e and out = %e\", in1, in2, out); $display(\"in1 = %f, in2 = %f and out = %f\", in1, in2, out); $display(\"in1 = %g, in2 = %g and out = %g\", in1, in2, out); $display(\"%m\"); $display(\"wire signal strength = %m\", wire_sgn); $display(\"\\n \\t \\\\ \\\" \\043 %%\"); $finish;endendmodule输出结果为：123456789101112in1 = 00000000000000000000000000100001, in2 = 00000000000000000000000000100010 and out = 00000000000000000000000000100011in1 = 00000000041, in2 = 00000000042 and out = 00000000043in1 = 33, in2 = 34 and out = 35in1 = 00000021, in2 = 00000022 and out = 00000023in1 = !, in2 = \" and out = #in1 = 3.300000e+01, in2 = 3.400000e+01 and out = 3.500000e+01in1 = 33.000000, in2 = 34.000000 and out = 35.000000in1 = 33, in2 = 34 and out = 35tb_sys_taskwire signal strength = tb_sys_taskx \\ \" # %对于显示数字前有占位空格或补 0 问题，可以在输出格式符的字母前加 0 来解决：1234$display(\"in1 = %0b, in2 = %0b and out = %b\", in1, in2, out);$display(\"in1 = %0o, in2 = %0o and out = %o\", in1, in2, out);$display(\"in1 = %0d, in2 = %0d and out = %d\", in1, in2, out);$display(\"in1 = %0h, in2 = %0h and out = %h\", in1, in2, out);输出为：1234in1 = 100001, in2 = 100010 and out = 00000000000000000000000000100011in1 = 41, in2 = 42 and out = 00000000043in1 = 33, in2 = 34 and out = 35in1 = 21, in2 = 22 and out = 00000023还有一种输出方式：1$display($time, , \"display1 data = \", data);另外也可以用 $display 和 $write 来打印当前时间：12$display(\"cur time = %t\", $time);$write(\"cur time = %t\", $time);输出为：12cur time = 0cur time = 01.2、$strobe$strobe 命令提供了在选定时间显示模拟数据的能力。该时间是当前仿真时间的末尾，仿真时间马上要完成的时候，此时该仿真时间内的所有仿真事件都已完成。使用方法与 $display 一样，区别在于：$strobe 在当前仿真时间结束时完成$display 立即执行。$strobe 与 $monitor 的区别在于：$strobe 在调用后只输出一次。$monitor 在调用后，只要参数列表发生变化，就会自动输出。测试：123456789101112131415161718192021222324module tb_strobe();reg [31: 0] data;reg clk;initial begin clk = 0; data = 0; forever #5 clk = ~clk;endalways @(posedge clk) begin if(data != 32'h100) data = data + 1; else data = 0;endinitial begin forever @(negedge clk) $strobe (\"At time %0d, data is %h\", $time, data);endendmodule波形：日志输出为：1234567At time 10, data is 00000001At time 20, data is 00000002At time 30, data is 00000003At time 40, data is 00000004At time 50, data is 00000005At time 60, data is 00000006...1.3、$monitor$monitor 任务提供了监视和显示参数列表中指定的变量或表达式的值的能力。当调用了带有一个或多个参数的 $monitor 任务时，仿真器会建立一种机制，使得每当参数列表中的变量或表达式的值（除了 $time、$stime 和 $realtime 这些系统功能外）改变时，整个参数列表都会在时间步的末尾输出，就像调用了 $display 一样。如果两个或多个参数同时改变值，则只会产生一个显示新值的显示。在任何时候，只有一个 $monitor 显示列表可以激活；但是，在仿真过程中，可以多次发出带有新显示列表的新 $monitor 任务。 需要在程序中及时控制 monitor 的开启和关闭，使得不同的模块都可以调用 monitor，同时调用两个 monitor 会自动关闭前一个（后面的测试证实不是这样）。$monitoron 和 $monitoroff 任务通过控制监控标志来启用和禁用 monitor 任务。使用 $monitoroff 可以关闭监控标志并禁用 monitor。$monitoron 任务可用来打开监控标志，以启用 monitor，并且最近调用的 $monitor 可以恢复它的显示。$monitoron 调用后会立即执行一次输出，无论参数列表中的值是否发生变化；这可以用来在监控任务开始时设置初值。监控标志默认在仿真开始时打开。用法：12$monitor($time, , \"monitor1 data = \", data);$monitor(\"monitor2 @ %d, data = %d\", $time, data);1.3.1、测试一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263module tb_monitor(); reg [31: 0] data1; reg [31: 0] data2; reg clk; initial begin clk = 0; data1 = 0; data2 = 0; forever #5 clk = ~clk; end initial begin #10; // time 10 $monitor(\"At time %0d, data1=%0d, data2=%0d\", $time, data1, data2); #20; // time 30 data1 = 10; #30; // time 60 data2 = 20; #10; // time 70 data1 = 30; $monitoroff; #10; // time 80 data1 = 40; #10; // time 90 data2 = 50; $monitoron; #10; // time 100 data1 = 60; #10; // time 110 $monitoroff; #10; // time 120 data2 = 70; $monitor(\"new task: At time %0d, data1=%0d, data2=%0d\", $time, data1, data2); #10; // time 130 data1 = 80; #10; // time 140 data2 = 90; $monitoron; #10; // time 150 data1 = 100; #10; // time 160 data2 = 110; #10; // time 170 data1 = 120; $finish; endendmodule输出为：1234567891011At time 10, data1=0, data2=0At time 30, data1=10, data2=0At time 60, data1=10, data2=20At time 90, data1=40, data2=50At time 100, data1=60, data2=50new task: At time 140, data1=80, data2=90At time 140, data1=80, data2=90At time 150, data1=100, data2=90new task: At time 150, data1=100, data2=90At time 160, data1=100, data2=110new task: At time 160, data1=100, data2=110可以看出：1） $monitor() 调用的时刻，monitor 会输出（如 time 10 时刻）。2）参数列表中任一参数变量发生变化，monitor 都会输出（如 time 30、60 时刻）。3）$monitoroff 所在时刻，monitor 不输出（如 time 70）。4）$monitoron 所在时刻，monitor 会输出（如 time 90）。5）$monitoroff 执行后，再执行 $monitor()，monitor 不会输出（如 time 120、130）。与前文所述存在监控标志用以使能 monitor，且监控标志初始时是开启的相符。6）$monitoroff 之后，增加新的 monitor()，然后执行 $monitoron 重新打开后，两个 $monitor() 语句的内容都会输出（如 time 140、150、160），与前文所述不符。7）$finish 所在的时刻，即便信号值发生变化，也不会被 monitor 输出（如 time 170）。1.3.2、测试二上述第 6 条与前文所述“在任何时候，只有一个 $monitor 显示列表可以激活”相矛盾。修改代码，在一个 initial 语句块中一次性调用三个 $monitor() 任务。123456789101112131415161718initial begin #10; $monitor(\"monitor 01: At time %0d, data1=%0d, data2=%0d\", $time, data1, data2); $monitor(\"monitor 02: At time %0d, data1=%0d, data2=%0d\", $time, data1, data2); $monitor(\"monitor 03: At time %0d, data1=%0d, data2=%0d\", $time, data1, data2); #20; data1 = 10; #30; data2 = 20; #10; data1 = 30; $monitoroff; $finish;end输出为：123456789monitor 01: At time 10, data1=0, data2=0monitor 02: At time 10, data1=0, data2=0monitor 03: At time 10, data1=0, data2=0monitor 01: At time 30, data1=10, data2=0monitor 02: At time 30, data1=10, data2=0monitor 03: At time 30, data1=10, data2=0monitor 01: At time 60, data1=10, data2=20monitor 02: At time 60, data1=10, data2=20monitor 03: At time 60, data1=10, data2=20说明同一个语句块（此例中的 initial 块）中的多个 $monitor() 是可以同时激活的。测试不同语句块中的多个 $monitor() 能否同时激活：123456789101112131415161718192021222324252627282930initial begin #10; $monitor(\"monitor 01: At time %0d, data1=%0d\", $time, data1); #20; data1 = 10; #30; data1 = 20; #10; data1 = 30;endinitial begin #10; $monitor(\"monitor 02: At time %0d, data2=%0d\", $time, data2); #20; data2 = 10; #30; data2 = 20; #10; data2 = 30; #30; $finish;end输出为：12345678monitor 01: At time 10, data1=0monitor 02: At time 10, data2=0monitor 01: At time 30, data1=10monitor 02: At time 30, data2=10monitor 01: At time 60, data1=20monitor 02: At time 60, data2=20monitor 01: At time 70, data1=30monitor 02: At time 70, data2=30两个 initial 块中的 monitor 都能输出，说明同一 module 的不同语句块中可以同时存在多个 monitor。1.3.3、测试三再测试下多个 module 中的 monitor 能否同时使用：1）顶层模块123456789101112131415161718192021222324252627282930313233343536373839module tb_monitor_topmodule();reg clk;reg [31:0] data;initial begin clk = 0; forever #5 clk = ~clk;endtb_monitor_submodule1 sub1( .clk(clk), .data(data));tb_monitor_submodule2 sub2( .clk(clk), .data(data));initial begin #10; data = 10; #10; data = 20; #10; data = 30; #10; data = 40; #10; data = 50; #10; data = 60; #10; data = 70;endendmodule2）子模块112345678910module tb_monitor_submodule1( input wire clk, input wire [31: 0] data);initial begin $monitor(\"sub1 @ %t: data = %0d\", $time, data);endendmodule3）子模块212345678910module tb_monitor_submodule2( input wire clk, input wire [31: 0] data);initial begin $monitor(\"sub2 @ %t: data = %0d\", $time, data);endendmodule输出为：12345678910111213141516sub1 @ 0: data = xsub2 @ 0: data = xsub2 @ 10000: data = 10sub1 @ 10000: data = 10sub2 @ 20000: data = 20sub1 @ 20000: data = 20sub2 @ 30000: data = 30sub1 @ 30000: data = 30sub2 @ 40000: data = 40sub1 @ 40000: data = 40sub2 @ 50000: data = 50sub1 @ 50000: data = 50sub2 @ 60000: data = 60sub1 @ 60000: data = 60sub2 @ 70000: data = 70sub1 @ 70000: data = 70可以看出，两个子模块在 $monitor() 中设置的参数变量发生改变时，相应的 monitor 都做了输出。综合以上三个测试结果，可以得出不存在只能有一个 monitor 工作的问题。同时开启多个 monitor 时，都能同时工作，无论是在同一语句块内、不同语句块内还是不同 module 内。从很多博客中可以看到多个 monitor 不能同时工作的论述而且附有仿真代码和结果，这里的矛盾可能是因为本文使用的 Vivado2021.1 版本较新，对仿真器的功能进行了升级，不过并不确定是否如此。二、文件 I&#x2F;O 任务（File I&#x2F;O tasks）基于文件的操作的系统任务和功能可分为以下类别:打开和关闭文件的函数和任务输出值到文件的任务输出值到变量的任务从文件读出值并载入变量或存储器的任务和函数2.1、$fopen、$fclose、$ferror 打开和关闭文件函数描述fd &#x3D; $fopen(“fname”, mode);打开文件。fname 是文件名，mode 是打开格式，返回零值表示打开出错。fd 是 32bit 的 mcd（multichannel descriptor）$fclose(fd);关闭文件。errno &#x3D; $ferror(fd, str);读取错误状态。errno 和 str 为零值说明读取无误。errno 非零表示出错，最近一次文件 I&#x2F;O 操作所遇到的错误类型的字符串描述被写入 str 中，str 应该至少是640位宽。mode 类型：2.2、$fdisplay、$fwrite、$fstrobe、$fmonitor 文件写入共 4 类，末尾带 b&#x2F;h&#x2F;o 只是以不同的进制输出。函数描述$fdisplay(fd, arguments);类似 $display，自动换行$fwrite(fd, arguments);类似 $write，不换行$fstrobe(fd, arguments);类似 $stobe，调用后写入一次$fmonitor(fd, arguments);类似 $monitor，监测到数据有变化就写文件测试：123456789101112131415161718192021module tb_file_options(); integer fd; integer err; reg [639: 0] str; initial begin fd = $fopen(\"./file_io_test.txt\", \"a+\"); err = $ferror(fd, str); if (!err) begin $fdisplay(fd, \"fd: %h\", fd) ; $fdisplay(fd, \"str: %h\", str) ; $fdisplay(fd, \"err: %h\", err) ; $fwrite(fd, \"fd: %h \", fd) ; $fwrite(fd, \"str: %h \", str) ; $fwrite(fd, \"err: %h \", err) ; end $fclose(fd); endendmodule可以看到在 {工程目录}/{工程名}.sim/sim_1/behav/xsim/ 目录下生成了代码中设置的 file_io_test.txt 文件，其内容为：1234fd: ffffb1e0str: 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004e6f204572726f72err: 00000000fd: ffffb1e0 str: 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004e6f204572726f72 err: 00000000符合预期。如果需要输出有符号数，可以使用 $singed() 进行转化，例如：1$fdisplay(fd, \"%d\\n\", $signed(result_pooling2));输出为：1fd: -200002.3、$swrite 和 $sformat 数据格式化为字符串$swrite 和 $sformat 用于向字符串中写数据。函数描述$swrite(output_reg, list_of_arguments);与 $fwrite 类似，将参数列表 list_of_arguments 中的参数写入 output_reg 变量中len &#x3D; $sformat(output_reg, format_string, list_of_arguments)用法与 $display 类似，但只有第二个参数 format_string 会被解释为格式字符串。测试：1234567891011121314151617181920212223242526module tb_string_options(); reg [299: 0] str_swrite; reg [299: 0] str_sformat; reg [63: 0] str_temp; integer len = 111; initial begin str_temp = \"testStr\"; $swrite(str_swrite, \"%s's length is %d\", str_temp, len); $display(\"%s\", str_swrite); $swrite(str_swrite, \"abc\", , 123); $display(\"%s\", str_swrite); $sformat(str_sformat, \"test: %s\", str_temp); $display(\"%s\", str_sformat); $sformat(str_sformat, \"abc %d\", 123); $display(\"%s\", str_sformat); $sformat(str_sformat, \"abc\"); $display(\"%s\", str_sformat); $sformat(str_sformat, \"abc\", , 123); $display(\"%s\", str_sformat); endendmodule输出为：12345678 testStr's length is 111 abc 123 test: testStr abc 123 abcERROR: No Format provided for this argumentERROR: No Format provided for this argument abc可以看出，当 $sformat 只有两个参数，且第二个参数中不含格式控制符，只有字符串时，是可以正常输出的。但是，如果 $sformat 有多个参数，且第二个参数不含格式控制符时，从第三个参数开始将报错。2.4、$fread、$fgets、$fscanf 文件读出函数描述code &#x3D; $fread(store, fd, start, count);$fread 用于以二进制格式将数据从文件读取到 reg 或 memory 中。store 是存放读取内容的变量，可以是 reg，也可以是 memory。fd 是文件指针。start 是文件的起始位置，count 是读取文件的长度。如果没有指定起始地址，则选取内存的最低地址。这两个参数对于store 是 reg 类型时无效。code &#x3D; $fgets(str, fd);以行为单位，按字符连续读取，直到 str 填满或一行读完。返回值 code 是读取的行数，code 为零值表示读出错。code &#x3D; $fscanf(fd, format, args);根据格式 format 从 fd 中读取数据到 args 中，遇空白符停止。code 为零值表示读出错。$fread 测试：123456789101112131415161718192021222324252627module tb_fread(); integer fd; integer err; integer code; reg [639: 0] str; reg[799: 0] mem [9: 0]; initial begin #10; fd = $fopen(\"./test_readmem.hex\", \"r\"); err = $ferror(fd, str); if(!err) begin // code = $fread(mem, fd, 0, 5); code = $fread(mem, fd); $display(\"$fread read num: %0d\", code); $display(\"$fread read: %s\", mem[0]); $display(\"$fread read: %s\", mem[1]); $display(\"$fread read: %s\", mem[2]); $display(\"$fread read: %s\", mem[3]); $display(\"$fread read: %s\", mem[4]); end $fclose(fd); endendmodule输出为：12345678910$fread read num: 80$fread read: // test $readmemh and $readmembaa5555aa12341357ace11234abcd cdef1234a5a55a5a$fread read: $fread read: $fread read: $fread read:如果 reg 宽度足够大，数组中的第一项就将接收所有的字符。否则，写满一项，再写下一项。2.5、$ftell、$fseek、$rewind 文件定位用法：12integer pos;pos = $ftell(fd);pos 为文件 fd 的当前字节相对于文件起始位置的偏移量。12code = $fseek ( fd, offset, operation );code = $rewind ( fd );$fseek 的 operation 的用法：0 sets position equal to offset bytes1 sets position to current location plus offset2 sets position to EOF plus offset$rewind 相当于 $fseek (fd,0,0);2.6、$fflush 刷新输出123$fflush(mcd);$fflush(fd);$fflush();将任何缓冲输出写到 MCD 指定的文件中，写到 fd 指定的文件中，或者如果不带参数调用 $fflush，写到所有打开的文件中。2.7、$feof 探测 EOF用法：12integer code;code = $feof ( fd );探测到 EOF 返回非零值，否则返回零值。2.8、$readmemb、$readmemh 从文件载入 memory 数据用法：12$readmemb (\"file_name\", memory_name[ , start_addr[, finish_addr]]);$readmemh (\"file_name\", memory_name[ , start_addr[, finish_addr]]);4 s个参数分别是：文件名、数组&#x2F;reg 变量、起始地址和终止地址。其中，起始地址和终止地址可以省略。测试数据（test_readmem.hex）：12345// test $readmemh and $readmembaa5555aa1357ace11234abcd cdef1234a5a55a5a测试代码：1234567891011121314151617181920212223242526module tb_readmem();reg [63: 0] mem_1[9: 0];reg [31: 0] mem_2[9: 0];initial begin #10; $readmemh(\"./test_readmem.hex\", mem_1); $display(\"mem_1 read data: %h\", mem_1[0]); // 此处不能直接用 mem_1 作为参数 $display(\"mem_1 read data: %h\", mem_1[1]); $display(\"mem_1 read data: %h\", mem_1[2]); $display(\"mem_1 read data: %h\", mem_1[3]); $display(\"mem_1 read data: %h\", mem_1[4]); $display(\"mem_1 read data: %h\", mem_1[5]); $readmemh(\"./test_readmem.hex\", mem_2); $display(\"mem_2 read data: %h\", mem_2[0]); // 此处不能直接用 mem_2 作为参数 $display(\"mem_2 read data: %h\", mem_2[1]); $display(\"mem_2 read data: %h\", mem_2[2]); $display(\"mem_2 read data: %h\", mem_2[3]); $display(\"mem_2 read data: %h\", mem_2[4]); $display(\"mem_2 read data: %h\", mem_2[5]);endendmodule输出为：123456789101112mem_1 read data: 00000000aa5555aamem_1 read data: 000000001357ace1mem_1 read data: 000000001234abcdmem_1 read data: 00000000cdef1234mem_1 read data: 00000000a5a55a5amem_1 read data: xxxxxxxxxxxxxxxxmem_2 read data: aa5555aamem_2 read data: 1357ace1mem_2 read data: 1234abcdmem_2 read data: cdef1234mem_2 read data: a5a55a5amem_2 read data: xxxxxxxx$readmemh 读取数据时遇到空白符就会停止，然后写入到一个 reg 中，如果开辟了一整个大位宽的 reg，例如1reg [299: 0] mem[0: 0];则只有第一个数据会被写入 mem，后面的数据不会写入。如果数据的长度大于 reg 寄存器的长度，则会截掉高位保留低位后写入 reg。因此，需要提前判断数据宽度和个数，合理规划用来接收的 reg 数组。三、时间度量任务（Timescale tasks）$printtimescale$timeformat四、仿真控制任务（Simulation control tasks）4.1、$finish$finish 系统任务是让仿真器退出，并将控制权交还给主机操作系统。如果向这个任务提供了一个表达式，则它的值（0、1 或 2）决定了在发出提示符之前打印的诊断消息。 如果没有提供参数，则默认值为1。参数值诊断信息0不输出信息1输出当前仿真时刻和位置2输出当前仿真时刻，位置，和仿真中使用的 memory 和 CPU 时间的统计$finish(0)1$finish called at time : 20 ns$finish(1)1$finish called at time : 20 ns : File \"D:/verilog_test/system_task/system_task.srcs/sim_1/new/tb_time.v\" Line 38$finish(2)12$finish called at time : 20 ns : File \"D:/verilog_test/system_task/system_task.srcs/sim_1/new/tb_time.v\" Line 38Memory in use : 7764 KB (peak memory: 7764 KB) CPU usage : 0 ms4.2、$stop$stop 可以暂停仿真。与 finish 相同，stop 也可以用 0、1、2 三个参数来指定打印诊断信息的内容。五、PLA 建模任务（PLA modeling tasks）六、随机分析任务（Stochastic analysis tasks）$q_initialize$q_add$q_remove$q_full$q_exam七、仿真时间函数（Simulation time functions）7.1、$time$time 系统函数返回一个 64 位的整数，按调用它的模块的时间单位缩放。时间单位是指文件中由 &#96;timescale 定义的内容（timescale 时间单位&#x2F;时间精度）。测试：12345678910111213141516171819module tb_time();reg [31: 0] data;initial begin data = 0; $display($time, , \"display1 data = \", data); $display(\"display2 @ %d, data = %d\", $time, data); $monitor($time, , \"monitor1 data = \", data); $monitor(\"monitor2 @ %d, data = %d\", $time, data); #10; data = 10; #10; $finish;endendmodule输出为：123456 0 display1 data = 0display2 @ 0, data = 0 0 monitor1 data = 0monitor2 @ 0, data = 0 10 monitor1 data = 10monitor2 @ 10, data = 107.2、$realtime用法与 $time 相同，只是返回实数值（$time 是整数）。7.3、$stime用法与 $time 相同，只是返回 32bit 整数值（$time 是 64bit 整数）。八、转换函数（Conversion functions）$bitstoreal $realtobits$itor $rtoi$signed $unsigned九、概率分布函数（probabilistic distribution functions）包含一组随机数生成器，用于返回按标准概率函数分布的整数值。9.1、$random$random 函数每次被调用都会返回一个新的32位随机数。 随机数是一个有符号整数; 它可以是正的也可以是负的。产生 -59~59 之间的随机数：12reg [23:0] rand;rand = $random % 60;产生 0~59 之间的随机数：12reg [23:0] rand;rand = &#123;$random&#125; % 60;9.2、$dist_functions包含一系列概率分布函数：从上到下分别是：均匀分布正态分布指数分布泊松分布t 分布erlang 分布十、命令行输入（Command line input）以命令行参数的形式为仿真器提供信息，参数以 “+” 开头（Vivado 使用的 XSIM 仿真器没有使用 “+”）。10.1、$test$plusargs$test$plusarg() 用于在 plusargs 列表中搜索用户指定的 plusarg_string。 该字符串在系统函数的参数中指定为字符串或解释为字符串的非实数变量。 此字符串不包括命令行参数的前导加号。 在命令行中出现的 plusargs 将按照提供的顺序进行搜索。 如果所提供的 plusargs 的前缀匹配所提供的字符串中的所有字符，则函数返回一个非零整数。 如果命令行中没有 plusarg 与所提供的字符串匹配，函数将返回整数值零。测试：1234567891011121314`timescale 1ns / 1psmodule tb_test_plusargs();initial begin if($test$plusargs(\"HELLO\")) $display(\"Hello argument found.\"); if($test$plusargs(\"HE\")) $display(\"The HE subset string is detected.\"); if($test$plusargs(\"H\")) $display(\"Argument starting with H found.\"); if($test$plusargs(\"HELLO_HERE\"))$display(\"Long argument.\"); if($test$plusargs(\"HI\")) $display(\"Simple greeting.\"); if($test$plusargs(\"LO\")) $display(\"Does not match.\");end endmodule在 Vivado 界面左侧的 Fow Navigator 中的 SIMULATION 处右键，选择 Simulation Settings，如下图：在 Simulation 的参数设置中，有一栏名为 xsim.simulate.xsim.more_options*，在其后添加：1-testplusarg &#123;HELLO&#125;{} 中的内容即为设置的参数。输出为：123Hello argument found.The HE subset string is detected.Argument starting with H found.可以看出，不仅匹配了 HELLO，HE 和 H 也匹配到了，这是因为 $test$plusargs() 做参数匹配时，是用参数列表中的参数去匹配命令行输入的参数，因此 HELLO、HE、H 都能匹配到外界输入的 HELLO。关于参数设置的格式不同于前述的 IEEE 标准提到的以 “+” 开头，是因仿真器而异的。如果要输入两个参数，可以设置成：1-testplusarg &#123;HELLO&#125; -testplusarg &#123;LO&#125;10.2、$value$plusargs$value$plusargs() 用于匹配给定参数，匹配成功则传递给指定的变量。使用格式为：1$value$plusargs(\"plusarg_string=/+format_string\", variable)类似于 C 语言中的 scanf()，其中：plusarg_string 是用于匹配的参数名称format_string 是参数的格式，类似于 $display 中的用法variable 是接收参数的变量参数格式有以下几种：参数格式描述%ddecimal conversion%ooctal conversion%hhexadecimal conversion%bbinary conversion%ereal exponential conversion%freal decimal conversion%greal decimal or exponential conversion%sstring (no conversion)测试：123456789101112131415`timescale 1ns / 1psmodule tb_value_plusargs();reg [8*32: 1] testname;real frequency;initial begin if($value$plusargs(\"TESTNAME=%0s\", testname)) $display(\"TESTNAME = %0s\", testname); if (!($value$plusargs(\"FREQ+%0F\", frequency))) frequency = 8.33333; // 166 MHz $display(\"frequency = %f\", frequency);endendmodule设置参数：1-testplusarg TESTNAME=bar -testplusarg FREQ+9.234输出为：12TESTNAME = barfrequency = 9.234000使用 $value$plusargs() 需要预估接收参数的变量的位数，否则会根据一定的规则转换，出现非预期的结果。十一、数学函数（Math functions）$clog2 $asin$ln $acos$log10 $atan$exp $atan2$sqrt $hypot$pow $sinh$floor $cosh$ceil $tanh$sin $asinh$cos $acosh$tan $atanh","tags":"fpga verilog 仿真"},{"title":"Verilog 赋值语句","url":"/article/bf9a208b.html","text":"Verilog HDL 语言中有两种赋值语句，分别是阻塞式赋值语句，和非阻塞式赋值语句。关于两种语句的使用，有两条约定俗称的规则：在描述组合逻辑的 always 块中用阻塞赋值（&#x3D;），则综合成组合逻辑的电路结构。在描述时序逻辑的 always 块中用非阻塞赋值（&lt;&#x3D;），则综合成时序逻辑的电路结构。之所以会有这样的规则，是与仿真有关。忽略这两条规则也能推断出正确的综合逻辑，但是综合前仿真的行为可能会与综合出的电路不匹配。以下分别进行实验测试。〇、概念0.1、缩写RHS（Right Hand Side）：赋值语句中，赋值符号右侧的变量或表达式。LHS（Left Hand Side）：赋值语句中，赋值符号左侧的变量或表达式。0.2、延迟方式左侧延迟（赋值间延迟）：1#&lt;delay&gt; &lt;LHS&gt; = &lt;RHS&gt;右侧延迟（赋值内延迟）：1&lt;LHS&gt; = #&lt;delay&gt; &lt;RHS&gt;0.3、阻塞赋值的竞争问题A Verilog race condition occurs when two or more statements that are scheduled to execute in the same simulation time-step, would give different results when the order of statement execution is changed, as permitted by the IEEE Verilog Standard.简单来讲，当两个阻塞赋值的 always 块互换 LHS 和 RHS 的时候，就会出现竞争问题。例如：12345678always @(posedge clk or posedge rst) begin if(rst) x = 0; else x = y;endalways @(posedge clk or posedge rst) begin if(rst) y = 1; else y = x;end由于阻塞赋值中没有新值、旧值之分，因此这样的写法会导致输出的不确定。在 vivado2021.1 中，上述代码生成的逻辑与非阻塞赋值相同，可能是软件做了优化，但从语法角度这样写是有问题的。如果将上述代码改成非阻塞赋值，则 x 和 y 输出的新值分为是对方输出的旧值，不会产生冲突。生成的逻辑如下：综合后的原理图：一、阻塞式赋值阻塞是指一条语句在执行时不允许被其他语句打断。阻塞式赋值先计算 RHS 的值再进行赋值，且不允许其他语句打断，直到当前赋值语句完成。即 RHS 赋给 LHS 之后，才允许别的赋值语句执行。可综合的阻塞赋值操作在 RHS 不能设定延迟（零延迟也不允许）。可能是因为这样相当于让电路计时一段时间后才继续下一个操作（也是电路），实际上无法实现。always 块中的阻塞式赋值的 LHS 也必须是 reg 型变量，但是实际上不会生成触发器。二、非阻塞式赋值非阻塞指 always 块中所有的非阻塞赋值语句同时计算 RHS 并向 LHS 赋值，无先后之分。2.1、单条非阻塞赋值源码：123456789101112131415161718192021222324module unblocking( input a, input b, input c, output out1, output out2, input clk ); reg out1_r; reg out2_r; always @(posedge clk) begin out1_r &lt;= a &amp; b; end always @(*) begin out2_r = b &amp; c; end assign out1 = out1_r; assign out2 = out2_r;endmodule仿真代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546module unblocking_tb(); // Ports reg a = 0; reg b = 0; reg c = 0; wire out1; wire out2; reg clk = 0; initial begin $monitor(\"[%0t]: a=%0b b=%0b c=%0b out1=%0b out2=%0b\", $time, a, b, c, out1, out2); end unblocking unblocking_dut ( .a (a ), .b (b ), .c (c ), .out1 (out1 ), .out2 (out2 ), .clk ( clk) ); initial begin begin a = 0; b = 0; c = 0; #30; a = 1; b = 1; c = 1; #50; a = 0; b = 0; c = 0; #50; $finish; end end always #5 clk = ! clk ;endmodule生成逻辑：仿真波形：将 RHS 的计算和 LHS 的赋值看成两个独立的电路模块，从以上测试可以看出：1）阻塞赋值相当于 RHS 计算的输出和 LHS 赋值的输入直接通过导线连了起来2）非阻塞赋值相当于 RHS 计算的输出和 LHS 赋值的输入通过一个 触发器进行了隔离，因此就有新值和旧值之分，不会出现阻塞赋值中出现的竞争问题。2.2、某语句的 RHS 含块内其他语句的 LHS源码（只贴关键部分）：12345always @(posedge clk) begin a_r &lt;= a; b_r &lt;= b; out1_r &lt;= a_r &amp; b_r;end生成逻辑：仿真波形：可以看出，在 a、b 拉高后的第一个时钟上升沿，a_r、b_r 拉高，第二个时钟上升沿，out1 和 out1_r 才拉高。说明，第一个时钟时，a_r、b_r 采样到的是 a、b 的最新值（由于 a、b 是 wire，不存在新旧值一说，只有新值），而 out_r 采样到的是 a_r、b_r 的旧值，直到第二个时钟才采样到新值。调整仿真代码，使 a、b 变化的时刻与时钟上升沿对齐：a_r、b_r 仍能在第一个周期拉高，而 out1_r 比 a_r、b_r 延后一个时钟。以上说明，对于 always 块中的非阻塞赋值会在何时起作用，要看其 RHS 的类型。2.1 中 RHS 都是 wire 型（a 和 b） ，则在变化后的第一个周期就会立即产生变化。因为只有一级触发器，当上升沿来临时，会立即采样 D 端数据更新到 Q 端。而 2.2 中 RHS 存在 reg 型（a_r 和 b_r） ，则会延迟一个周期产生变化。因为第一个上升沿时，a_r 和 b_r 采样到新值，D 端更新到 Q 端，然后进行与运算。与此同时 out1_r 采样到上升沿时刻 a_r 和 b_r 所在触发器 Q 端的数据进行与运算的结果，此时该数据为旧值，即该周期中不能接触到 RHS 中 reg 型变量（a_r 和 b_r）的新值。第二个上升沿时，RHS 中 out1_r 所在触发器的 D 端已经是新值，此时立即更新到 Q 端，实现新值的赋值。本质上，会不会产生延迟，取决于路径中产生了几级触发器。如果某个变量所在的数据路径中只有一级触发器，则无论数据早于时钟上升沿变化，还是数据与时钟上升沿同步变化，都不会产生延迟，数据会立即更新（只是后者的 RHS 中的计算不能太复杂，否则可能建立&#x2F;保持时间不满足）。而如果某变量所在的数据路径中有两级触发器，则会产生一个周期的延迟，因为触发器每一拍只能传递一级。2.3、连续级联赋值在一个 always 块内，多次级联寄存器，观察现象。预期结果是 n 次级联赋值产生 n 级触发器，最终输出结果产生 n-1 个时钟的延迟。源码：123456always @(posedge clk) begin a_r &lt;= a; b_r &lt;= a_r; c_r &lt;= b_r; out1_r &lt;= a_r &amp; b_r &amp; c_r;end生成逻辑：仿真波形：由于 out1 所在的链路中，存在 4 级触发器，因此 out1 的输出相比 a、b、c 的输入延迟了 3 个周期。三、if-else 语句中赋值这里测试一下 if-else 语句会不会对赋值语句的执行时间产生影响。3.1、简单 if-else（条件为外部输入 wire）源码：123456789101112131415161718192021222324252627282930313233module unblocking_ifelse( input a, input b, input c, output out1, output out2, input clk);reg out1_r;reg out2_r;// 非阻塞always @(posedge clk) begin if(c) out1_r &lt;= a | b; else begin out1_r &lt;= 1'b0; endend// 阻塞always @(*) begin if(c) out2_r = a | b; else begin out2_r = 1'b0; endendassign out1 = out1_r;assign out2 = out2_r;endmodule生成逻辑：从原理图中可以看出，使用了 if-else 语句之后，会生成 MUX 逻辑，判断条件 c 被作为 2 to 1 MUX 的选通端信号。MUX 的输出端链接 out1 的触发器，并直连 out2。因此，当 c 为 1 时，MUX 的 I0 输入选通到输出，组合逻辑输出 out2 会立刻进行赋值输出，时序逻辑输出 out1 会在时钟上升沿进行赋值并输出。由于这里只生成了一级触发器，所以输出不会延时一拍。在仿真代码中设置 c 的变化与 clk 上升沿同步时，就会看到 out1 与 out2 同时变化的现象。仿真波形：out1（时序逻辑） 的数据在下一个时钟上升沿发生改变，out2（组合逻辑） 的数据在 a、b、c 变化的当时就改变。如果将测试逻辑中的第一个延时从 20 修改成 25（a、b、c 的变化与时钟上升沿对齐）：则组合逻辑与时序逻辑的变化是相同的。说明简单的 if-else 语句不会造成输出延迟。这个例子中，if 的条件是简单的外部输入，下面试一试 if 条件中或条件表达式中含其他 reg 输出。3.2、if 条件中含 reg 变量将 if 的条件由外部输入的 wire 变量，换成一个 reg 变量，并在另一个 always 块中对这个 reg 变量做非阻塞赋值。源码：1234567891011always @(posedge clk) begin c_r &lt;= c;endalways @(posedge clk) begin if(c_r) out1_r &lt;= a | b; else begin out1_r &lt;= 1'b0; endend生成逻辑：由于寄存器变量在 if 条件中，所以在 c 输入和 MUX 控制端之间多了一级触发器。波形图：可以看出，由于 c_r 生成了触发器，out1 比 a、b、c 延迟了一个周期另外，本例中如果将 c_r &lt;&#x3D; c 与条件语句放在同一个 always 块中，也是一样的效果。12345678always @(posedge clk) begin c_r &lt;= c; if(c_r) out1_r &lt;= a | b; else begin out1_r &lt;= 1'b0; endend3.3、条件表达式中含 reg 变量源码：1234567891011always @(posedge clk) begin if(c) begin a_r &lt;= a; b_r &lt;= b; end else begin a_r &lt;= 1'b0; b_r &lt;= 1'b0; end out1_r &lt;= a_r | b_r;end生成逻辑：由于 if 条件中是 wire 变量，而条件表达式中是 reg 变量，所以触发器生成在了 MUX 和 或门之间。波形图：由于触发器的存在，out1 相对于 a、b、c 有一拍的时延。四、总结阻塞式赋值没有时延周期一说。非阻塞式赋值如果是最简单的形式，也不会有时延周期一说，在上升沿之后很快就会输出结果。如果非阻塞式赋值语句中存在 reg 变量，由于 reg 变量会生成触发器，则数据通路中触发器级数减 1 就是该路径的时延周期数。赋值语句使用时的八条建议：1）建模时序逻辑时，用非阻塞赋值2）建模锁存器时，用非阻塞赋值3）用 always 块建模组合逻辑时，用阻塞赋值4）在同一个 always 块中同时建模时序逻辑和组合逻辑时，使用非阻塞语句。5）不要再同一个 always 块中混合使用阻塞语句和非阻塞语句。6）不要在多个 always 块中对同一个变量赋值。7）使用 $strobe 来显示已经用非阻塞赋值语句赋值过的值。8）不要在赋值时使用 #0 延时。","tags":"fpga verilog"},{"title":"AXI slave 官方示例代码分析","url":"/article/ca088436.html","text":"按照通道对信号进行分类，以 always 块为单位对代码进行解读。但是代码中有写地方没有对通道进行严格的划分，存在一个 always 块中对两个通道的信号或寄存器进行操作的情况。AXI 的 5 个通道中，master 主控写地址、写数据和读地址三个通道，slave 主控写响应、读数据两个通道。一、写地址通道（AW）1.1、awready 逻辑当主机将 awvalid 和 wvalid 都拉高后，从机将 awready 拉高。其他状态下，awready 保持常低。1234567891011121314151617181920212223always @( posedge S_AXI_ACLK ) begin if ( S_AXI_ARESETN == 1'b0 ) begin axi_awready &lt;= 1'b0; axi_awv_awr_flag &lt;= 1'b0; end else begin if (~axi_awready &amp;&amp; S_AXI_AWVALID &amp;&amp; ~axi_awv_awr_flag &amp;&amp; ~axi_arv_arr_flag) begin // slave is ready to accept an address and // associated control signals axi_awready &lt;= 1'b1; axi_awv_awr_flag &lt;= 1'b1; // used for generation of bresp() and bvalid end else if (S_AXI_WLAST &amp;&amp; axi_wready) // preparing to accept next address after current write burst tx completion begin axi_awv_awr_flag &lt;= 1'b0; end else begin axi_awready &lt;= 1'b0; end endendaxi_awv_awr_flag 拉高表示 awvalid 和 awready 都拉高了，用于写响应通道生成 bresp[] 和 bvalid。axi_arv_arr_flag 和 axi_awv_awr_flag 都为低时，才将 awready 拉高，后面的 arready 也是二者都为低时才拉高，所以 awready 和 arready 只有一个能拉高。一次成功的写传输后（WLAST 拉高一个周期），将 axi_awv_awr_flag 重新拉低。1.2 awaddr 地址锁存当 awvalid 和 wvalid（为什么要包括 wvalid）都有效时，锁存 awaddr。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253always @( posedge S_AXI_ACLK ) begin if ( S_AXI_ARESETN == 1'b0 ) begin axi_awaddr &lt;= 0; axi_awlen_cntr &lt;= 0; axi_awburst &lt;= 0; axi_awlen &lt;= 0; end else begin if (~axi_awready &amp;&amp; S_AXI_AWVALID &amp;&amp; ~axi_awv_awr_flag) begin // address latching axi_awaddr &lt;= S_AXI_AWADDR[C_S_AXI_ADDR_WIDTH - 1:0]; axi_awburst &lt;= S_AXI_AWBURST; axi_awlen &lt;= S_AXI_AWLEN; // start address of transfer axi_awlen_cntr &lt;= 0; end else if((axi_awlen_cntr &lt;= axi_awlen) &amp;&amp; axi_wready &amp;&amp; S_AXI_WVALID) begin axi_awlen_cntr &lt;= axi_awlen_cntr + 1; case (axi_awburst) 2'b00: // fixed burst // The write address for all the beats in the transaction are fixed begin axi_awaddr &lt;= axi_awaddr; //for awsize = 4 bytes (010) end 2'b01: //incremental burst // The write address for all the beats in the transaction are increments by awsize begin axi_awaddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] &lt;= axi_awaddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] + 1; //awaddr aligned to 4 byte boundary axi_awaddr[ADDR_LSB-1:0] &lt;= &#123;ADDR_LSB&#123;1'b0&#125;&#125;; //for awsize = 4 bytes (010) end 2'b10: //Wrapping burst // The write address wraps when the address reaches wrap boundary if (aw_wrap_en) begin axi_awaddr &lt;= (axi_awaddr - aw_wrap_size); end else begin axi_awaddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] &lt;= axi_awaddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] + 1; axi_awaddr[ADDR_LSB-1:0] &lt;= &#123;ADDR_LSB&#123;1'b0&#125;&#125;; end default: //reserved (incremental burst for example) begin axi_awaddr &lt;= axi_awaddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] + 1; //for awsize = 4 bytes (010) end endcase end endend（1）axi_awlen_cntr 用于。。。（2）在 awvalid 拉高，但 awready 还没拉高的周期，完成以下操作：awaddr、awburst、awlen 锁存axi_awlen_cntr 复位（置零）因为 awvalid 的拉高是早于 awready 的，且 awvalid 拉高时总线上的数据可认为是有效的，所以此时即便从机还没有准备好处理数据（对于 AW 通道就是地址和 burst 信息），也可以先把数据先缓存过来。（3）wready 与 wvalid 握手成功（二者均为高电平），且 axi_awlen_cntr 小于等于 axi_awlen 时，首先将 axi_awlen_cntr 自增 1。然后根据 awburst 的操作类型分别执行不同的操作：fixed burst 类型，地址始终为 awaddrincremental burst 类型，地址的最低 2&#x2F;3 位填 0，其他高位增加 1wrapping burst 类型先判断是否需要回卷，由 aw_wrap_en 表示，需要就回卷到起始位置不需要回卷就按照第二种方式进行递增其中，需要填 0 的低位地址位数 ADDR_LSB，通过写数据通道的数据位宽除以 32 再加 1 得到，代码如下。例如，32bit 宽度的数据，地址需要每次增加 4 个 Byte，因此地址的低 2 位需要填 0，而 64bit 宽度的数据，地址需要每次增加 8 个 Byte，则地址的低 3 位需要填 0。数据位宽越大，地址低位填 0 的位数越多。1localparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32)+ 1;aw_wrap_en 的计算是通过将 axi_awaddr 与 aw_wrap_size 按位与之后再与 aw_wrap_size 判等得到的，代码如下。12assign aw_wrap_size = (C_S_AXI_DATA_WIDTH/8 * (axi_awlen));assign aw_wrap_en = ((axi_awaddr &amp; aw_wrap_size) == aw_wrap_size)? 1'b1: 1'b0;二、写数据通道（W）2.1、wready 逻辑与 awready 类似，当主机将 wvalid 和 wvalid （这一句翻译自代码中的注释，为什么要等awvalid？）都拉高后，从机将 wready 拉高。其他状态下，wready 保持常低。123456789101112131415always @( posedge S_AXI_ACLK ) begin if ( S_AXI_ARESETN == 1'b0 ) begin axi_wready &lt;= 1'b0; end else begin if ( ~axi_wready &amp;&amp; S_AXI_WVALID &amp;&amp; axi_awv_awr_flag) begin // slave can accept the write data axi_wready &lt;= 1'b1; end //else if (~axi_awv_awr_flag) else if (S_AXI_WLAST &amp;&amp; axi_wready) begin axi_wready &lt;= 1'b0; end endendaxi_awv_awr_flag 的产生代码和作用。。。数据之类的用 assign？todo。。。三、写响应通道（B）3.1、写响应逻辑当 wready 和 wvalid 拉高时，从机将写响应和响应有效信号拉高。这标志着接受了地址，且指示了此次写事务的状态。12345678910111213141516171819202122always @( posedge S_AXI_ACLK ) begin if ( S_AXI_ARESETN == 1'b0 ) begin axi_bvalid &lt;= 0; axi_bresp &lt;= 2'b0; axi_buser &lt;= 0; end else begin if (axi_awv_awr_flag &amp;&amp; axi_wready &amp;&amp; S_AXI_WVALID &amp;&amp; ~axi_bvalid &amp;&amp; S_AXI_WLAST ) begin axi_bvalid &lt;= 1'b1; axi_bresp &lt;= 2'b0; // 'OKAY' response end else begin if (S_AXI_BREADY &amp;&amp; axi_bvalid) //check if bready is asserted while bvalid is high) //(there is a possibility that bready is always asserted high) begin axi_bvalid &lt;= 1'b0; end end endend写事务完成后才将 bvalid 拉高，且 bresp 设置为 “OKAY” 响应。bvalid 拉高后，即等待主机拉高 bready。等写事务握手完成后将 bvalid 拉低。注释里写了存在 bready 为常高的可能。这个代码的 else 里面，只有 if，没有 else，会不会漏掉什么情况，或产生 latch?前面的 if 是为了等待 bready 拉高，如果不加 else，意味着 bready 没有拉高的话，bvalid 会保持不变。另外这里用到了 buser 信号，返回了一个常 0。四、读地址通道（AR）4.1、arready 逻辑当主机将 arvalid 拉高时，从机将 arready 拉高，其他时候保持常低（等待 arvalid 拉高）。1234567891011121314151617181920always @( posedge S_AXI_ACLK ) begin if ( S_AXI_ARESETN == 1'b0 ) begin axi_arready &lt;= 1'b0; axi_arv_arr_flag &lt;= 1'b0; end else begin if (~axi_arready &amp;&amp; S_AXI_ARVALID &amp;&amp; ~axi_awv_awr_flag &amp;&amp; ~axi_arv_arr_flag) begin axi_arready &lt;= 1'b1; axi_arv_arr_flag &lt;= 1'b1; end else if (axi_rvalid &amp;&amp; S_AXI_RREADY &amp;&amp; axi_arlen_cntr == axi_arlen) // preparing to accept next address after current read completion begin axi_arv_arr_flag &lt;= 1'b0; end else begin axi_arready &lt;= 1'b0; end endend与 awready 逻辑类似，主机将 arvalid 拉高，且 axi_awv_awr_flag 和 axi_arv_arr_flag 两个标志都拉低时，将 arready 拉高。axi_arlen_cntr 的作用。。。4.2、araddr 地址锁存当 arvalid 和 rvalid 拉高时，将 araddr 锁存。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465always @( posedge S_AXI_ACLK ) begin if ( S_AXI_ARESETN == 1'b0 ) begin axi_araddr &lt;= 0; axi_arlen_cntr &lt;= 0; axi_arburst &lt;= 0; axi_arlen &lt;= 0; axi_rlast &lt;= 1'b0; axi_ruser &lt;= 0; end else begin if (~axi_arready &amp;&amp; S_AXI_ARVALID &amp;&amp; ~axi_arv_arr_flag) begin // address latching axi_araddr &lt;= S_AXI_ARADDR[C_S_AXI_ADDR_WIDTH - 1:0]; axi_arburst &lt;= S_AXI_ARBURST; axi_arlen &lt;= S_AXI_ARLEN; // start address of transfer axi_arlen_cntr &lt;= 0; axi_rlast &lt;= 1'b0; end else if((axi_arlen_cntr &lt;= axi_arlen) &amp;&amp; axi_rvalid &amp;&amp; S_AXI_RREADY) begin axi_arlen_cntr &lt;= axi_arlen_cntr + 1; axi_rlast &lt;= 1'b0; case (axi_arburst) 2'b00: // fixed burst // The read address for all the beats in the transaction are fixed begin axi_araddr &lt;= axi_araddr; //for arsize = 4 bytes (010) end 2'b01: //incremental burst // The read address for all the beats in the transaction are increments by awsize begin axi_araddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] &lt;= axi_araddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] + 1; //araddr aligned to 4 byte boundary // ! 低 2/3 位地址置零 axi_araddr[ADDR_LSB-1:0] &lt;= &#123;ADDR_LSB&#123;1'b0&#125;&#125;; //for awsize = 4 bytes (010) end 2'b10: //Wrapping burst // The read address wraps when the address reaches wrap boundary if (ar_wrap_en) begin axi_araddr &lt;= (axi_araddr - ar_wrap_size); end else begin axi_araddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] &lt;= axi_araddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB] + 1; //araddr aligned to 4 byte boundary axi_araddr[ADDR_LSB-1:0] &lt;= &#123;ADDR_LSB&#123;1'b0&#125;&#125;; end default: //reserved (incremental burst for example) begin axi_araddr &lt;= axi_araddr[C_S_AXI_ADDR_WIDTH - 1:ADDR_LSB]+1; //for arsize = 4 bytes (010) end endcase end else if((axi_arlen_cntr == axi_arlen) &amp;&amp; ~axi_rlast &amp;&amp; axi_arv_arr_flag ) begin axi_rlast &lt;= 1'b1; end else if (S_AXI_RREADY) begin axi_rlast &lt;= 1'b0; end endendaxi_arlen_cntr 用于读数据过程中的计数。当主机将 arvalid 拉高，且 axi_arv_arr_flag 为低时，将 araddr、arburst、arlen 锁存，将 axi_arlen_cntr 和 rlast 置零。当握手成功（axi_rvalid 和 S_AXI_RREADY 拉高）且 axi_arlen_cntr &lt;&#x3D; axi_arlen 的时候，将 axi_arlen_cntr 自增 1，将 rlast 置零。然后根据 arburst 的 burst 类型执行不同的操作，类似于写通道。默认是 incremental burst 类型。当 axi_arlen_cntr 计数值等于 axi_arlen 且 rlast 没有拉高时，将 rlast 拉高。这样下一个周期，刚好是最后一个数据，且 rlast 刚好拉高。最后一个条件判断，当 rready 为高时，将 rlast 拉低（为什么要这样做？）。五、读数据通道（R）读数据通道的 source 是从机，由从机发起通信，即控制 rid、rdata、rresp、rlast、rvalid 等信号，而主机只控制 rready。当 arvalid 和 arready 都拉高时， rvalid 拉高。rvalid 拉高标志着总线上的读出数据有效，rresp 表示读事务的状态。12345678910111213141516always @( posedge S_AXI_ACLK ) begin if ( S_AXI_ARESETN == 1'b0 ) begin axi_rvalid &lt;= 0; axi_rresp &lt;= 0; end else begin if (axi_arv_arr_flag &amp;&amp; ~axi_rvalid) begin axi_rvalid &lt;= 1'b1; axi_rresp &lt;= 2'b0; // 'OKAY' response end else if (axi_rvalid &amp;&amp; S_AXI_RREADY) begin axi_rvalid &lt;= 1'b0; end endendaxi_arv_arr_flag 为高时，将 rvalid 拉高。握手成功后，将 rvalid 拉低，rvalid 只握手一个周期。六、访问用户逻辑存储区域1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253generate if (USER_NUM_MEM &gt;= 1) begin assign mem_select = 1; assign mem_address = (axi_arv_arr_flag? axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]:(axi_awv_awr_flag? axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]:0)); endendgenerate// implement Block RAM(s)generate for(i=0; i&lt;= USER_NUM_MEM-1; i=i+1) begin:BRAM_GEN wire mem_rden; wire mem_wren; assign mem_wren = axi_wready &amp;&amp; S_AXI_WVALID ; assign mem_rden = axi_arv_arr_flag ; //&amp; ~axi_rvalid for(mem_byte_index=0; mem_byte_index&lt;= (C_S_AXI_DATA_WIDTH/8-1); mem_byte_index=mem_byte_index+1) begin:BYTE_BRAM_GEN wire [8-1:0] data_in ; wire [8-1:0] data_out; reg [8-1:0] byte_ram [0 : 255]; integer j; //assigning 8 bit data assign data_in = S_AXI_WDATA[(mem_byte_index*8+7) -: 8]; assign data_out = byte_ram[mem_address]; always @( posedge S_AXI_ACLK ) begin if (mem_wren &amp;&amp; S_AXI_WSTRB[mem_byte_index]) begin byte_ram[mem_address] &lt;= data_in; end end always @( posedge S_AXI_ACLK ) begin if (mem_rden) begin mem_data_out[i][(mem_byte_index*8+7) -: 8] &lt;= data_out; end end end endendgenerate//Output register or memory read dataalways @( mem_data_out, axi_rvalid) begin if (axi_rvalid) begin // Read address mux axi_rdata &lt;= mem_data_out[0]; end else begin axi_rdata &lt;= 32'h00000000; endend","tags":"fpga axi"},{"title":"AXI master 官方示例代码分析","url":"/article/f9bc4c85.html","text":"AXI4 接口共有五个通道，三个写通道，两个读通道。写通道中的写响应通道是单独一个通道，而读通道中的读响应和读数据合在了一个通道里。写通道：读通道：以下是握手信号的依赖关系：箭头含义:单箭头指向的信号可以在箭尾信号 assert 之前或之后 assert。双箭头指向的信号必须在箭尾信号 assert 之后 assert。即：单箭头的箭头对箭尾没有依赖关系，所以箭尾不能等待箭头 assert，但箭头可以等待（也可以不等）箭尾 assert 。双箭头的箭头依赖箭尾，所以箭头必须等待（全部）箭尾 assert 之后，才能 assert。valid 信号不能等 ready 信号拉高之后再拉高。ready 信号可以等 valid 信号拉高之后再拉高。本文从 Vivado 自动生成的 AXI4 master 接口代码的 always 块入手进行分析。〇、AXI_master 接口以外信号共三个：INIT_AXI_TXN（input） —— 启动 transaction。TXN_DONE（input） —— transaction 完成。ERROR（output） —— 错误指示。0.1、INIT_AXI_TXN 信号打拍INIT_AXI_TXN 信号是从外部输入到 AXI_master 模块的信号，用于使能一次传输，属于慢时钟域到快时钟域的跨时钟域信号，因此这里打两拍进行同步。1234567891011always @(posedge M_AXI_ACLK) begin // Initiates AXI transaction delay if (M_AXI_ARESETN == 0 ) begin init_txn_ff &lt;= 1'b0; init_txn_ff2 &lt;= 1'b0; end else begin init_txn_ff &lt;= INIT_AXI_TXN; init_txn_ff2 &lt;= init_txn_ff; endend用打拍后的信号来提取使能信号的上升沿：1assign init_txn_pulse = (!init_txn_ff2) &amp;&amp; init_txn_ff;一、写地址通道（AW）1.1、awvalid 逻辑awvalid 信号用于指示写地址通道的数据（地址）有效，与 awready 信号同为 1’b1 时握手成功。12345678910111213141516always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1 ) begin axi_awvalid &lt;= 1'b0; end // If previously not valid , start next transaction else if (~axi_awvalid &amp;&amp; start_single_burst_write) begin axi_awvalid &lt;= 1'b1; end /* Once asserted, VALIDs cannot be deasserted, so axi_awvalid must wait until transaction is accepted */ else if (M_AXI_AWREADY &amp;&amp; axi_awvalid) begin axi_awvalid &lt;= 1'b0; end else axi_awvalid &lt;= axi_awvalid;endstart_single_burst_write 为高，且 axi_awvalid 为低时，将 axi_awvalid 拉高，等待握手完成。当 M_AXI_AWREADY 和 axi_awvalid 均为高电平时，将 axi_awvalid 拉低。也就是说，握手只持续一个时钟周期，数据（写通道的地址）只传送一次。且根据依赖关系，awvalid 不能等待 awready 拉高，而 awready 可以等待 awvalid 拉高。所以这里只要满足条件就拉高 awvalid，然后从机检测到 awvalid 拉高后，就将 awready 拉高进行握手。start_single_burst_write 信号在状态机中进行修改：123456789101112131415161718INIT_WRITE: // This state is responsible to issue start_single_write pulse to // initiate a write transaction. Write transactions will be // issued until burst_write_active signal is asserted. // write controller if (writes_done) begin mst_exec_state &lt;= INIT_READ;// end else begin mst_exec_state &lt;= INIT_WRITE; if (~axi_awvalid &amp;&amp; ~start_single_burst_write &amp;&amp; ~burst_write_active) begin start_single_burst_write &lt;= 1'b1; end else begin start_single_burst_write &lt;= 1'b0; //Negate to generate a pulse end end1.2、awaddr 地址生成当从机拉高 awready，意味着该次地址传输握手成功（因为 awvalid 一开始就在等待）。握手成功时，主机计算下一次 burst 的地址并赋给 awaddr。此时本次 burst 数据传输（写数据通道的传输）还没完成。12345678910always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1) begin axi_awaddr &lt;= 'b0; end else if (M_AXI_AWREADY &amp;&amp; axi_awvalid) begin axi_awaddr &lt;= axi_awaddr + burst_size_bytes; end else axi_awaddr &lt;= axi_awaddr;end另外，只有主机需要计算或从外部输入获取 awaddr 地址，从机只需要被动获取来自主机的 awaddr 即可。二、写数据通道（W）2.1、写下一笔数据标志1assign wnext = M_AXI_WREADY &amp; axi_wvalid;当 wvalid 和 wready 都为高时，说明握手成功，下一个数据可以继续传输，用 wnext 来表示。此时总线上的 wdata 已经完成一次传输。2.2、wvalid 逻辑12345678910111213141516always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1 ) begin axi_wvalid &lt;= 1'b0; end // If previously not valid, start next transaction else if (~axi_wvalid &amp;&amp; start_single_burst_write) begin axi_wvalid &lt;= 1'b1; end /* If WREADY and too many writes, throttle WVALID Once asserted, VALIDs cannot be deasserted, so WVALID must wait until burst is complete with WLAST */ else if (wnext &amp;&amp; axi_wlast) axi_wvalid &lt;= 1'b0; else axi_wvalid &lt;= axi_wvalid;end收到发送触发信号后，拉高 wvalid，等待与 wready 握手。握手成功后，保持高电平，继续传输数据。当最后一个数据发送时（即 wlast 拉高时），将 wvalid 拉低（此时最后一个数据已经传输完成）。2.3、wlast 逻辑1234567891011121314151617181920212223242526//WLAST generation on the MSB of a counter underflowalways @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1 ) begin axi_wlast &lt;= 1'b0; end // axi_wlast is asserted when the write index // count reaches the penultimate count to synchronize // with the last write data when write_index is b1111 // else if (&amp;(write_index[C_TRANSACTIONS_NUM-1:1])&amp;&amp; ~write_index[0] &amp;&amp; wnext) else if (((write_index == C_M_AXI_BURST_LEN-2 &amp;&amp; C_M_AXI_BURST_LEN &gt;= 2) &amp;&amp; wnext) || (C_M_AXI_BURST_LEN == 1 )) begin axi_wlast &lt;= 1'b1; end // Deassrt axi_wlast when the last write data has been // accepted by the slave with a valid response else if (wnext) axi_wlast &lt;= 1'b0; else if (axi_wlast &amp;&amp; C_M_AXI_BURST_LEN == 1) axi_wlast &lt;= 1'b0; else axi_wlast &lt;= axi_wlast;end第一个 else if 用于拉高 wlast，包括两种情况：1）busrt_len 大于等于 2 时，在倒数第二个数据发送的周期进行拉高，由于阻塞赋值的数据在下一个周期才生效，所以刚好在最后一个数据所在的周期将 wlast 拉高。2）burst_len 等于 1 时，直接拉高。由于此时 wready 未必拉高，所以其实是 wvalid 和 wlast 时钟保持拉高，等待 wready 拉高。握手一次后就结束。第二个 else if 用于 busrt_len 大于等于 2 时，在数据传输过程中，保持 wlast 为低。第三个 else if 用于 burst_len 等于 1 时，传输一次即拉低（与 wvalid 保持同步，因为 wvalid 会在检测到 wlast 拉高之后拉低）。2.4、write_index 传输数据计数write_index 用于计数传输的数据量，用作产生 wlast 的依据。12345678910always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1 || start_single_burst_write == 1'b1) begin write_index &lt;= 0; end else if (wnext &amp;&amp; (write_index != C_M_AXI_BURST_LEN-1)) begin write_index &lt;= write_index + 1; end else write_index &lt;= write_index;end2.5、wdata 数据生成握手成功后，不断产生新的待传输数据。但这个模块不具有通用性，仅用于测试代码。正常的 master 接口的数据来源应该是模块外部输入的。12345678910always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1) axi_wdata &lt;= 'b1; //else if (wnext &amp;&amp; axi_wlast) // axi_wdata &lt;= 'b0; else if (wnext) axi_wdata &lt;= axi_wdata + 1; else axi_wdata &lt;= axi_wdata;end三、写响应通道（B）写响应通道用来反馈写操作已经提交给从机。当地址和所有数据已经到达并被从机接受，就会发生 BREADY。write issuance（未完成的写地址数目） 由 Address Write transfer 开始，且由一个 BREADY&#x2F;BRESP 完成。虽然否定 BREADY 最终会限制 AWREADY 信号，但最好不要这样限制整个数据通道。BRESP[1] 用于指示整个写 burst 中来自互连或从机的任何错误。 这个例程将错误捕获到 ERROR输出中。3.1、bready 逻辑写响应通道的数据方向与另外两个写通道的方向相反。主机负责提供 bready 信号，与从机提供的 bvalid 信号握手。1234567891011121314151617always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1 ) begin axi_bready &lt;= 1'b0; end // accept/acknowledge bresp with axi_bready by the master // when M_AXI_BVALID is asserted by slave else if (M_AXI_BVALID &amp;&amp; ~axi_bready) begin axi_bready &lt;= 1'b1; end // deassert after one clock cycle else if (axi_bready) begin axi_bready &lt;= 1'b0; end // retain the previous value else axi_bready &lt;= axi_bready;end根据前面的握手信号依赖关系图，主机控制的 bready 可以等待从机控制的 bvalid，也可以不等。这里的代码是等待 bvalid 拉高后，才将 bready 拉高。3.2、bresp[1] 写错误响应12//Flag any write response errorsassign write_resp_error = axi_bready &amp; M_AXI_BVALID &amp; M_AXI_BRESP[1];握手成功且 bresp[1] 位为高时，标志着写入错误。本例程中通过 ERROR 信号将这一错误输出。四、读地址通道（AR）读地址通道（AR）提供了一个类似于写地址通道的功能 ——为突发提供传输限制。4.1、arvalid 逻辑123456789101112131415always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1 ) begin axi_arvalid &lt;= 1'b0; end // If previously not valid , start next transaction else if (~axi_arvalid &amp;&amp; start_single_burst_read) begin axi_arvalid &lt;= 1'b1; end else if (M_AXI_ARREADY &amp;&amp; axi_arvalid) begin axi_arvalid &lt;= 1'b0; end else axi_arvalid &lt;= axi_arvalid;end与写地址通道一样， arvalid 不必判断 arready 即可拉高，且只保持一个握手周期（握手不成功则会保持拉高）。4.2、araddr 地址生成12345678910always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1) begin axi_araddr &lt;= 'b0; end else if (M_AXI_ARREADY &amp;&amp; axi_arvalid) begin axi_araddr &lt;= axi_araddr + burst_size_bytes; end else axi_araddr &lt;= axi_araddr;end与 awaddr 类似。五、读数据通道（R）5.1、读下一笔数据标志1assign rnext = M_AXI_RVALID &amp;&amp; axi_rready;5.2、read_index 传输数据计数12345678910always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1 || start_single_burst_read) begin read_index &lt;= 0; end else if (rnext &amp;&amp; (read_index != C_M_AXI_BURST_LEN-1)) begin read_index &lt;= read_index + 1; end else read_index &lt;= read_index;end与 write_index 类似。5.3、rready 逻辑12345678910111213141516always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1 ) begin axi_rready &lt;= 1'b0; end // accept/acknowledge rdata/rresp with axi_rready by the master // when M_AXI_RVALID is asserted by slave else if (M_AXI_RVALID) begin if (M_AXI_RLAST &amp;&amp; axi_rready) begin axi_rready &lt;= 1'b0; end else begin axi_rready &lt;= 1'b1; end end // retain the previous valueend在从机的 rvalid 拉高的前提下，有两种情况：1）rlast 和 rready 都拉高，说明本周期读到的是最后一个数据，此时将 rready 拉低。2）其他情况下，都将 rready 拉高，继续保持握手，并传输数据。例程中，由于读到的数据直接送入 data checker 进行校验，接收能力能得到保证，因此不需要考虑数据反压。在客制化设计中，根据读出端的具体应用，可能需要设置数据反压机制。5.4、rresp[1] 读错误响应1assign read_resp_error = axi_rready &amp; M_AXI_RVALID &amp; M_AXI_RRESP[1];六、数据校验6.1、read_mismatch 数据校验1234567891011always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1) begin read_mismatch &lt;= 1'b0; end //Only check data when RVALID is active else if (rnext &amp;&amp; (M_AXI_RDATA != expected_rdata)) begin read_mismatch &lt;= 1'b1; end else read_mismatch &lt;= 1'b0;end将读通道读到的数据与生成的 expected_rdata 进行比较，不一致则将 read_mismatch 置位。6.2、生成测试数据123456789always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1)// || M_AXI_RLAST) expected_rdata &lt;= 'b1; // ! 读通道握手成功就生成测试数据 else if (M_AXI_RVALID &amp;&amp; axi_rready) expected_rdata &lt;= expected_rdata + 1; else expected_rdata &lt;= expected_rdata;endexpected_rdata 与 rdata 是对齐的。6.3、错误报告12345678910always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1) begin error_reg &lt;= 1'b0; end else if (read_mismatch || write_resp_error || read_resp_error) begin error_reg &lt;= 1'b1; end else error_reg &lt;= error_reg;end共三种错误：1）读数据不匹配；2）写错误响应；3）读错误响应。七、应用功能实现为了最大化端口的吞吐量，这个例程尝试让每个通道独立地快速运行。但是，用户应用程序有时候需要将数据流进行节流。 这个例程要求在写入数据之前不读取数据，并且写通道不能超前一个任意的阈值（意为防止当前读地址超出写地址）。根据 AXI4 规范 13.13.1：”If a master requires ordering between read and write transactions, it must ensure that a response is received for the previous transaction before issuing the next transaction.”此例程通过以下几点完成了这个用户应用的节流：读等待写完全完成当没有读且发出的事务计数超过参数化的阈值，地址写等待当没有读且运转中的数据突发数超过参数化阈值时，写等待7.1、Write_burst_counter 计数器12345678910111213always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1 ) begin write_burst_counter &lt;= 'b0; end else if (M_AXI_AWREADY &amp;&amp; axi_awvalid) begin if (write_burst_counter[C_NO_BURSTS_REQ] == 1'b0) begin write_burst_counter &lt;= write_burst_counter + 1'b1; //write_burst_counter[C_NO_BURSTS_REQ] &lt;= 1'b1; end end else write_burst_counter &lt;= write_burst_counter;endWrite_burst_counter 计数器跟踪发起的突发事务数和主机需要发起的突发事务数。AW 通道握手成功，则 write_burst_counter 计数加一。7.2、Read_burst_counter 计数器12345678910111213always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1) begin read_burst_counter &lt;= 'b0; end else if (M_AXI_ARREADY &amp;&amp; axi_arvalid) begin if (read_burst_counter[C_NO_BURSTS_REQ] == 1'b0) begin read_burst_counter &lt;= read_burst_counter + 1'b1; //read_burst_counter[C_NO_BURSTS_REQ] &lt;= 1'b1; end end else read_burst_counter &lt;= read_burst_counter;endRead_burst_counter 计数器跟踪发起的突发事务数和主机需要发起的突发事务数。AR 通道握手成功，则 read_burst_counter 计数加一。7.3、状态机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081always @ ( posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 1'b0 ) begin // reset condition // All the signals are assigned default values under reset condition mst_exec_state &lt;= IDLE; start_single_burst_write &lt;= 1'b0; start_single_burst_read &lt;= 1'b0; compare_done &lt;= 1'b0; ERROR &lt;= 1'b0; end else begin // state transition case (mst_exec_state) IDLE: // This state is responsible to wait for user defined C_M_START_COUNT // number of clock cycles. if ( init_txn_pulse == 1'b1) begin mst_exec_state &lt;= INIT_WRITE; ERROR &lt;= 1'b0; compare_done &lt;= 1'b0; end else begin mst_exec_state &lt;= IDLE; end INIT_WRITE: // This state is responsible to issue start_single_write pulse to // initiate a write transaction. Write transactions will be // issued until burst_write_active signal is asserted. // write controller if (writes_done) begin mst_exec_state &lt;= INIT_READ;// end else begin mst_exec_state &lt;= INIT_WRITE; if (~axi_awvalid &amp;&amp; ~start_single_burst_write &amp;&amp; ~burst_write_active) begin start_single_burst_write &lt;= 1'b1; end else begin start_single_burst_write &lt;= 1'b0; //Negate to generate a pulse end end INIT_READ: // This state is responsible to issue start_single_read pulse to // initiate a read transaction. Read transactions will be // issued until burst_read_active signal is asserted. // read controller if (reads_done) begin mst_exec_state &lt;= INIT_COMPARE; end else begin mst_exec_state &lt;= INIT_READ; if (~axi_arvalid &amp;&amp; ~burst_read_active &amp;&amp; ~start_single_burst_read) begin start_single_burst_read &lt;= 1'b1; end else begin start_single_burst_read &lt;= 1'b0; //Negate to generate a pulse end end INIT_COMPARE: // This state is responsible to issue the state of comparison // of written data with the read data. If no error flags are set, // compare_done signal will be asseted to indicate success. //if (~error_reg) begin ERROR &lt;= error_reg; mst_exec_state &lt;= IDLE; compare_done &lt;= 1'b1; end default : begin mst_exec_state &lt;= IDLE; end endcase endend //MASTER_EXECUTION_PROC7.4、burst_write_active 写突发活跃标志12345678910always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1) burst_write_active &lt;= 1'b0; //The burst_write_active is asserted when a write burst transaction is initiated else if (start_single_burst_write) burst_write_active &lt;= 1'b1; else if (M_AXI_BVALID &amp;&amp; axi_bready) burst_write_active &lt;= 0;end当 start_single_burst_write 拉高初始化一个突发写传输时，burst_write_active 信号拉高。burst_write_active 将保持拉高状态，直到这个突发写被从机接受。7.5、writes_done 写完成逻辑1234567891011always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1) writes_done &lt;= 1'b0; //The writes_done should be associated with a bready response //else if (M_AXI_BVALID &amp;&amp; axi_bready &amp;&amp; (write_burst_counter == &#123;(C_NO_BURSTS_REQ-1)&#123;1&#125;&#125;) &amp;&amp; axi_wlast) else if (M_AXI_BVALID &amp;&amp; (write_burst_counter[C_NO_BURSTS_REQ]) &amp;&amp; axi_bready) writes_done &lt;= 1'b1; else writes_done &lt;= writes_done;end这个逻辑是用最终的写响应来限定最近的写计数。这演示了如何确认写操作已提交。C_NO_BURSTS_REQ 刚好是计数器的最高位，用来指示计数器计满（只针对这个应用，刚好计数2的幂次，其他设计不通用），计数器计满 + 握手条件满足，则将 writes_done 拉高，表示写完成。7.6、burst_read_active 读突发活跃标志12345678910always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1) burst_read_active &lt;= 1'b0; //The burst_write_active is asserted when a write burst transaction is initiated else if (start_single_burst_read) burst_read_active &lt;= 1'b1; else if (M_AXI_RVALID &amp;&amp; axi_rready &amp;&amp; M_AXI_RLAST) burst_read_active &lt;= 0;end与 burst_write_active 类似。7.7、reads_done 读完成逻辑1234567891011always @(posedge M_AXI_ACLK) begin if (M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1) reads_done &lt;= 1'b0; //The reads_done should be associated with a rready response //else if (M_AXI_BVALID &amp;&amp; axi_bready &amp;&amp; (write_burst_counter == &#123;(C_NO_BURSTS_REQ-1)&#123;1&#125;&#125;) &amp;&amp; axi_wlast) else if (M_AXI_RVALID &amp;&amp; axi_rready &amp;&amp; (read_index == C_M_AXI_BURST_LEN-1) &amp;&amp; (read_burst_counter[C_NO_BURSTS_REQ])) reads_done &lt;= 1'b1; else reads_done &lt;= reads_done;end参考文档《AMBA AXI and ACE Protocol Specification》ARM IHI 0022H.c (ID012621)","tags":"fpga axi"},{"title":"Arduino IDE 配置 ESP32 开发环境","url":"/article/64d1c9e3.html","text":"〇、说明Arduino IDE 默认是不支持 ESP32 开发板的，但是可以通过开发板管理器安装其他开发板的开发环境。对于 ESP32，可以通过自动下载或者手动下载的方式来安装其开发环境，但由于网络原因，自动下载经常失败。以下对两种方法都做以下介绍，如果自动下载不成功，可以按照第二种方法手动安装。一、方法一：自动安装1、安装最新版 Arduino IDE，下载网址： Software | Arduino2、打开 Arduino 软件，点击菜单栏的 文件 - 首选项。在附加开发板管理器网址处填写：https://dl.espressif.com/dl/package_esp32_index.json然后保存，重启 Arduino 软件。3、在菜单栏中选择：工具 - 开发板 - 开发板管理在开发板管理器上，搜索 esp32，可以看到 esp32 by Espressif Systems，点击右下角的安装，等待安装完成即可。这个过程可能比较慢，取决于网络，请耐心等待。如果安装失败，可以尝试重新安装。在这一步中，笔者更改 esp32 的各个版本尝试，都没能成功。这种情况下应改用手动安装方式。注意如果这里安装失败，要把 用户文件夹\\AppData\\Local\\Arduino15\\ 路径下下载失败的内容清理掉。二、方法二：手动安装1、用 ${Arduino} 表示 Arduino 软件的安装目录。在 ${Arduino}/hardware 文件夹下建一个文件夹 espressif，然后将 arduino-esp32（espressif&#x2F;arduino-esp32: Arduino core for the ESP32 (github.com)） 克隆到这里（git clone 或者 下载安装包都可以）。点击 tools 文件夹下的 get.exe 安装编译器。（将文件夹名 arduino-esp32 改成 esp32，编译的时候不会有警告）2、开发板选项中出现 esp32 开发板编译的时候又报错，说找不到 xtensa-esp32-elf-g++ 编译器。。。3、上一步的问题在于，运行 tools 文件夹下的 get.exe 的时候其实没有运行成功，而是中断了（因为要下载东西，估计也是网络问题）。这个程序的功能是下载几个东西，中断后下载失败。${Arduino}&#x2F;hardware&#x2F;espressif&#x2F;esp32&#x2F;tools 目录下经过运行 get.exe 应该有以下几个文件夹，如果没有，说明 get.exe 运行失败。4、分析缺失的内容，然后手动下载有可能因为版本不同，需要的文件夹不同，具体需要哪些文件夹，可以查看 get.py：12345678if __name__ == '__main__': identified_platform = identify_platform() print('Platform: &#123;0&#125;'.format(identified_platform)) tools_to_download = load_tools_list(current_dir + '/../package/package_esp32_index.template.json', identified_platform) mkdir_p(dist_dir) for tool in tools_to_download: get_tool(tool) print('Platform Tools Installed')发现是根据 ../package/package_esp32_index.template.json 这个文件中的内容来下载东西。打开该文件可以看到，要安装的第一个 tools 模块是 riscv32-esp-elf-gcc（版本不同有可能稍有区别），下面给出了不同系统架构下的该软件的下载链接。为了确认自己的 host 类型，可以运行一下前面的 get.exe，在命令行界面刚出来的时候，会显示系统信息和平台信息。如：123System: Windows, Info: Windows-10-10.0.17763Platform: i686-mingw32所以就下载 i686-mingw32 下面对应的下载链接中的内容，下载后解压放到 ${Arduino}/hardware/espressif/esp32/tools 目录下。其他模块类似，都是下载相应的版本然后放在一起就行。注意有的模块下载后文件夹的命名可能需要修改，不要带有版本号等其他信息。全部模块都下载后就可以在 Arduino 软件中选择开发板，并正常编译了。","tags":"硬件拾忆 arduino esp32"},{"title":"Hexo 常用指令","url":"/article/2a82771e.html","text":"一、安装、更新、初始化12345npm install hexo -g # 安装npm update hexo -g # 更新hexo init # 初始化二、写作123456789101112131415hexo publish [layout] &lt;title&gt; 发表草稿hexo n &quot;name&quot; # 新建文章hexo g # 生成静态网页hexo p # 发表草稿hexo s # 启动服务hexo d # 部署网站hexo g -d # 生成静态网页并部署网站hexo d -g # 生成静态网页并部署网站，与 hexo g -d 完全一样三、服务器Hexo 3.0 把服务器独立成了个别模块，必须先安装才能使用。1234567891011npm install hexo-server --save # 安装服务hexo s # 启动服务，可以通过浏览器输入 http://localhost:4000/ 来查看，默认端口为 4000hexo server -p 5000 # 更改端口hexo s -s # 静态模式hexo s -i 192.168.1.1 # 自定义iphexo clean # 清除缓存","tags":"软件使用 hexo"},{"title":"AXI4 接口定义速查","url":"/article/ad4ca854.html","text":"以下截图自 ARM 官方的《AMBA AXI and ACE Protocol Specification》，文档编号为 ARM IHI 0022H.c(ID012621)。〇、全局信号一、写地址通道（AW Channel）二、写数据通道（W Channel）三、写响应通道（B Channel）四、读地址通道（AR Channel）五、读数据通道（R Channel）","tags":"fpga axi"},{"title":"test","url":"/article/d87f7e0c.html","text":"","tags":""},{"title":"逆波兰表达式","url":"/article/93bfc68e.html","text":"逆波兰表达式，即后缀表达式，常用于表达式求值中。相应的波兰表达式为前缀表达式。后缀表达式的特点是事先考虑运算符的优先级，运算符在操作数之后，不需要处理括号。正常的表达式为中缀表达式，可以通过几种方式由中缀表达式得到后缀表达式。笔算方法一：① 将两个直接操作数用括号括起来；② 将操作符提到括号后；③ 去掉括号。例如：​ 1+3*2-6&#x2F;2：① ((1+(3*2))-(6&#x2F;2))② ((1(32)*)+(62)&#x2F;)-③ 132*+62&#x2F;-即 1+3*2-6&#x2F;2 → 132+62&#x2F;-使用这种方法还可得到前缀表达式，即在第 ② 步将操作符提到括号前。方法二：写出表达式树（编程实现时，常用后缀表达式生成表达式树），然而进行后序遍历即可得到后缀表达式。表达式树的特点是所有操作数都位于叶子结点上，所有的叶子结点的数据都是操作数，操作符位于分支结点上。例如：​ A+B*(C-D)-E&#x2F;F经过后序遍历得到：ABCD-*+EF&#x2F;-程序算法从左到右遍历中缀表达式：① 遇到操作数时就输出，加入后缀表达式；② 遇到操作符时：若为 ‘(‘，入栈若为 ‘)’，则依次把栈中的运算符加入后缀表达式，直到出现 ‘(‘，从栈中直接删除 ‘(‘若为除括号外的其他操作符，当其优先级高于除 ‘(‘ 以外的栈顶运算符时，直接入栈。否则从栈顶开始，依次弹出比当前处理的操作符优先级高和优先级相等的操作符，直到一个比它优先级低的或遇到了一个左括号为止③ 遍历结束后，栈中剩下的操作符依次出栈加入后缀表达式。根据以上原则，可以用数字对栈内和栈外的操作符优先级进行排序：操作符#(*，&#x2F;+，-)isp01536isp06421其中，isp 表示栈内优先（in stack priority），icp 表示栈外优先（in coming priority）。在表达式之后加上符号 ‘#’ 表示表达式结束，相应地，在遍历表达式之前，先入栈一个 ‘#’。","tags":"算法"},{"title":"Numpy 中 linspace() 与 arange() 的区别","url":"/article/98889d59.html","text":"从功能上，两者都是生成一个 numpy.ndarray 类型的等差数列。12arange(start=None, stop=None, step=None, dtype=None)linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)numpy.arange() 的参数是 start，stop 和 step（步长）numpy.linspace() 的参数是 start，stop 和 num（数量）numpy.arange() 是将从 start 到 stop 的区间，按照步长 step 生成含 (stop-start)&#x2F;step 个元素的向量，结果中不包含 stop。例如：12v = np.arange(0, 1, 0.1)print(v)的结果是：1[ 0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]numpy.linspace() 是将从 start 到 stop 的区间，按照步长 (stop-start)&#x2F;(num-1) 生成含 num 个元素的向量，结果中包含 stop。例如：12u = np.linspace(0, 1, 10)print(u)的结果是：12[ 0. 0.11111111 0.22222222 0.33333333 0.44444444 0.55555556 0.66666667 0.77777778 0.88888889 1. ]其步长为 (1 - 0)&#x2F;(10-1) &#x3D; 0.111…，共 10 个元素。而12u = np.linspace(0, 1, 11)print(u)的结果是：1[ 0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. ]其步长为 (1 - 0)&#x2F;(11-1) &#x3D; 0.1，共 11 个元素。","tags":"编程语言 python"},{"title":"Markdown 语法","url":"/article/78e09c9c.html","text":"Markdown 是一种轻量级标记语言，可以让人专注于文字内容而不是排版样式，可读性强，直观，入门简单。标题12345# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题效果：一级标题二级标题三级标题四级标题五级标题标题最多 6 级。# 与标题之间用一个空格隔开。引用123&gt;123&gt;&gt; 234&gt;&gt;&gt; 345效果：123234345插入分割线12---***效果：插入图片或链接12![图片文件名](图片链接)[显示的内容](链接)插入图片需要使用图床产生链接，例如使用 SM.MS。插入表格12345| 123 | 456 | 789 || --- | --- | --- || 111 | 111 | 111 || 222 | 222 | 222 || 333 | 333 | 333 |效果：123456789111111111222222222333333333Markdown 中的表格也可以换行、合并单元格等。插入代码使用 · 或 ··· 将代码上下括起来即可（注意不是单引号，是键盘中 Tab 键上方那个符号），通常 · 用于语句中内嵌代码，只能显示为一行，··· 用于插入代码块，可以按照输入格式显示为多行。效果：使用 · ：print(123) 123使用 ··· ：12print(123)123粗体、斜体、下划线、删除线1234**粗体123***斜体123*&lt;u&gt;下划线123&lt;/u&gt;~~删除线123~~效果：粗体123斜体123下划线123删除线123字体、文字颜色、文字大小通过内嵌 HTML，可以调整 Markdown 文本的字体、文字颜色、文字大小（有些编辑器内可能不支持）。123456&lt;font face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;华文彩云&lt;/font&gt;&lt;font color=#0099ff size=10 face=&quot;黑体&quot;&gt;深蓝色黑体 10号&lt;/font&gt;&lt;font color=#00ffff size=10&gt;浅蓝色 10号&lt;/font&gt;&lt;font color=gray size=10&gt;灰色 10号&lt;/font&gt;效果：黑体微软雅黑华文彩云深蓝色黑体 10号浅蓝色 10号灰色 10号常用文字颜色：1234567891011121314151617红色：&lt;font color=&quot;#dd0000&quot;&gt;显示文字&lt;/font&gt;绿色：&lt;font color=&quot;#00dd00&quot;&gt;显示文字&lt;/font&gt;蓝色：&lt;font color=&quot;#0000dd&quot;&gt;显示文字&lt;/font&gt; 黄色：&lt;font color=&quot;#dddd00&quot;&gt;显示文字&lt;/font&gt;青色：&lt;font color=&quot;#00dddd&quot;&gt;显示文字&lt;/font&gt;紫色：&lt;font color=&quot;#dd00dd&quot;&gt;显示文字&lt;/font&gt;效果：显示文字显示文字显示文字显示文字显示文字显示文字其他颜色可查询：RGB颜色查询对照表","tags":"编程语言 markdown"},{"title":"常用数学符号","url":"/article/2736cc94.html","text":"希腊字母α β γ δ ε ζ η θ ι κ λ μ ν ξ ο π ρ σ τ υ φ χ ψ ωΑ Β Γ Δ Ε Ζ Η Θ Ι Κ Λ Μ Ν Ξ Ο Π Ρ Σ Τ Υ Φ Χ Ψ Ω逻辑关系≈ ≠ ≥ ≤ ∽ ≌ ∥⊆ ⊂ ⊇ ⊃集合∪ ∩ ∈推理∀ ∃ ⊥ ∽ △ ∠ ∩ ∪ ≠ ≡ ± ≥ ≤ ∈ § ∵ ∴← ↑ → ↓ ↖ ↗ ↘ ↙ ∥ ∧ ∨微积分∫ ∮ ∂ ∑ ∏ ▽几何⊥ ∥ ∠ ⌒ ⊙ ≡ ≌ △代数∝ ∧ ∨ ～ ∫ ≠ ≤ ≥ ≈ ∞ ∶离散数学符号├ 断定符（公式在L中可证）╞ 满足符（公式在E上有效，公式在E上可满足）┐ 命题的“非”运算∧ 命题的“合取”（“与”）运算∨ 命题的“析取”（“或”，“可兼或”）运算→ 命题的“条件”运算A&lt;&#x3D;&gt;B 命题A 与B 等价关系A&#x3D;&gt;B 命题 A与 B的蕴涵关系A* 公式A 的对偶公式wff 合式公式iff 当且仅当↑ 命题的“与非” 运算（ “与非门” ）↓ 命题的“或非”运算（ “或非门” ）□ 模态词“必然”◇ 模态词“可能”φ 空集∈ 属于（??不属于）P（A） 集合A的幂集|A| 集合A的点数R^2&#x3D;R○R [R^n&#x3D;R^(n-1)○R] 关系R的“复合”（或下面加 ≠） 真包含∪ 集合的并运算∩ 集合的交运算-（～） 集合的差运算〡 限制[ A ](右下角R) 集合关于关系R的等价类A&#x2F; R 集合A上关于R的商集[a] 元素a 产生的循环群I (i大写) 环，理想Z&#x2F;(n) 模n的同余类集合r(R) 关系 R的自反闭包s(R) 关系 的对称闭包CP 命题演绎的定理（CP 规则）EG 存在推广规则（存在量词引入规则）ES 存在量词特指规则（存在量词消去规则）UG 全称推广规则（全称量词引入规则）US 全称特指规则（全称量词消去规则）R 关系r 相容关系R○S 关系 与关系 的复合domf 函数 的定义域（前域）ranf 函数 的值域f:X→Y f是X到Y的函数GCD(x,y) x,y最大公约数LCM(x,y) x,y最小公倍数aH(Ha) H 关于a的左（右）陪集Ker(f) 同态映射f的核（或称 f同态核）[1，n] 1到n的整数集合d(u,v) 点u与点v间的距离d(v) 点v的度数G&#x3D;(V,E) 点集为V，边集为E的图W(G) 图G的连通分支数k(G) 图G的点连通度△（G) 图G的最大点度A(G) 图G的邻接矩阵P(G) 图G的可达矩阵M(G) 图G的关联矩阵C 复数集N 自然数集（包含0在内）N* 正自然数集P 素数集Q 有理数集R 实数集Z 整数集Set 集范畴Top 拓扑空间范畴Ab 交换群范畴Grp 群范畴Mon 单元半群范畴Ring 有单位元的（结合）环范畴Rng 环范畴CRng 交换环范畴R-mod 环R的左模范畴mod-R 环R的右模范畴Field 域范畴Poset 偏序集范畴","tags":"数学"},{"title":"CodeBlocks 不能编译或调试的解决办法","url":"/article/e6474535.html","text":"今天新装了最新版的 Code::Blocks17.12，下载的时候选择了完整版（带了 MinGW），编译一切正常，但是 Debug 的时候报了错：123ERROR: You need to specify a debugger program in the debuggers&apos;s settings.(For MinGW compilers, it&apos;s &apos;gdb.exe&apos; (without the quotes))(For MSVC compilers, it&apos;s &apos;cdb.exe&apos; (without the quotes))这是因为没有设置调试器（以前用的那个版本好像安装完就能直接调试）。如果下载的是完整版的，就按照以下步骤添加调试器路径：Settings -&gt; Debugger -&gt; Default -&gt; Executable path路径为：CodeBlocks\\MinGW\\bin\\gdb32.exe （也有可能是 gdb.exe）如果路径下没有这个文件，就从 http://www.equation.com/servlet/equation.cmd?fa=gdb 下载一个。如果是没法编译，也是下载一个 MinGW ，安装，然后配置系统变量。最后在 CodeBlocks 软件中 Settings -&gt; Complier 选择 GUN GCC Compiler 编译器即可。","tags":"软件使用 codeblocks"},{"title":"C++ 模板的编译问题","url":"/article/f1dd40fc.html","text":"一、C++ 对模板的编译使用普通函数和类的时候，编译器只需掌握函数或类的声明即可，所以声明和定义通常分别放在 .h 和 .cpp 文件中。而模板和模板的成员函数都是在用到的时候才会实例化，这就导致如果按照普通函数或类的方法去定义和声明模板类，在链接阶段，链接器将找不到模板函数或模板类成员函数的定义，因为它们所在的 .cpp 文件并未被编译。为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，因此模板的头文件通常既包括声明，也包括定义。事实上，C++对想要将声明和定义分别放在两个文件中进行编译提供了两种方式：包含编译分离编译包含编译：大部分内容与正常函数或类的定义和声明相同，只是文件包含有所区别，不需要 cpp 头部包含 .h 文件，而是用头文件包含源文件，在 .h 文件的末尾#include&lt;XXX.cpp&gt;。这样其实就相当于把所有内容都写在了头文件中，因为预编译阶段就是把 #include 的文件复制到包含位置。分离编译：仍是大部分内容与正常函数或类的定义和声明相同，在定义所在的 .cpp 文件中的函数定义的最前面加上 export 关键字，以告诉编译器该定义在哪里被引用。然而在 codeblocks12.11 中使用上面两种方法时，均失败。分别报错说 .cpp 中的类名“does not name a type”，和 export 关键字没有被实现，因而将被忽略，进而导致实例化时该类模板“undefined reference”。可见，以上两种方法虽理论上可行，但实际上由于编译器的原因，并不一定能使用。二、Codeblocks 中使用模板的方法方法一：定义和声明放在同一个 .h 文件中。这是最可靠的方式，无论哪个编译器都不会出错。只是有可能在大规模项目中导致文件特别大。方法二：声明和定义放在不同的 .h 文件中，在声明文件的末尾（注意是末尾） #include 定义的 .h 文件。这样做原理上与方法一是一致的，在预编译阶段通过复制使它们成为了一个文件。方法三：声明和定义分别放在 .h 和 .cpp 文件中，.cpp 文件包含 .h 文件，在 .cpp 文件中写一个函数，对该文件中涉及到的所有成员函数全部实例化一遍（如果只对部分成员函数实例化了，则剩余函数不会被编译）。这种方法的原理在于：如果不在 .cpp 文件中进行实例化，编译阶段编译器遇到这个 .cpp 文件，一看里面全是模板，就会将这个文件忽略，这样在链接阶段，链接器就会因为找不到模板函数的定义文件而报错。在 .cpp 文件中通过一个函数进行了实例化之后，编译阶段，编译器发现这个文件中有非模板函数，就会对其进行编译，由于它的内部对模板进行了实例化，所以，而这些模板的定义和声明又有迹可循，所以就能对它们进行编译。方法四：声明和定义分别放在 .h 和 .cpp 文件中，.cpp 文件包含 .h 文件，在实例化模板的文件中，再统一包含这两个文件。例如，在 main() 函数中对类模板及其中的成员函数进行了实例化，则在 main() 函数所在的文件头部包含 .cpp 和 .h 文件。此方法的原理类似于方法三。以上四种方法都是在 codeblocks12.11 中验证过的。总体来说，还是方法一和方法二更实用一些。但是在摸索这些方法的过程中，加深对程序编译和 C++ 语言特性的理解，还是颇有好处的。参考博文及书籍：《C++ primer（中文第 5 版）》https://blog.csdn.net/xiaoyaohuqijun/article/details/50558208https://blog.csdn.net/qq_41230365/article/details/80207842https://blog.csdn.net/u012814856/article/details/84645963https://blog.csdn.net/chenyiming_1990/article/details/9094593","tags":"c++ 编程语言"},{"title":"C++ 模板","url":"/article/bac12bc7.html","text":"一、函数模板（Function Template）值的参数化：在函数定义时形参数据的值是未知的，只有等到函数调用时接收了实参才能确定其值。类型的参数化：在 C++ 中，数据类型也可以通过参数来传递，在函数定义时不指明具体数据类型，函数调用时，编译器可以根据传入的实参自动推断数据类型。函数模板：建立一个函数的模板，其用到的数据类型（返回值、形参、局部变量的类型）用一个虚拟的类型代替。函数模板的语法：（模板头 + 使用新定义的类型参数的函数定义）1234template &lt;typename 类型参数1 , typename 类型参数2 , ...&gt; 返回值类型 函数名(形参列表)&#123; …&#125;比如：123456template&lt;typename T&gt; void Swap(T &amp;a, T &amp;b)&#123; T temp = a; a = b; b = temp;&#125;函数模板也可以先声明后定义，但是声明的时候也必须带上模板头。可以用多个 typename 声明多种不同的类型参数。typename 关键字也可以使用 class 关键字代替。二、类模板（Class Template）类模板的定义与函数模板类似，语法如下：123template&lt;typename 类型参数1, typename 类型参数2 , …&gt; class 类名&#123; …&#125;;类的成员函数的定义时，语法为：12345template &lt;typename 类型参数1, typename 类型参数2, …&gt;返回值类型 类名&lt;类型参数1, 类型参数2, … &gt; :: 函数名(参数表)&#123; …&#125;在类名之后，需带上该类全部的类型参数表（不需要写 typename），函数的参数表中，用到了哪个类型参数写哪个就可以。123456789101112131415161718192021222324252627282930313233343536373839template&lt;typename T&gt; class Operation&#123;public: Operation(T a, T b) :m_a(a), m_b(b)&#123;&#125; T Sum(); bool SetValue(T a, T b);private: T m_a; T m_b;&#125;;template&lt;typename T&gt;T Operation&lt;T&gt;::Sum()&#123; T c = m_a + m_b; return c;&#125;template&lt;typename T&gt;bool Operation&lt;T&gt;::SetValue(T a, T b)&#123; m_a = a; m_b = b;&#125;int main()&#123; Operation&lt;float&gt; ope(2.3, 3.4); float sum = ope.Sum(); cout &lt;&lt; sum &lt;&lt; endl;return 0;&#125;使用类模板创建对象时，需显示指明类型参数，例如：1Operation&lt;float&gt; ope(2.3, 3.4);如果是创建对象指针，赋值时两边都要指明具体类型，且要保持一致：1Operation&lt;float&gt; *ope = new Operation&lt;float&gt;(1.2, 2.3);另外，也可以仿造类模板定义结构体模板。","tags":"c++ 编程语言"},{"title":"爬虫网页基础","url":"/article/96ce78ad.html","text":"《Python 网络爬虫开发实战（崔庆才著）》笔记一、HTTP 基本原理1、URI 和 URLURI（Uniform Resource Identifier，统一资源标志符）URL（Universal Resource Locator，统一资源定位符）URI 包括 URL 和 URN（Universal Resource Name，统一资源名称），URL 是 URI 的子集。URN 用的较少，所以几乎所有的 URI 都是 URL。URL&#x2F;URI 唯一指定一个资源，包括：访问协议访问路径（根目录）资源名称2、超文本网页的源代码就可以称作超文本。3、HTTP 和 HTTPS常见协议类型：http（Hyper Text Transfer Protocol）https（Hyper Text Transfer Protocol over Secure Socket Layer）ftpsftpsmb爬虫主要爬取 http 或 https 协议。http 协议用于从网络传输超文本数据到本地浏览器的传送协议，能保证高效而准确地传送超文本文档。https 协议是以安全为目标的 HTTP 通道，在 HTTP 下加入 SSL 层，是 HTTP 的安全版。SSL 的主要作用有两种：建立一个信息安全通道来保证数据传输的安全确认网站的真实性，使用 HTTPS 的网站，都可以点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可通过 CA 机构颁发的安全签章来查询某些网站虽使用了 HTTPS 协议，但证书不是被 CA 机构认证的，爬取时需要设置忽略证书的选项，否则会提示 SSL 连接错误。4、HTTP 请求过程浏览器中输入一个 URL，按下回车之后，浏览器向网站所在的服务器发送一个请求，网站服务器接收到请求后进行解析和处理，然后返回对应的响应，接着传回给浏览器。响应里包含了页面的源代码等内容。5、请求请求由客户端向服务器发出，可分为 4 部分内容：请求方法（Request Method）请求的网址（Request URL）请求头（Request Headers）请求体（Request Body）（1）请求方法方法描述GET请求页面，并返回页面内容HEAD类似 GET 请求，但返回的响应中没有具体内容，用于获取报头POST大多用于提交表单或上传文件，数据包含在请求体中PUT从客户端向服务器传送的数据取代指定文档中的内容DELETE请求服务器删除指定的页面CONNECT把服务器当跳板，让服务器代替客户端访问其他网页OPTINONS允许客户端查看服务器的性能TRACE回显服务器收到的请求，主要用于测试或诊断其中常用的是 GET 和 POST。在浏览器直接输入 URL 并回车，发起的是 GET 请求。POST 请求大多在表单提交时发起。如登录时需要提交用户名和密码，如果用 GET 方法，密码将暴露在 URL 中，又或者上传文件时，由于文件内容较大，也会选用 POST 方式。GET 和 POST 请求方法的区别为：GET 请求中的参数包含在 URL 里，数据可以在 URL 中看到。POST 请求的 URL 不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中GET 请求提交的数据最多只有 1024 字节，而 POST 方式没有限制。（2）请求的网址即 URL，唯一确定欲请求的资源。（3）请求头用于说明服务器要使用的附加信息。常用的头信息有：Accept：请求报头域，用于指定客户端可接受哪些类型的信息Accept-Language：指定客户端可接受的语言类型Accept-Encoding：指定客户端可接受的内容编码Cookies：网站为了辨别用户进行会话跟踪而存储在用户本地的数据，主要功能是维持当前访问对话Referer：用于标识这个请求是从哪个页面发来的，服务器可拿到这一信息并做相应处理，如做来源统计、防盗链处理等User-Agent：用户代理（UA），可使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。做爬虫时加上此信息，可伪装成浏览器Content-Type：也叫互联网媒体类型或者 MIME 类型，在 HTTP 协议消息头中，用来表示具体请求中的媒体类型信息（4）请求体一般承载的内容是 POST 请求中的表单数据，GET 请求的请求体为空Content-Type 和 POST 提交数据方式的关系Content-Type提交数据的方式application&#x2F;x-www-form-urlencoded表单数据multipart&#x2F;form-data表单文件上传application序列化 JSON 数据text&#x2F;xmlXML 数据6、响应响应由服务器端返回给客户端，可分为三部分：响应状态码（Response Status Code）响应头（Response Headers）响应体（Response Body）（1）响应状态码状态码说明详情1XX100继续请求者应当继续提出请求。服务器已收到请求的一部分，正在等待其余部分101切换协议请求者已要求服务器切换协议，服务器已确认并准备切换2XX200成功201已创建202已接受203非授权信息204无内容205重置内容206部分内容3XX300多种选择301永久移动302临时移动303查看其他位置304未修改305使用代理307临时重定向4XX400错误请求401未授权403禁止访问404未找到405方法禁用406不接受407需要代理授权408请求超时409冲突410已删除411需要有效长度412未满足前提条件413请求实体过大414请求 URI 过长415不支持类型416请求范围不符417未满足期望值5XX500服务器内部错误服务器遇到错误，无法完成请求501未实现服务器不具备完成请求的功能502错误网关服务器作为网关或代理，从上游服务器收到无效响应503服务不可用服务器目前无法使用504网关超时服务器作为网关或代理，但是没有及时从上游服务器收到请求505HTTP 版本不支持（2）响应头响应头包含了服务器对请求的应答信息，如 Content-Type、Server、Set-Cookie 等。常用的响应头信息：Date：标识响应产生的时间Last-modified：指定资源的最后修改时间Content-Encoding：指定响应内容的编码Server：包含服务器的信息，比如名称、版本号等Content-Type：文档类型，指定返回的数据类型，text&#x2F;html 代表返回 HTML 文档，application&#x2F;x-javascript 代表返回 JavaScript 文件，image&#x2F;jpeg 代表返回图片Set-Cookie：设置 Cookies。响应头中的 Set-Cookie 告诉浏览器需要将此内容放在 Cookies 中，下次请求携带 Cookies 请求Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间（3）响应体存放响应的正文数据。比如请求网页时，响应体就是网页的 HTML 代码；请求图片时，响应体就是图片的二进制数据。爬虫请求网页后，要解析的内容就是响应体。二、网页基础1、网页的组成网页可分为三大部分HTML，定义网页的内容和结构CSS，描述网页的布局JavaScript，定义网页的行为（1）HTMLHyper Text Markup Language，即超文本标记语言。HTML 定义了网页的结构。不同类型的元素通过不同类型的标签来表示，如图片用 img，视频用 video，段落用 p。各种类型之间的布局又通过布局标签 div 嵌套组合而成。（2）CSSCascading style Sheets，即层叠样式表。“层叠”是指当在 HTML 中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等格式。在网页中，一般统一定义整个网页的样式规则，并写入 CSS 文件中。在 HTML 中，只需要用 link 标签即可引入写好的 CSS 文件，这样整个页面就会变得美观、优雅。（3）JavaScript简称 JS，是一种脚本语言。HTML 和 CSS 配合使用，提供给用户的只是一种静态信息，缺乏交互性。JS 的出现使得用户与信息之间不只是一种浏览与现实的关系，而是实现了一种实时、动态、交互的页面功能。在 HTML 中通过 script 标签即可引入 .js 文件。2、网页的结构一个网页的标准形式是 html 标签内嵌套 head 和 body 标签，head 内定义网页的配置和引用，body 内定义网页的正文。3、节点树及节点间的关系在 HTML 中，所有标签定义的内容都是结点，它们构成了一个 HTML DOM 树。DOM 是 Document Object Model 即文档对象类型，它定义了访问 HTML 和 XML 文档的标准。W3C DOM 标准被分为 3 个不同的部分：核心 DOM：针对任何结构化文档的标准模型XML DOM：针对 XML 文档的标准模型HTML DOM：针对 HTML 文档的标准模型根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：整个文档是一个文档节点每个 HTML 元素是元素节点HTML 元素内的文本是文本节点每个 HTML 属性是属性节点注释是注释节点通过 HTML DOM，树中的所有节点均可通过 JavaScript 访问，所有 HTML 节点元素均可被修改，也可被创建或删除。4、选择器网页由一个个节点组成，CSS 选择器会根据不同的节点设置不同的样式规则。在 CSS 中，使用 CSS 选择器来定位节点。还有一种比较常用的选择器是 XPath。三、爬虫的基本原理1、爬虫概述（1）获取网页使用请求库获取网页的源代码。（2）提取信息从 Body 部分提取需要的数据，最通用的方法是采用正则表达式提取。另外由于网页的结构有一定规则，所以还有一些根据网页节点属性、CSS 选择器或者 Xpath 来提取网页信息的库，如 BeautifulSoup、pyquery、lxml 等。（3）保存数据可以简单保存为 TXT 文本或 JSON 文本，也可以保存到数据库，如 MySQL 或 MongoDB 等，也可以保存到远程服务器，如借助 SFTP 进行操作等。（4）自动化程序即爬虫可以替代人来完成这些操作。2、能抓怎样的数据只要在浏览器里可以访问到的文件，都可以抓取下来。3、JavaScript 渲染页面很多网页可能是由 JavaScript 渲染出来的，原始的 HTML 代码就是一个空壳。JavaScript 会改变 HTML 中的节点，向其添加内容，最后得到完整的页面。对于使用 JavaScript 渲染的网页，有时候得到的源代码和浏览器看到的不一样，因此使用基本 HTTP 请求库得到的源代码可能跟浏览器中的页面源代码不太一样，可以分析其后台 Ajax 接口，也可以使用 Selenium、Splash 这样的库来模拟 JavaScript 渲染。四、会话和 Cookies1、静态网页和动态网页静态网页 —— 由 HTML 代码编写，文字、图片等内容均通过写好的 HTML 代码来指定。动态网页 —— 可以动态解析 URL 中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变。动态网站可还以实现用户登录和注册的功能。2、无状态 HTTPHTTP 的无状态是指 HTTP 协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态。于是出现了两个用于保持 HTTP 连接状态的技术：会话在服务器端，用来保存用户的会话信息会话对象用于存储特定用户会话所需的属性及配置信息用户在应用程序的 Web 页之间跳转时，存储在会话对象中的变量不会丢失用户请求 Web 页时，如果还没有会话，Web 服务器将自动创建一个会话对象，当会话过期或被放弃后，服务器将终止该会话Cookies在客户端，是某些网站为了辨别用户身份、进行会话跟踪而存储在用户本地终端上的数据。浏览器在下次访问网页时会自动附带上 Cookies 发送给服务器，服务器通过识别 Cookies 并鉴定出是哪个用户，在判断用户是否是登录状态，然后返回对应的响应Cookies 是客户第一次请求服务器时，由服务器返回一个请求头中带有 Set-Cookie 字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把 Cookies 保存起来。会话 Cookie 和持久 Cookie：会话 Cookie 就是把 Cookie 放在浏览器内存里，浏览器在关闭之后该 Cookie 即失效持久 Cookie 则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态-严格来说，没有会话 Cookie 和持久 Cookie 之分，只是有 Cookie 的 Max Age 或 Expires 字段决定了过期的时间3、常见误区关闭浏览器不会导致会话消失，所以需要服务器为会话设置一个失效时间。五、代理的基本原理1、基本原理代理指代理服务器，英文叫作 proxy server，它的功能是代理网络用户去取得网络信息，是网络信息的中转站。这个过程中 Web 服务器识别出的真实 IP 就不再是我们本机的 IP 了，就成功实现了 IP 伪装。2、代理的作用突破自身 IP 访问限制，访问一些平时不能访问的站点访问一些单位或团体内部资源提高访问速度隐藏真实 IP3、爬虫代理使用代理隐藏真实的 IP，让服务器误以为是代理服务器在请求自己，这样在爬取过程中通过不断更换代理，就不会被封锁，可以达到很好的爬取效果。4、代理分类根据协议区分：FTP 代理服务器HTTP dialing服务器SSL&#x2F;TLS 代理RTSP 代理Telnet 代理。主要用于 telnet 远程控制（黑客入侵计算机时常用于隐藏身份），端口一般为23POP3&#x2F;SMTP 代理SOCKS 代理。只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般有缓存功能，端口一般为 1080根据匿名程度区分：高度匿名代理普通匿名代理透明代理。除了能用缓存技术提高浏览速度，能用内容过滤提高安全性之外，无其他显著作用，最常见的例子是内网中的硬件防火墙间谍代理5、常见代理设置使用网上的免费代理，最好使用高匿代理使用付费代理服务，质量好ADSL 拨号，拨一次号换一次 IP，稳定性高","tags":"cs基础"},{"title":"C++ 字符串、向量和数组","url":"/article/cddca394.html","text":"《C++ primer》笔记一、命名空间的 using 声明1、若不用 using 声明命名空间 std，使用库函数需要 std::cin 的形式。2、头文件不应包含 using 声明。3、using 的两种形式：12using namespace std // 可使用命名空间的所有对象using std::cin // 只能使用 cin，其他仍加 std::二、标准库类型 string1、标准库类型 string 表示可变长的字符序列，使用 string 类型必须先包含 string 头文件。2、初始化 string 对象的方式拷贝初始化直接初始化123456string s1 // 默认初始化，s1 是一个空串string s2(s1) // s2 是 s1 的副本strings2=s1 // 等价于 s2(s1)，s2 是 s1 的副本 string s3(&quot;value&quot;) // s3 是字面值“value”的副本，除了字面值最后的那个空字符外string s3=&quot;value&quot; // 等价于 s3(&quot;value&quot;)，s3 是字面值&quot;value&quot;的副本string s4(n，&apos;c&apos;) // 把 s4 初始化为由连续 n 个字符 c 组成的串3、string对象上的操作os &lt;&lt; s将 s 写到输出流 os 当中，返回 osis &gt;&gt; s从 is 中读取字符串赋给 s，字符串以空白分隔，返回 isgetline(is, s)从 is 中读取一行赋给 s，返回 iss.empty()s 为空返回 true，否则返回 falses.size()返回 s 中字符的个数s[n]返回 s 中第 n 个字符的引用，位置 n 从 0 计起s1 + s2返回 s1 和 s2 连接后的结果s1 &#x3D; s2用 s2 的副本代替 s1 中原来的字符s1 &#x3D;&#x3D; s2如果 s1 和 s2 中所含的字符完全一样，则它们相等；s1 !&#x3D; s2string 对象的相等性判断对字母的大小写敏感&lt;，&lt;&#x3D;，&gt;，&gt;&#x3D;利用字符在字典中的顺序进行比较，且对字母的大小写敏感4、string 会自动忽略输入流开头的空白，从第一个真正的字符开始读起，直到遇见下一处空白为止。5、使用 getline 可以保留输入流中的空白符。getline 遇到换行符才结束。结果中并不包含换行符。6、size 函数返回一个 string::size_type 类型的值。size_type 是一个无符号整型数，因此不能在表达式中混用带符号数和无符号数。7、string 对象可比较大小。8、标准库允许把字符字面值和字符串字面值转换成 string。string 和字面值可以相加，但两个字符串字面值无法相加。9、cctype 头文件中定义的一组标准库函数可以判断 string 中的单个字符。10、C++ 兼容 C 语言的 &lt;name.h&gt; 头文件命名形式为，中定义的名字从属于 std 命名空间。11、范围 for 语句可以处理 string对象中的单个元素。12、访问 string 对象的单个字符有两种方式：下标，和迭代器。三、标准库类型 vector1、vector 表示对象的集合，其中所有对象的类型都相同。因为 vector “容纳着”其他对象，所以也叫容器。2、使用 vector，必须包含。3、vector 是一个类模板。模板本身不是类或函数，可以将模板看作为编译器生成类或函数编写的一份说明。4、编译器根据模板创建类或函数的过程称为实例化，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。5、引用不是对象，所以不存在包含引用的 vector。6、某些编译器可能仍需以老式的声明语句来处理元素为vector的vector对象，如vector&lt;vector&gt;。（两个&gt;&gt;之间有空格）7、初始化 vector 对象的方法vectorv1v1 是一个空 vector，它潜在的元素是 T 类型的，执行默认初始化vectorv2(v1)v2 中包含有 v1 所有元素的副本vectorv2&#x3D;v1等价于v2（v1），v2中包含有v1所有元素的副本vectorv3(n，val)v3 包含了 n 个重复的元素，每个元素的值都是 valvectorv4(n)v4 包含了 n 个重复地执行了值初始化的对象vectorv5{a, b, c…}v5包含了初始值个数的元素，每个元素被赋予相应的初始值vectorv5&#x3D;{a, b, c…}等价于v5{a, b, c…}8、用花括号 {} 表示列表初始化，用 () 表示数量初始化9、利用 vector 对象的 push_back 成员函数向其中添加元素。10、不能使用下标形式添加元素。可用下标访问已存在元素。确保下标合法的一种有效手段就是尽可能使用范围 for 语句。四、迭代器1、所有标准库容器都可以使用迭代器。string 也支持。2、迭代器提供了对对象的间接访问。3、有迭代器的类型都有返回迭代器的成员，分别是 begin 和 end。end 返回指向“尾后”元素的迭代器（尾元素的下一位置）。4、标准迭代器的运算符。5、拥有迭代器的标准库使用 iterator 和 const_iterator 来表示迭代器的类型。6、迭代器运算。五、数组1、与 vector 不同的是，数组的大小确定不变。2、定义数组必须制定类型，不能用 auto。3、不存在引用的数组。4、不允许用于拷贝和赋值的右值。5、理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。6、使用数组下标的时候，通常将其定义为 size_t 类型。7、使用数组时，编译器一般会把它转换成指针。8、指针也是迭代器。9、C 风格的字符串尽量不要在 C++ 中使用，因为不方便，且容易引发程序漏洞。10、允许使用以空字符结束的字符数组来初始化 string 对象或为 string 对象赋值。在 string 对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在 string 对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。11、在 C++ 程序中应尽量使用 vector 和迭代器，避免使用内置数组和指针。尽量使用 string，避免使用 C 风格的基于数组的字符串。六、多维数组1、多维数组，即数组的数组。2、要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。3、可用类型别名简化多维数组的指针12using int_array = int[4];typedef int int_array[4];","tags":"c++ 编程语言"},{"title":"C++ 数据类型","url":"/article/4d9205f1.html","text":"《C++ primer》笔记一、基本内置类型1、long long 是在 C++11 中新定义的。2、char 和 signed char 并不一样。3、long 一般和 int 有一样的尺寸。4、算术表达式中不要使用 char 或 bool。char 跨平台容易出问题，要用也明确指明 signed 或 unsigned。5、浮点运算通常选 double，float 通常精度不够，且二者计算代价相差无几。6、无符号类型赋值时如果超范围，将取模后赋值。有符号类型赋值时如果超范围，结果是未定义的。7、不要混用有符号类型和无符号类型，计算时有符号类型会转换成无符号类型。8、指定常量（字面值）的类型字面值即常量，每种字面值都有对应的数据类型。L’a’宽字符型字面值，类型是 wchar_tu8”hi”utf-8字符串字面值（utf-8 用 8 位编码一个 Unicode 字符）42ULL无符号整型字面值，类型是 unsigned long long1E-3F单精度浮点型字面值，类型是 float3.14159L扩展精度浮点型字面值，类型是 long double字符和字符串常量（字面值）前缀含义类型uUnicode 16 字符char16_tUUnicode 32 字符char32_tL宽字符wchar_tu8UTF-8(仅用于字符串常量)char整型字面值后缀最小匹配类型u or Uunsignedl or Llongll or LLlong long浮点型字面值后缀类型f or Ffloatl or Llong double布尔字面值 和 指针字面值true 和 flasenullptr二、变量1、对 C++ 程序员来说，变量 和 对象 一般可以互换使用。2、一般情况下，对象指一块能存储数据并具有某种类型的内存空间。3、C++ 中初始化和赋值是两个完全不同的概念。初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。4、四种初始化语句：1234int units sold=0; int units_sold=&#123;0]; int units_sold&#123;0&#125;;int units sold(0);使用花括号（列表初始化）的好处是若初始值存在丢失信息的风险，则编译器将报错。如将 long double 型的常量赋给 int 型变量。5、未初始化的变量将被默认初始化，默认值由变量类型决定，同时定义变量的位置也会对此有影响。内置类型的变量未初始化时，全局变量将被初始化为 0，局部变量将不被初始化。每个类各自决定其初始化对象的方式。6、变量声明和定义的关系123extern int i; // 只声明extern int i = 1; // 声明并定义int j; // 声明并定义函数内部初始化一个由 extern 标记的变量，将引发错误。7、标识符对大小写敏感。必须以字母或下划线开头，不能数字开头。不能出现两个连续的下划线。不能下划线紧连大写字母开头。定义在函数体外的标识符不能以下划线开头。8、C++ 关键字9、C++ 操作符替代名10、名字的作用域名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。全局作用域、块作用域。作用域可嵌套，内层作用域可以重新定义外层作用域已有的名字。使用全部变量的函数不应再在内部定义同名局部变量。三、复合类型1、一条声明语句由一个基本数据类型和一个紧随其后的声明符列表组成。2、引用，有左值引用和右值引用，通常单说“引用”是指左值引用。符号为“&amp;”。出现在表达式中，&amp; 是取地址符。出现在声明中，且紧跟在 数据类型之后，&amp; 是引用符。（若出现在初始化的表示式右侧，仍是取地址符）引用即别名。引用必须被初始化，因为程序把应用和它的初始值绑定在一起，而不是拷贝，无法令应用重新绑定到另外一个对象。不能定义引用的引用，因为引用不是一个对象，只是一个别名。引用只能绑定在对象上，不能与某个常量或表达式的值绑定在一起。3、指针指针本身是一个对象，允许赋值和拷贝，且在生命周期内可以指向不同对象，可以不初始化。不能定义指向引用的指针，因为引用不是对象，没有实际地址。被指针指向的对象，可通过解引用符（*）来访问。解引用符适用于有效指针。4、空指针的生成方法1234int *p1 = nullptr; // 等价于 int *p1 = 0;int *p2 = 0; // 直接将 p2 初始化为字面常量 0// 需要包含 cstdlib 头文件int *p3 = NULL; // 等价于 int *p3 = 0;尽量用 nullptr，避免用 NULL。5、void* 指针可用于存放任意对象的地址。能进行的操作有限：与其他指针比较、作为函数的输入或输出、赋值给另一个 void* 指针。不能直接操作 void* 指针所指的对象，因为不知道所指对象的类型。6、int* p, q; 只将 p 声明为 int 型指针，而 q 是 int 型变量，因为该声明的实质是 int *p, q; 基本数据类型是 int，而非 int*。7、可以定义指向指针的引用。8、面对一条比较复杂的指针或引用的声明语句，从右向左阅读有助于弄清其真实含义。四、const 限定符1、const 对象必须初始化，且不能再做修改。默认状态下，const 对象仅在文件内有效。在其他文件中使用需声明。也可以加上 extern，并在头文件中声名。2、对 const 对象引用后，不能（通过引用）修改所绑定的对象。3、指向 const 对象的指针，不能（通过指针）改变其所指对象的值。4、* const 是 指针常量。const * 是 常量指针。从右往左看。5、顶层 const 表示指针本身是个常量。更一般的，顶层 const 可以表示任意的对象是常量，适用于任何数据类型。底层 const 表示指针所指的对象是一个常量。1const int &amp;r = ci; // 用于声明引用的 const 都是底层 const执行对象的拷贝操作时，常量是顶层 const 还是底层 const 区别明显。6、如果认定变量是一个常量表达式，可以声明成 constexpr 类型。7、常量表达式 和 constexpr 变量。8、在 constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关。1const int *p=nullptr； // p是一个指向整型常量的指针constexpr int *q=nullptr； // q是一个指向整数的常量指针五、处理类型1、两种定义类型别名的方法关键字 typedef：1typedef double wages；// wages 是 double 的同义词typedef wages base，*p；// base 是 double 的同义词，p 是 double* 的同义词别名声明（关键字 using）：1using SI = Sales_item；// SI 是 Sales_item 的同义词2、将类型别名替换成本来的样子再理解语句是错误的12typedef char *pstring；// pstring 是 char * 的别名const pstring cstr = 0；// cstr 是指向 char 的常量指针替换后：1const char *cstr = 0；// 是对 const pstring cstr 的错误理解，此处 cstr 是指向 char 型常量的指针前者 const 修饰 *，后者 const 修饰 char。3、auto 类型说明符可根据表达式的运算结果分析变量的类型，用 auto 定义的变量必须有初始值。auto 一般会忽略掉顶层 const，而保留底层 const。如果希望推断出的 auto 类型是一个顶层 const，需要明确指出。1const auto f=ci；//ci的推演类型是int，f是const int设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。4、decltype 与 auto 类似，但它值分析表达式并得到类型，却不实际计算表达式的值，也就不用表达式的值初始化变量。decltype 处理顶层 const 和引用的方式与 auto 有些许不同。如果 decltype 使用的表达式是一个变量，则 decltype 返回该变量的类型（包括顶层 const 和引用在内）：1234const int ci = 0，&amp;cj = ci；decltype（ci）x = 0；// x 的类型是 const int decltype（cj）y = x；// y 的类型是 const ints，y 绑定到变量 x decltype（cj）z；// 错误：z 是一个引用，必须初始化decltype 后不加括号，得到的是该变量的类型，如果加了括号，将被当成一个表达式。decltype（（variable））（注意是双层括号）的结果永远是引用，而decltype（variable）结果只有当variable本身就是一个引用时才是引用。六、自定义数据结构1、类内部定义的名字必须唯一，但可以与类外部定义的名字重复。类的花括号形成了一个新的作用域。2、一般不要把对象的定义和类的定义放在一起。3、string 类型是字符的序列，操作有 &gt;&gt;、&lt;&lt; 和 &#x3D;&#x3D;，代表读入、写出和比较字符串。4、类通常被定义在头文件中，且类所在头文件的名字应与类的名字一样。5、预处理变量无视 C++ 语言中关于作用域的规则。","tags":"c++ 编程语言"},{"title":"C++ 类的写法","url":"/article/9ecb7f62.html","text":"一、类的声明类的声明可以放在头文件中，如：1234567891011121314class Student&#123;public: // 成员变量 char *name; string stu_num; // 学号 int age; float score; // 成员函数 void Print_Info(); // 输出该生的信息&#125;; // 要加分号使用 class 关键字定义类。类的内部包括成员变量和成员函数。类只是一个模板（Template），编译后不占用内存，因此不能在声明或定义时对成员变量进行初始化，必须创建对象后才能赋值。根据成员的属性，可分为三类：public 公有，外部可访问pravite 私有，外部不可访问，不可在派生类中使用protected 受保护，外部不可访问，可在派生类中使用以上三种修饰符都只能修饰类成员，不能修饰类，且可以在类中多次出现，但为了直观简洁，最好每种只出现一次。在类的内部，三种类型的成员都可以互相访问，但在类的外部，只能通过对象访问 public 属性的成员。基类中的 protected 成员可以在派生类中使用。访问权限由高到低：public &gt; protected &gt; private。private 关键字的作用在于隐藏类的内部实现，不希望外部知道、只在类内使用或对外部没有影响的成员都建议声明为 private。需要对外暴露的接口都声明为 public。如果没有写 public 和 private，则默认 private。另外，类的声明和定义可以写在一起，即在声明时就定义成员函数，也可以把成员函数的定义放在类声明之外，声明中只对成员函数做声明，而不做定义。二、类的定义类的定义通常即指成员函数的定义，一般可以放在放在 .cpp 文件中。成员函数定义在类外时，必须加上 ::（域解析符，或作用域限定符），用来连接类名和函数名，指明当前函数属于哪个类。123456void Student::Print_Info()&#123; cout &lt;&lt; &quot;姓名&quot; &lt;&lt; &quot;: &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;学号&quot; &lt;&lt; &quot;: &quot; &lt;&lt; stu_num &lt;&lt; endl; cout &lt;&lt; &quot;年龄&quot; &lt;&lt; &quot;: &quot; &lt;&lt; age &lt;&lt; endl; cout &lt;&lt; &quot;成绩&quot; &lt;&lt; &quot;: &quot; &lt;&lt; score &lt;&lt; endl;&#125;即便成员函数定义在类外，也必须在类中作声明，且类的位置应在函数定义之前。若将成员函数定义在类内，则默认其位内联函数（将函数调用处用函数体替代），若想将定义在类外的成员函数变成内联函数，则在函数前加 inline 即可。三、创建对象1、对象声明&#x2F;定义类可以看做是一种数据类型，类似于 C 语言中声明了一个新的结构体类型。123class Student LiLei; // 创建单个对象Student HanMeimei; // 创建单个对象，class 可省略Student students[100]; // 创建对象数组2、访问成员对象的访问与结构体成员访问类似，使用 . 来访问：123456789101112131415int main()&#123; Student LiLei; class Student HanMeimei; Student students[100]; LiLei.name = (char*)&quot;LiLei&quot;; LiLei.stu_num = &quot;010013&quot;; LiLei.age = 23; LiLei.score = 90.5; LiLei.Print_Info(); return 0;&#125;3、使用对象指针123456// 静态分配，即指向栈中已创建的对象Student LiLei;Student *pStu = &amp;LiLei;//动态分配，即通过 new 在堆上动态创建对象Student *pStu1 = new Student; // 需匹配相应的 delete 进行回收栈中的对象都有名字，且栈内存由程序进行管理，不是必须使用指针指向它。而堆内存由程序员管理，且创建出来的对象没有名字，所以必须有指针指向它，才能进行操作。动态分配的对象使用完毕后必须用 delete 进行回收释放。通过指针访问成员：12345678Student HanMeimei;Student *pStu = &amp;HanMeimei;pStu -&gt; name = (char*)&quot;HanMeimei&quot;;pStu -&gt; stu_num = &quot;010014&quot;;pStu -&gt; age = 23;pStu -&gt; score = 91.5;pStu -&gt; Print_Info();四、类的封装实际项目开发中，成员变量以及只在类内部使用的成员函数都建议声明为 private，而只将允许通过对象调用的成员函数声明为 public。一般约定，private 的成员变量以 m_ 开头，以区别于成员函数的变量。private 的成员变量的作用域是整个类内部。则相应的可将上面的类修改为：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std;class Student&#123;public: void Set_Name(char *name); void Set_StuNum(string m_stu_num); void Set_Age(int age); void Set_Score(float score); void Print_Info(); // 输出该生的信息private: char *m_name; string m_stu_num; // 学号 int m_age; float m_score;&#125;; // 要加分号void Student::Set_Name(char *name)&#123; m_name = name;&#125;void Student::Set_StuNum(string stu_num)&#123; m_stu_num = stu_num;&#125;void Student::Set_Age(int age)&#123; m_age = age;&#125;void Student::Set_Score(float score)&#123; m_score = score;&#125;void Student::Print_Info()&#123; cout &lt;&lt; &quot;姓名&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; &quot;学号&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_stu_num &lt;&lt; endl; cout &lt;&lt; &quot;年龄&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_age &lt;&lt; endl; cout &lt;&lt; &quot;成绩&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_score &lt;&lt; endl &lt;&lt; endl;&#125;int main()&#123; Student LiLei; class Student HanMeimei; Student students[100]; Student *pStu = &amp;HanMeimei; // Student *pStu1 = new Student; // delete pStu1; LiLei.Set_Name((char*)&quot;LiLei&quot;); LiLei.Set_StuNum(&quot;010013&quot;); LiLei.Set_Age(23); LiLei.Set_Score(90.5); pStu -&gt; Set_Name((char*)&quot;HanMeimei&quot;); pStu -&gt; Set_StuNum(&quot;010014&quot;); pStu -&gt; Set_Age(23); pStu -&gt; Set_Score(91.5); LiLei.Print_Info(); pStu -&gt; Print_Info(); return 0;&#125;这里因为成员变量的属性改为了 private，不能通过对象从外部修改，因此增加了 public 属性的 set 函数来修改其值，相应的可以定义 get 函数来获取相应的成员变量值。另外也可以通过定义构造函数来初始化成员变量。五、构造函数1、构造函数可通过定义构造函数，使得类在实例化为对象时，可以通过传参来初始化。构造函数没有返回值，且必须是 public 属性的。构造函数没有返回值，也没有 return 语句，且构造函数名应与类名同名。在栈上创建对象时，实参位于对象名之后，如：1Student LiLei((char *)&quot;LiLei&quot;, &quot;010013&quot;, 23, 90.5);在堆上创建对象时，实参位于类名之后，如：1Student *pStu1 = new Student(&quot;LiHua&quot;, &quot;010015&quot;, 23, 92.5);构造函数支持重载，可以重载多个构造函数，创建对象时根据实参判断调用哪一个构造函数。一旦在类中定义了构造函数，构造函数的调用将是强制性的，创建时一定会调用，否则将是错误的。如果用户没有定义构造函数，编译器会自动生成一个默认的构造函数。如果定义了没有参数的构造函数，在创建对象时，可以不用写括号（用户不定义构造函数时即是这样调用了默认构造函数），例如，如果定义了 Student::Student();，则创建对象时，可以写成 Student stu(); 或 Student stu;。例程：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;using namespace std;class Student&#123;public: Student(char* name, string stu_num, int age, float score); Student(); void Set_Name(char *name); void Set_StuNum(string m_stu_num); void Set_Age(int age); void Set_Score(float score); void Print_Info(); // 输出该生的信息private: char *m_name; string m_stu_num; // 学号 int m_age; float m_score;&#125;; // 要加分号Student::Student(char* name, string stu_num, int age, float score)&#123; m_name = name; m_stu_num = stu_num; m_age = age; m_score = score;&#125;Student::Student()&#123; m_name = NULL; m_stu_num = &quot;NULL&quot;; m_age = 0; m_score = 0.0;&#125;void Student::Set_Name(char *name)&#123; m_name = name;&#125;void Student::Set_StuNum(string stu_num)&#123; m_stu_num = stu_num;&#125;void Student::Set_Age(int age)&#123; m_age = age;&#125;void Student::Set_Score(float score)&#123; m_score = score;&#125;void Student::Print_Info()&#123; cout &lt;&lt; &quot;姓名&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_name &lt;&lt; endl; cout &lt;&lt; &quot;学号&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_stu_num &lt;&lt; endl; cout &lt;&lt; &quot;年龄&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_age &lt;&lt; endl; cout &lt;&lt; &quot;成绩&quot; &lt;&lt; &quot;: &quot; &lt;&lt; m_score &lt;&lt; endl &lt;&lt; endl;&#125;int main()&#123; Student LiLei((char *)&quot;LiLei&quot;, &quot;010013&quot;, 23, 90.5); class Student HanMeimei((char *)&quot;HanMeimei&quot;, &quot;010014&quot;, 23, 91.5); //Student students[100]; //此处将报错，因为没有调用构造函数 Student *pStu = &amp;HanMeimei; // Student *pStu1 = new Student(&quot;LiHua&quot;, &quot;010015&quot;, 23, 92.5); // delete pStu1; LiLei.Print_Info(); pStu -&gt; Print_Info(); return 0;&#125;2、参数初始化表构造函数除了可以像正常函数一样使用函数体对成员变量一一赋值，还可以通过参数初始化表进行初始化。这种方法书写方便，效率上并无提升。例如：123Student::Student(char* name, string stu_num, int age, float score): m_name(name), m_stu_num(stu_num), m_age(age), m_score(score)&#123;&#125;参数初始化表可以用于全部成员变量，也可以只用于部分成员变量。参数初始化表的初始化顺序只与类中成员变量的顺序有关。const 成员变量只能用参数初始化表的方式来初始化。六、析构函数析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要显示调用（也无法显示调用），而是在销毁对象时自动执行。与构造函数类似，析构函数的函数名与类名相同，但要在类名前加一个 ~ 符号。析构函数没有参数，不能被重载，一个类只能有一个析构函数。如果用户不定义，编译器会自动生成一个默认析构函数。例如在构造函数中分配了堆内存：1m_array = new int[len];则在析构函数中需要释放相应的内存：1delete[] m_array;七、this 指针this 是一个 C++ 关键字，用于指向当前对象，通过它可以访问当前对象的所有成员。this 是一个 const 指针，只能用在类的内部。通常可用在成员变量与成员函数的参数重名时。用 this -&gt; 成员变量 表示该变量是成员变量，而不是函数参数。this 其实是存在对象内部的存放对象地址的 const 指针变量，所以只能用在内部，只有通过对象调用成员函数时才给 this 赋值。成员函数最终会被变异成与对象无关的普通函数，对象只保留成员变量，因此通过 this 将成员函数与成员变量进行关联。八、静态成员变量不同对象之间的相同成员变量是相互独立的，若想要不同的对象共享数据，可使用 static 定义静态成员变量。例如：1234class Student&#123;public: static string m_teacher;&#125;静态成员变量必须在类声明的外部进行初始化（放在构造函数中也不行），且必须带上数据类型，形式为：1int Student::m_teacher = &quot;Miss Wang&quot;;静态成员变量有三种访问方式：12345678910// 通过类访问Student::m_teacher = &quot;Mr Li&quot;;// 通过对象访问Student LiLei((char *)&quot;LiLei&quot;, &quot;010013&quot;, 23, 90.5);LiLei.m_teacher = &quot;Miss Zhao&quot;;// 通过对象指针访问Student *pStu = new Student(&quot;HanMeimei&quot;, &quot;010014&quot;, 23, 92.5);pStu -&gt; m_teacher = &quot;Mr Gao&quot;;static 静态成员变量不属于某个对象，而属于类，因此不占用对象内存，而在所有对象外部（内存中的全局数据区）开辟内存，不创建对象也可以访问。静态成员变量的访问需要遵循 public、private、protected 关键字的访问权限限制，如果属性设为 private，将不能在外部进行访问，只能通过成员函数访问。九、静态成员函数在类中，除了静态成员变量，还可以声明静态成员函数。静态成员函数只能访问静态成员，静态成员函数没有 this 指针，不知道指向哪个对象，可以通过类来直接调用（也可以通过对象调用）。同时，无法访问对象的（普通）成员变量和调用对象的（普通）成员函数，只能访问静态成员变量和调用静态成员函数。和静态成员变量类似，静态成员函数在声明时要加 static，在定义时不能加 static。静态成员函数的主要目的就是访问静态成员。（当然普通成员函数也可以访问静态成员，但是加上 static 意义更明确）十、类中的 const 关键字如果不希望数据被修改，可以用 const 修饰，包括成员变量、成员函数和对象。1、const 成员变量const 成员变量的初始化只能通过参数初始化表。初始化之后不能修改。2、const 成员函数const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值。const 成员函数定义和声明时都要在函数头部的结尾处加上 const 关键字，如：12345float Get_Score() const; // 声明float Student::Get_Score() const&#123; // 定义 return m_score;&#125;3、const 对象const 对象也叫常对象，常对象只能访问类的 const 成员。定义常对象时，const 关键字和类名谁前谁后都可以，通常把 const 放在前。十一、friend 友元函数和友元类通过对象可以访问 public 成员，只有本类中的函数可以访问本类的 private 成员。通过友元（friend），可以让其他类中的成员函数以及全局范围的函数访问当前类的 private 成员。友元的关系是单向的。友元的关系不能传递。一般不建议声明友元类，声明友元函数更为安全。1、友元函数在当前类以外定义的、不属于当前类的函数，也可以在本类中声名，但要在前面加 friend 关键字，以构成友元函数。友元函数可以访问当前类中的所有成员，包括 public、private、protected 属性的。调用友元函数时，不需要通过对象，直接按照普通函数的方式调用即可。友元函数不能直接访问成员，需要通过对象或对象的指针来访问。类 A 使用其他类 B 的成员函数作为友元函数的时候，需要提前声明类 A。123friend void Get_Info(Student *pStu); // 将全局函数作为友元函数friend string Student::Get_Teacher(); // 将 Student 类 的 Get_Teacher 函数作为友元函数一个函数可以被多个类声明为友元函数。2、友元类友元类中的所有成员函数都是另一个类的友元函数。友元类声明语句：1friend class Student;十二、类和结构体的区别相比较 C 语言而言，C++ 对 struct 进行了扩充，使其可以定义成员函数，因此也具备定义一个类的能力。但是在 C++ 中，最好还是使用 class 来定义类。class 的成员默认是 private 属性，struct 的成员默认是 public 属性。class 继承默认是 private 继承，struct 的继承默认是 public继承。class 可使用模板，struct 不能使用模板。","tags":"c++ 编程语言"},{"title":"C++ 数组内容初始化","url":"/article/4846392f.html","text":"使用 memset 函数需要包含或 &lt;string.h&gt; 或 &lt;memory.h&gt;原型：1memset(void *s,int ch,size_t n);void *s 传入数组名或某指针ch 传入欲初始化的内容n 传入欲初始化的地址范围（以字节为单位）用法：1memset(bucket, 0, len*sizeof(ElemType_SqList));","tags":"c++ 编程语言"},{"title":"C++ string 转换为 int","url":"/article/a47d851c.html","text":"方法一、使用 stringstream需要包含头文件。1234int val;string str = &quot;123&quot;;stringstream ss(str);ss &gt;&gt; val；方法二、未完待续。。。","tags":"c++ 编程语言"},{"title":"C++ 查看数据类型","url":"/article/5f8a6a9f.html","text":"使用 typeid() 查看数据类型使用 typeid() 需要包含头文件使用方法：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;extern const char test_set_path[] = &quot;abc&quot;;int main()&#123;int avc = 0; cout &lt;&lt; typeid(avc).name() &lt;&lt; endl; cout &lt;&lt; typeid(test_set_path).name() &lt;&lt; endl; cout &lt;&lt; typeid(int).name() &lt;&lt; endl; cout &lt;&lt; typeid(char).name() &lt;&lt; endl; cout &lt;&lt; typeid(float).name() &lt;&lt; endl; cout &lt;&lt; typeid(double).name() &lt;&lt; endl; cout &lt;&lt; typeid(char[]).name() &lt;&lt; endl; cout &lt;&lt; typeid(char[][2]).name() &lt;&lt; endl; cout &lt;&lt; typeid(int[]).name() &lt;&lt; endl; cout &lt;&lt; typeid(int[][2]).name() &lt;&lt; endl; cout &lt;&lt; typeid(char*).name() &lt;&lt; endl; cout &lt;&lt; typeid(int*).name() &lt;&lt; endl; cout &lt;&lt; typeid(typeid(char).name()).name() &lt;&lt; endl; cout &lt;&lt; typeid(typeid(int).name()).name() &lt;&lt; endl; cout &lt;&lt; typeid(string).name() &lt;&lt; endl; return 0;&#125;输出结果：123456789101112131415i A4_c i c f dA_cA_A2_cA_iA_A2_iPcPiPKcPKcSs可见，typeid().name() 的返回值类型是 PKC，即 const char*。如果只需要对类型进行对比，可以直接 if(typeid(a) == typeid(b))。","tags":"c++ 编程语言"},{"title":"C++ 文件流输入输出","url":"/article/ff1aea7f.html","text":"头文件 fstream 定义了三个类来支持文件 IO：ifstream 从一个给定文件读取数据ofstream 向一个给定文件写入数据fstream 读写给定文件一、创建对象及打开文件头文件12#include &lt;fstream&gt;using namespace std;fstream 文件使用 std 命名空间。创建文件流读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。每个文件流类都定义了一个名为 open 的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。12ifstream input(ifile); // 构造一个 ifstream 并打开给定文件ofstream output; // 输出文件流未关联任何文件对象名字可以是任意有效名称，如以上的 input、output。打开文件以下两种打开方式是等效的：1234ifstream fin(&quot;in_test.txt&quot;);ifstream fin;fin.open(&quot;in_test.txt&quot;);如果文件在其他文件夹中，可以使用绝对路径。注意绝对路径中的 ‘\\‘ 要转义替换成 ‘\\\\‘。使用 open 方法时，共可以设置三个参数：filename，mode，access。mode 即打开方式，有以下常用值：ios::app： 以追加的方式打开文件 ios::ate： 文件打开后定位到文件尾，ios:app就包含有此属性 ios::binary： 以二进制方式打开文件，缺省是文本方式 ios::in： 文件以输入方式打开(文件数据输入到内存)ios::out： 文件以输出方式打开(内存数据输出到文件) ios::nocreate： 不建立文件，所以文件不存在时打开失败 ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败 ios::trunc： 如果文件存在，把文件长度设为0access 即打开文件的属性，有以下常用值：0：普通文件，打开访问1：只读文件2：隐含文件3：系统文件关闭文件流使用 close() 方法关闭文件流。例如：12ifstream fin(&quot;in_test.txt&quot;);fin.close();二、读写文本文件读文本文件1、使用插入器（&lt;&lt;）因为 istream&#x2F;ostream 类分别是 ifstream&#x2F;ofstream 类的基类，所以可以直接使用它们的方法。例如：123ifstream fin(&quot;in_test.txt&quot;);string str;fin &gt;&gt; str;注：cin上面的代码可以读取一行数据到字符串 str 中。如果出现空格，将读取到该行的空格位置。2、使用文件流的 getline() 成员函数ifstream 也有 getline() 成员函数，有两种重载形式：12istream&amp; getline (char* s, streamsize n ); //读取最多 n 个字符保存在 s 对应的数组中，即使大小不够 nistream&amp; getline (char* s, streamsize n, char delim ); //读取最多 n 个字符保存在s对应的数组中，遇到 delim，或者读完一行，或字数达到限制则终止最多读取 n 个字符，这 n 个字符包括结束符，如果 n 是 1，将只会得到一个 ‘\\0’，而不会获取文件中的内容。字符内容只能读到 char 型数组中。遇到空格或回车将结束读取，即使还没有到达设置的数量，即此方法只能读取一个 C 语言意义上的字符串。3、使用 string 类的 getline() 成员函数getline() 是 string 类的一种成员函数，共三个参数：流对象，string 对象，终止字符。一般如果终止字符不写，默认以回车符中止，能接受字符串中的空格。123string str;ifstream input(&quot;in_test.txt&quot;);getline(input, str);需要包含头文件。写文本文件写文本文件常用析取器（&gt;&gt;），遇到空格即停止。三、读写二进制文件读二进制文件1、使用 get() 函数读字符有多种重载形式，可以读单字符，也可以读到字符串中12345ifstream &amp;get(char &amp;ch); // 将字符保存到 ch 中，遇文件尾返回空字符int get(); // 返回字符，与文件尾返回 EOFifstream &amp;get(char *buf,int num,char delim=&apos;\\n&apos;); // 将字符串保存到 buf 数组中，遇 delim 结束读取2、使用 read() 函数读数据块1read(unsigned char *buf,int num);读 num 个字符到 buf 数组中。写二进制文件1、使用 put() 函数写字符1ofstream &amp;put(char ch)；2、使用 write() 函数写数据块1write(const unsigned char *buf,int num);从 buf 指向的位置，写 num 个字符到文件中，buf 的类型是 unsigned char*。可能用到的函数可使用 streamsize gcount() 返回在对象上执行的最后一个未格式化输入操作提取的字符数。若未进行任何操作，则返回 0。若提取了一行 6 个字符，将返回 7（因为有换行符），若提取的是最后一行 6 个字符，将返回 6。可使用 bool eof() 检测是否到达文件尾。可使用 bool bad() 检测读写过程中是否发生错误。如文件未打开，或者设备无写入空间。可使用 bool fail() 检测格式错误。也能检测 bad() 包含的错误类型。可使用 bool good() 检测文件流状态。可使用 clear() 重置其他状态检测成员函数。四、文件指针移动C++ 中文件流指针分为读指针和写指针，用于改变指针位置的成员函数是 seekg() 和 seekp()。seekg() 和 seekp() 有两种重载形式：123\\\\ 指向绝对位置，通常用于文本文件，也可用于二进制文件seekg ( pos_type ab_pos );seekp ( pos_type ab_pos );123\\\\ 使用 origin+origin 实现相对位置，最好只用于二进制文件istream &amp;seekg(off_type offset,seekdir ab_pos);ostream &amp;seekp(off_type offset,seekdir ab_pos);streamoff 定义偏移量 offset 所能取得的最大值。seek_dir 表示移动的基准位置，有以下枚举值：ios::beg： 文件开头 ios::cur： 文件当前位置 ios::end： 文件结尾tellg() 和 tellp() 用于返回当前输入流或者输出流指针的位置。返回值类型是 pos_type。五、缓存同步C++ 中对流对象进行操作时，不是直接将流对象与设备（如键盘、屏幕、存储器）直接联系起来，而是通过一个 streambuf 类型的缓存将二者联系起来。将缓存中的内容输出到指定设备的过程称为同步（synchronization），同步发生在以下几种情况：遇到流中特定的控制符时，如 endl 和 flush。二者都可以用在析取器语句中，flush 还可单独作为成员函数使用。缓存区满时将自动同步。文件关闭时，缓存将同步。调用成员函数 sync()，缓存将同步。六、各种流类之间的关系basic_ios 是所有流类的基类 ios_base 的模板类。在 ios_base 的基础上派生出 ios，又在 ios 基础上派生出其他类，详见上图。","tags":"c++ 编程语言"},{"title":"统计字符串中的回文子串长度","url":"/article/80d5e508.html","text":"概念子串：字符串中连续的长度大于0的一段。回文串：若字符串的倒序与此字符串相同，则称这个字符串为回文串。思路输入输出均没有特殊格式，使用 C++ 输入输出流。分别用函数切分子串和判断是否是回文串。切分子串时使用 string 类型的 .substr() 方法。代码123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;bool IsPalindromeStr(string str) &#123; for (int i = 0; i &lt; str.size()/2; i++) &#123; if (str[i] != str[str.size()-1-i]) return false; &#125; return true;&#125;int CountPalindromeStrNum(string str) &#123; int count = 0; for (int i = 0; i&lt;str.size(); i++) &#123; for (int j = 1; j &lt; str.size()-i+1; j++) &#123; string substrs = str.substr(i, j); if (IsPalindromeStr(substrs)) count++; &#125; &#125; return count;&#125;int main()&#123;​ string input_str;​ cin &gt;&gt; input_str;​ cout &lt;&lt; CountPalindromeStrNum(input_str) &lt;&lt; endl;​ return 0;&#125;","tags":"算法 c++"},{"title":"对数复杂度的常底数不需要写具体数值的原因","url":"/article/c423c538.html","text":"设某函数的上界可以表示为 f(x) &#x3D; O(logaN)，a&gt;1 为常数。对任一常数 b&gt;1，因 lna&#x2F;lnb 为常数，则由大 O 记号的性质有：f(n) &#x3D; O(logaN) &#x3D; O(lnb&#x2F;lna * logbN) &#x3D; O(logbN)所以无论常底数更换为任意常数，都只会影响常系数，而在大 O 记号中，常系数又可忽略，因此在用大 O 记号表示对数复杂度的时候，无需写常底数。","tags":"算法"},{"title":"送给2019","url":"/article/5cb4af88.html","text":"菩提本无树明镜亦非台本来无一物何处惹尘埃","tags":"心花路放"},{"title":"递归算法","url":"/article/5f7017e8.html","text":"《数据结构（C++语言版）》（邓俊辉编著）笔记〇、概念递归 —— 允许函数和过程进行 自我调用 的一种特殊形式。递归基 —— 保证递归能够结束（有穷性）的平凡情况，可以有多种，至少有一种，且迟早必然会出现。递归基可能是隐含的。一、常用递归算法1、线性递归概念每一层次上至多只有一个实例，且构成一个线性的次序关系，称为线性递归（linear recursion）。例如：123456int sum (int A[]，int n)&#123; // 数组求和算法（线性递归版） if (1&gt;n)// 递归基 return 0; else return sum (A，n-1) + A[n-1]; // 减而治之&#125; 减而治之 （decrease-and-conquer）策略递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡的简单问题。问题划分为两个子问题：平凡的子问题规模缩减的子问题2、二分递归（多路递归）概念将一个大规模的问题划分为若干（通常两个）规模大体相当的子问题，分别求解子问题，由子问题的解，得到原问题的解。例如：12345678int sum(int A[]，int lo，int hi)&#123; // 数组求和算法(二分递归版) if(lo == hi) // 递归基 return A[lo]; else&#123; int mi = (lo+hi)&gt;&gt;1; return sum(A，lo，mi) + sum(A，mi+1，hi); // 分而治之 &#125;&#125; 分而治之 （divide-and-conquer）策略将问题分解为若干规模更小的子问题，再通过递归机制分别求解。3、多向递归（多分支递归）每一递归实例虽有多个可能的递归方向，但只能从中选择其一。各层次上的递归实例依然构成一个线性次序关系，这种情况本质上仍属于线性递归。例如：12345inline_int64 sqr(_int64 a)&#123; return a*a;&#125;int64 power2(int n)&#123; //幂函数 2^n 算法(优化递归版) if(e==n)return 1;// 递归基 return(n&amp;1) ？sqr(power2(n&gt;&gt;1))&lt;&lt;1 : sqr(power2(n&gt;&gt;1));// 多分支递归&#125;针对输入参数 n 为奇数或偶数两种可能，分别设有不同的递归方向。二、递归分析1、递归跟踪（recursion trace）将算法的执行过程整理成图的形式，可以直观的分析递归算法的运行时间与空间。2、递推方程通过对递归模式的数学归纳，导出复杂度定界函数的递推方程（组）及其边界条件，从而将复杂度的分析，转化为递归方程（组）的求解。边界条件往往可以分析递归基获得。三、递归消除递归程序往往需要较多的空间，并进而影响实际的运行速度，因此，往往应将递归算法改写成等价的非递归版本。可以借助栈来消除递归。对于单向递归和尾递归，也可利用迭代的方式进行递归消除。","tags":"算法"},{"title":"算法复杂度分析","url":"/article/f3215fef.html","text":"《数据结构（C++语言版）》（邓俊辉编著）笔记一、高效解1、常数复杂度（constant-time algorithm） O(1)运行时间可表示和度量为 T(n) &#x3D; O(1) 的算法。通常不含循环、分支、子程序调用等。仅需常数规模辅助空间的算法，称为就地算法（in-place algorithm）。2、对数复杂度（logarithmic-time algorithm） O(logn)常底数无所谓log a n &#x3D; log a b · log b n &#x3D; Θ( log b n )常数次幂无所谓log n^c &#x3D; c log n &#x3D; Θ( log n )对数多项式（ploy-log function）T( n ) &#x3D; O( (logn)^c )忽略低次项此类算法非常有效，复杂度无限接近于常数任意 c&gt;0，log n &#x3D; O( n^c )低于任何一个多项式的复杂度举例：1234567int countones(unsigned int n)&#123;//统计整数n的二进制展开中数位1的总数：0（1ogn） int ones = e； while(e&lt;n)&#123; ones += (1&amp;n)； n &gt;&gt;= 1； return ones；&#125;二、有效解1、线性复杂度（linear-time algorithm） O(n)所有 O( n ) 类算法。如迭代累加：123456int sumI(int A[]，int n)&#123; int sum = e； for(inti=e；i&lt;n；i++) sum += A[i]； return sum；&#125; //0（1）+0（n）*O（1）+0（1）=0（n+2）=0（n）`2、多项式复杂度（polynomial-time algorithm） O( polynomial(n) )O( n^c ) 类算法，低次项可忽略。多项式复杂度被视作一个具有特殊意义的复杂度级别，实际应用中一般认为是可接受的。三、难解1、指数复杂度（exponential-time algorithm） O( c^n )运行时间可以表示和度量为 T(n) &#x3D; O(a^n) 形式的算法。通常认为，指数复杂度算法无法真正应用于实际问题中，它们不是有效算法，甚至不能称作算法。四、复杂度层次典型的复杂度层次包括：O( 1 )O( log * n )O( loglogn )O( logn )O( sqrt(n) )O( n )O( nlog * n )O( nloglogn )O( nlogn )O( n^2 )O( n^3 )O( n^c )O( 2^n )五、输入规模待计算问题的输入规模，应严格定义为：用以描述输入所需的空间规模。有些情况下，以输入参数 n 本身的数值作为基准而得出的 O( logn ) 和 O( n ) 复杂度，应分别称为伪对数的（pseudo-logarithmic）和伪线性的（pseudo-linear）复杂度。例如：123456__int4 power2BF_I(int n)&#123; __int64 pow = 1； while（e&lt;n--） pow &lt;&lt;= 1; return pow；&#125;此程序如果以 n 本身数值作为基准，复杂度为 O( n )。但如果以输入参数 n 的二进制展开的宽度 r 作为输入规模，则为 O( 2^r )，这样也更为合理。","tags":"算法"},{"title":"算法复杂度度量","url":"/article/95a6f8e7.html","text":"《数据结构（C++语言版）》（邓俊辉编著）笔记一、时间复杂度在规模为 n 的所有输入中，选择执行时间最长者作为 T(n)，并以 T(n) 度量算法的时间复杂度。二、渐进复杂度1、渐进分析（asymptotic analysis）着眼长远、更为注重时间复杂度的总体变化趋势和增长速度的策略与方法。2、大 O 记号（big-O notation）若存在正的常数 c 和函数 f(n)，使得对任何 n &gt;&gt; 2 都有 T(n) ≤ c · f(n)，则可认为在 n 足够大之后，f(n) 给出了 T(n) 增长速度的一个 渐进上界。记为 T(n) &#x3D; O( f(n) )。性质：（1）对任一常数 c&gt;0，有 O( f(n) ) &#x3D; O( c · f(n) )（2）对任意常数 a&gt;b&gt;0，有 O( n^a + n^b ) &#x3D; O( n^a )以大 O 记号形式表示的时间复杂度，实质上是对算法执行时间的一种保守估计（最坏情况）。 3、大 Ω 记号若存在正的常数 c 和函数 g(n)，使得对任何 n &gt;&gt; 2 都有 T(n) ≥ c · g(n)，则可认为在 n 足够大之后，g(n) 给出了 T(n) 的一个 渐进下界。记为 T(n) &#x3D; Ω( g(n) )。 大 Ω 记号是对算法执行效率的一种乐观估计。4、大 Θ 记号若存在正的常数 c1 &lt; c2 和函数 h(n)，使得对任何 n &gt;&gt; 2 都有 c1 · h(n) ≤ T(n) ≤ c · h(n)，则可认为在 n 足够大之后，h(n) 给出了 T(n) 的一个确界。记为 T(n) &#x3D; Θ( h(n) )。大 Θ 记号是对算法复杂度的一种准确估计。三种渐进复杂度记号之间的联系与区别三、空间复杂度空间复杂度通常并不计入原始输入本身所占用的空间。其它（如转储、中转、索引、映射、缓冲等）各个方面所消耗的空间，都应计入。任一算法的任何一次运行过程汇总所消耗的存储空间，都不会多于其间所执行基本操作的累计次数。时间复杂度本身就是空间复杂度的一个天然上界。","tags":"算法"},{"title":"Altium Designer PCB 操作总结","url":"/article/3f43eab6.html","text":"1、定原点（PCB文件原点）Edit -&gt; origin2、定义尺寸（可以最开始定，也可以最后定）先画mechanical layer，再复制到 keep-out-layer（要粘贴时先点Edit-&gt;paste special），然后 Design -&gt; Board Shape -&gt; Redefine Board Shape3、测量距离ctrl+M4、 更换线型ctrl+space，用“&lt;”和“&gt;”可改变倒角曲率半径5、铺地place -&gt; polygon pour -&gt; connect to GND，选 top layer 或 bottom layer，选 pour over all same objects -&gt; 选范围 -&gt; 确定6、焊盘贴片焊盘用 top layer，过孔焊盘用multi layer7、旋转空格8、打开&#x2F;关闭层L9、切换层小键盘 *10、添加层design -&gt;layer stack manager -&gt;点击 Toplayer 或 Bottomlayer -&gt; 信号层 add layer&#x2F;内电层 add plane如果要分割，不要添加 net11、泪滴Tools -&gt; Teardoops12、铺铜皮Place -&gt; 矩形 Fill &#x2F; 多边形 Solid region13、灌铜Place -&gt; Polygon Pour（需要设置 net，也可以不设）灌铜掏空：Place -&gt; Polygon Pour Cutout14、走线换层shift + ctrl +鼠标滑轮15、原理图更新到 PCB 时出现 unknown pin删除 PCB 图中所有 net（design -&gt; netlist）16、元件换层拖住按 L17、选中需要修整的铜皮 M+G修钝角 P+Y18、PCB 图中修改丝印字体任一丝印右键 -&gt; find similar objects -&gt; text width 选 same -&gt; OK -&gt; 在 PCB inspector 中修改19、隐藏网络飞线N -&gt; Hide Connections 选 Net","tags":"软件使用"},{"title":"Altium Designer 原理图操作总结","url":"/article/a140eeab.html","text":"1、统一改 IC 标号Tools -&gt; Annotate Schematic -&gt; Reset All -&gt; UpdateChanges List2、统一改封装器件右键 -&gt; Find Similar Objects -&gt; Description 选 same -&gt; Symbol Reference 选 same -&gt; OK -&gt; CTRL + A -&gt; 改 current footprint -&gt; 左击菜单外的工作台改完之后因为过滤器其他器件为灰色，此时在工作台任意位置右键，点 Filter，clear filter3、导出 BOM需要将每一个器件的 comment 改成对应的阻值容值，template 选 BOM Default Template 95.xlt，最后点 Export","tags":"软件使用"},{"title":"Cadence Allegro 操作总结","url":"/article/d5da8179.html","text":"1、查看快捷键命令行输入alias2、显示丝印菜单栏 color192（四个方块）-&gt; component -&gt; silkscreen打钩3、关闭和显示网络飞线Display -&gt; Show Rats -&gt; All -&gt; 即可打开显示所有的网络飞线（未布线的网络）Display -&gt; Blank Rats -&gt; All -&gt; 关闭隐藏所有的网络飞线","tags":"软件使用"},{"title":"Win7 下 Cadence Capture 窗口最小化无法打开问题解决办法","url":"/article/d0c66c85.html","text":"问题描述打开 Capture 时，软件一直最小化到下方任务栏，点击后无反应。解决办法方法一：直接删除 capture.ini方法二：先关闭软件。打开 capture.ini，找到 [Window Placement] 配置选项，将窗口大小改为默认大小。[Window Placement]Max Position…&#x3D;(-1,-1)Min Position…&#x3D;(-32000,-32000)Normal Position&#x3D;(138,105,1176,877)Show………..&#x3D;ShowNormal","tags":"软件使用"},{"title":"Cadence Capture 加页码的方法","url":"/article/d55e31d2.html","text":"1、 选中 .dsn 文件（工程文件）2、执行 tools 菜单里的 Annotate 命令3、在弹出的 Annotate 对话框中选择 Packaging 页4、在 action 栏选择 Add Intersheet References5、点击 “确定” 按钮进入 Intersheet References 对话框，勾选第一项：Place on off page connectors注意，在 title block 里面一定要有正确的页码，比如 1 of 8， 2 of 8 等等，这个是打页码的依据。添加 title block的方法： place -&gt; title block。如果要删除 off page connector 的页面编号，在 Annotate 对话框中，选择 Delete Intersheet References 即可删除。","tags":"软件使用"},{"title":"Cadence Capture 操作总结","url":"/article/3922d180.html","text":"1、放置跨页符Place -&gt; Off-Page Connector2、更改颜色、字体等偏好option -&gt; preferences3、生成PDFfile -&gt; Print Setup -&gt; 名称选择 Adobe PDF（或其他软件） -&gt; file -&gt; Print -&gt; OK 后选路径即可4、创建原理图文件夹 —— 选择原理图文件夹 -&gt; 选design -&gt; new schematic创建原理图文件 —— 选择原理图文件夹 -&gt; 选design -&gt; new schematic page5、重命名原理图：在页面主菜单 design -&gt; rename，或 dsn 下右键 -&gt; rename工程文件 opj：只能在 windows 下重命名设计文件 dsn：不要再 window 下重命名，这样明明后，工程文件就找不到数据库了，应该 file -&gt; save as。6、创建元件库file -&gt; new -&gt; library选中新建的库文件，右键 -&gt; new part，弹出对话框输入 name 和 rart reference prefix（U、R、C等），封装可以先空着。如果分几部分建立，part per pkg 填相应数量添加引脚：选中 -&gt; place -&gt; pin array改引脚名称：双击改名即可，如果需要加横线表示低有效，在每个字母后面加 “\\”统一改引脚名称：edit-propertiesoption -&gt; package properties可以编辑该 package 的 footprint，名称，索引符号，分裂元件数量创建分裂元件在 parts per pkg 中选择分裂数量即可，若相似的几部分，选 homogeneous，若不同，选 heterogeneous电源只放在一个部分即可，不需要每个部分都放，如运放CTRL+N 切换不同部分7、开启&#x2F;关闭引脚名称显示option -&gt; part properties8、取消格点吸附工具栏快捷键 snap to grid 可以取消&#x2F;开启吸附栅格点。9、画斜线拉线时按住 shift10、Capture 自带 Library 路径：cadence–spb_16.3 – tools – capture – library11、总线总线命名不能以空格或数字结束。总线命名有3种规则：BUSNAME[0..31]或BUSNAME[0:31]或BUSNAME[0-31]。wire命名时不能带[ ]。直接BUSNAME0、BUSNAME1等。如果不用总线入口，而把wire线直接连到总线上，在连接处也有连接点，但并没有真正的电气连接。如果使用总线入口，总线必须通过bus entry和信号线实现互连。并且总线和信号线都要命名，并符合命名规范。如果不用总线入口，总线和wire信号线之间只能通过网络名称实现电气互连。两段总线如果形成T型连接，则自动放置连接点，电气上是互连的。两段十字型的总线默认没有连接点，要形成电气互连，必须手动放置连接点。12、器件重新编号选择工程文件 -&gt; tools -&gt; Annotate -&gt; (Action)Reset to ? -&gt; 确定 -&gt;tools -&gt; Annotate -&gt; incremental reference update13、鼠标变成长十字快捷键按 F614、查看所有器件、网络schematic 上右键 -&gt; Edit object properties15、字母上加横线命名时字母后加反斜杠16、建封装时从 excel 批量复制Shift + Insert17、编辑器件 Pin Groupview -&gt; package -&gt; edit -&gt; properties18、新建 symbol 库file -&gt; new library -&gt; olb 右键 new symbol，可新建 power、跨页符、标题栏、pin shape、端口标示19、快速新建封装file -&gt; new library -&gt; olb 右键 new part from spreadsheet重新修改右键 split part20、插入可编辑的 visio 图形Place -&gt; OleObject选择 由文件创建点击浏览，选择 visio 文件后点确定在原理图中画方框（方框后期也可以随意拖动和调整大小）21、元件不能删除和移动右键该器件，选 edit part，然后退出即可","tags":"软件使用"},{"title":"ARM CMSIS-DSP 库简介","url":"/article/5d8cceea.html","text":"CMSIS 的 DSP 库主要提供以下数字信号处理算法：1、BasicMathFunctions提供基本的数据运算，如加减乘除，以 _f32 结尾的函数是浮点运算，以 _q8，_q15，_q31 结尾的函数是定点运算。2、FastMathFunctions主要提供 SIN，COS 以及平方根 SPRT 的运算。3、ComplexMathFunctions复杂数学运算，主要是向量，求模等运算。4、FilteringFunctions主要是滤波函数，如 IIR，FIR，LMS 等。5、MatrixFunctions主要是矩阵运算。6、TransformFunctions变换功能。包括复数 FFT（CFFT）&#x2F;负数 FFT 逆运算（CIFFT）、实数 FFT（RFFT）&#x2F;实数 FFT 逆运算。7、ControllerFunctions控制功能，主要为 PID 控制函数。arm_sin_cos_f32&#x2F;_q31.c 函数提供 360 点正余弦函数表和任意角度的正余弦函数值计算功能。8、StatisticsFunctions统计功能函数，如求平均值、计算 RMS 等。9、SupportFunctions支持功能函数，如数据拷贝，Q 格式和浮点格式相互转换。10、CommonTablesarm_common_tables.c 文件提供位翻转或相关参数表。","tags":"硬件拾忆 stm32"},{"title":"STM32 通用定时器","url":"/article/f7e075a6.html","text":"一、stm32 定时器简介高级定时器 TIM1 TIM8通用定时器 TIM2~TIM5基本定时器 TIM6 TIM7二、通用定时器通用定时器通过一个可编程预分频器驱动的 16 位自动装在计数器构成。它使用于多种场合，包括测量输入信号的脉冲长度（输入捕获）或者产生输出波形（输出比较和 PWM）。使用定时器预分频器和 RCC 时钟控制器预分频器，脉冲长度和波形周期可以在几个微秒到几个毫秒间调整。每个定时器完全独立，没有共享任何资源，可同步操作。通用定时器的功能包括：1）16 位向上、向下、向上&#x2F;向下自动装载计数器（TIMx_CNT）2）16 位可编程（可实时修改）预分频器（TIMx_PSC），计数器时钟频率的分频系数为 1~65535 之间的任意数值。3）4 个独立通道（TIMxCH1~4），这些通道可以用来作为：​ A. 输入捕获​ B. 输出比较​ C. PWM 生成（边缘或中间对齐模式）​ D. 单脉冲模式输出4）可使用外部信号（TIMx_ETR）控制定时器和定时器互连（可以用1个定时器控制另外一个定时器）的同步电路。5）如下事件发生时产生中断&#x2F;DMA更新：计数器向上溢出&#x2F;向下溢出，计数器初始化（通过软件或者内&#x2F;外部触发）触发事件（计数器启动、停止、初始化或者由内&#x2F;外部触发计数）输入捕获输出比较6）支持针对定位的增量（正交）编码器和霍尔传感器电路7）触发输入作为外部时钟或者按周期的电流管理三、通用定时器使用步骤：1）TIMx 时钟使能因为 Stm32_Clock_Init() 函数里把 APB1 的分频设置为 2，所以 TIM3 时钟是 APB1 时钟的 2 倍，等于 72M。2）设置 TIM3_ARR 和 TIM3_PSC 的值3）设置 TIM3_DIER 允许更新中断4）允许 TIM3 工作5）TIM3 中断分组6）编写中断服务函数","tags":"硬件拾忆 stm32"},{"title":"STM32 外部中断","url":"/article/71b6b9a8.html","text":"STM32 的每个 IO 口都可以作为中断输入，但每一个中断线只能分配到某一个 IO 口的相应管脚，如中断 2 只能分配到 PA2 或 PB2 或 PC2 等其中的一个。把 IO 口作为外部中断输入的步骤：1、初始化 IO 为输入可以上拉，下拉，或浮空输入。浮空的时候外部一定要上拉或下拉，否则中断可能不停触发。干扰打的地方，就算使用了内部上&#x2F;下拉，最好外部再上&#x2F;下拉一下，一定程度上防止外部干扰。2、开启 IO 口复用时钟，设置 IO 口与中断线的映射关系IO 口复用时钟在 RCC-&gt;APB2ENR 处使能（AFIOEN），在 AFIO-&gt;EXTICR 处将 EXTI.BITx 映射到 GPIO.BITx。3、开启与该 IO 口相对的线上中断&#x2F;事件，设置触发条件从 EXTI-&gt;IMR 处开启中断请求，从 EXTI-&gt;EMR 处开启事件请求，从 EXTI-&gt;FTSR（下降沿）和 RTSR（上升沿）设置触发条件。触发条件只能是上升沿或下降沿。不配置 EMR 位，软硬件仿真都可以进入外部中断，配置以后，软件仿真不能进入外部中断。4、配置中断分组（NVIC），并使能中断从 SCB-&gt;AIRCR[10:8] 配置中断分组，从 NVIC-&gt;ISER 使能外部中断，从 NVIC-&gt;IP 设置优先级。见 PM0056。5、编写中断服务函数0~4 有各自的 ISR：void EXTI0_IRQHandler(void)9~5 共用 ISR：void EXTI9_5_IRQHandler(void)15~10 共用 ISR：void EXTI15_10_IRQHandler(void)","tags":"硬件拾忆 stm32"},{"title":"STM32 程序编译","url":"/article/4c207401.html","text":"Code：表示程序所占用 FLASH 的大小（FLASH）RO-data：Read Only-data，表示程序定义的常量（FLASH）RW-data：Read Write-data，表示已被初始化的变量（SRAM）ZI-data：Zero Init-data，表示未被初始化的变量（SRAM）程序的大小不是 .hex 文件的大小，而是编译后 Code 和 RO-data 之和。在 startup_stm32f10x_hd.s 里面，定义了堆栈（Heap+Stack）大小为 0x600，也就是 1536 字节，usart.c 里定义了 200 字节大小的接收缓冲，共占用 1736 字节的 SRAM。","tags":"硬件拾忆 stm32"},{"title":"STM32 中断","url":"/article/bc8a78ec.html","text":"一、CM3 内核​CM3 内核支持 256 个中断，其中前 16 个为内核中断，另外 240 个为外部中断，具有 256 级的可编程中断设置。二、stm32f1stm32 有 84 个中断，包括 16 个内核中断和 68 个可屏蔽中断，具有 16 级可编程的中断优先级。f103 上只有 60 个中断，互联型如 f107 才有 68 个。stm32f103 支持 19 个外部中断：线 0~15：对应外部 IO 的输入中断线 16：连接到 PVD 输出线 17：连接到 RTC 闹钟事件线 18：连接到 USB 唤醒事件三、相关寄存器向量中断控制器，简称 NVIC。访问地址 0xe000e000。ISER（8 个，用 3 个）Interrupt Set-Enable Registers中断使能。写 0 无效。​ICER（8 个，用 3 个）Interrupt Clear-Enable Registers清除使能。写 0 无效。ISPR（8 个，用 3 个）Interrupt Set-Pending Registers中断挂起，执行更高级中断。写 0 无效。ICPR（8个，用 3 个）Interrupt Clear-Pending Registers挂起解除。写 0 无效。IABR（8 个，用 3 个）Interrupt Active Bit Register中断活动标志，指示正在被执行的中断，硬件清零，只读。在处理器执行了某一种中断的 ISR 的第一条指令后，它的活动位就置 1，直到 ISR 返回时才硬件清零。即使该中断被抢占，其活动状态依然为 1。IP（240 个，用 68 个，高 4 位有效）Interrupt Priority RegisterSTIR具体信息见 PM0056 STM32 内核编程手册SCB-&gt;AIRCR 设置分组共 5 组，0 表示 0 位抢占优先级，4 表示 4 位抢占优先级软件中断最简单的方法是用 SETPEND 寄存器。更专业快捷的方法是用 STIR 寄存器四、外部中断IMR（中断屏蔽寄存器）EMR（事件屏蔽寄存器）RTSR（上升沿触发选择寄存器）FTSR（下降沿触发选择寄存器 ）SWIER（软件中断时间寄存器）PR（挂起寄存器）​ 写1清除该位五、中断编号（f103）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&#123;/****** Cortex-M3 Processor Exceptions Numbers ***************************************************/ NonMaskableInt_IRQn = -14, /*!&lt; 2 Non Maskable Interrupt */ MemoryManagement_IRQn = -12, /*!&lt; 4 Cortex-M3 Memory Management Interrupt */ BusFault_IRQn = -11, /*!&lt; 5 Cortex-M3 Bus Fault Interrupt */ UsageFault_IRQn = -10, /*!&lt; 6 Cortex-M3 Usage Fault Interrupt */ SVCall_IRQn = -5, /*!&lt; 11 Cortex-M3 SV Call Interrupt */ DebugMonitor_IRQn = -4, /*!&lt; 12 Cortex-M3 Debug Monitor Interrupt */ PendSV_IRQn = -2, /*!&lt; 14 Cortex-M3 Pend SV Interrupt */ SysTick_IRQn = -1, /*!&lt; 15 Cortex-M3 System Tick Interrupt *//****** STM32 specific Interrupt Numbers *********************************************************/ WWDG_IRQn = 0, /*!&lt; Window WatchDog Interrupt */ PVD_IRQn = 1, /*!&lt; PVD through EXTI Line detection Interrupt */ TAMPER_IRQn = 2, /*!&lt; Tamper Interrupt */ RTC_IRQn = 3, /*!&lt; RTC global Interrupt */ FLASH_IRQn = 4, /*!&lt; FLASH global Interrupt */ RCC_IRQn = 5, /*!&lt; RCC global Interrupt */ EXTI0_IRQn = 6, /*!&lt; EXTI Line0 Interrupt */ EXTI1_IRQn = 7, /*!&lt; EXTI Line1 Interrupt */ EXTI2_IRQn = 8, /*!&lt; EXTI Line2 Interrupt */ EXTI3_IRQn = 9, /*!&lt; EXTI Line3 Interrupt */ EXTI4_IRQn = 10, /*!&lt; EXTI Line4 Interrupt */ DMA1_Channel1_IRQn = 11, /*!&lt; DMA1 Channel 1 global Interrupt */ DMA1_Channel2_IRQn = 12, /*!&lt; DMA1 Channel 2 global Interrupt */ DMA1_Channel3_IRQn = 13, /*!&lt; DMA1 Channel 3 global Interrupt */ DMA1_Channel4_IRQn = 14, /*!&lt; DMA1 Channel 4 global Interrupt */ DMA1_Channel5_IRQn = 15, /*!&lt; DMA1 Channel 5 global Interrupt */ DMA1_Channel6_IRQn = 16, /*!&lt; DMA1 Channel 6 global Interrupt */ DMA1_Channel7_IRQn = 17, /*!&lt; DMA1 Channel 7 global Interrupt ADC1_2_IRQn = 18, /*!&lt; ADC1 and ADC2 global Interrupt */ USB_HP_CAN1_TX_IRQn = 19, /*!&lt; USB Device High Priority or CAN1 TX Interrupts */ USB_LP_CAN1_RX0_IRQn = 20, /*!&lt; USB Device Low Priority or CAN1 RX0 Interrupts */ CAN1_RX1_IRQn = 21, /*!&lt; CAN1 RX1 Interrupt */ CAN1_SCE_IRQn = 22, /*!&lt; CAN1 SCE Interrupt */ EXTI9_5_IRQn = 23, /*!&lt; External Line[9:5] Interrupts */ TIM1_BRK_IRQn = 24, /*!&lt; TIM1 Break Interrupt */ TIM1_UP_IRQn = 25, /*!&lt; TIM1 Update Interrupt */ TIM1_TRG_COM_IRQn = 26, /*!&lt; TIM1 Trigger and Commutation Interrupt */ TIM1_CC_IRQn = 27, /*!&lt; TIM1 Capture Compare Interrupt */ TIM2_IRQn = 28, /*!&lt; TIM2 global Interrupt */ TIM3_IRQn = 29, /*!&lt; TIM3 global Interrupt */ TIM4_IRQn = 30, /*!&lt; TIM4 global Interrupt */ I2C1_EV_IRQn = 31, /*!&lt; I2C1 Event Interrupt */ I2C1_ER_IRQn = 32, /*!&lt; I2C1 Error Interrupt */ I2C2_EV_IRQn = 33, /*!&lt; I2C2 Event Interrupt */ I2C2_ER_IRQn = 34, /*!&lt; I2C2 Error Interrupt */ SPI1_IRQn = 35, /*!&lt; SPI1 global Interrupt */ SPI2_IRQn = 36, /*!&lt; SPI2 global Interrupt */ USART1_IRQn = 37, /*!&lt; USART1 global Interrupt */ USART2_IRQn = 38, /*!&lt; USART2 global Interrupt */ USART3_IRQn = 39, /*!&lt; USART3 global Interrupt */ EXTI15_10_IRQn = 40, /*!&lt; External Line[15:10] Interrupts */ RTCAlarm_IRQn = 41, /*!&lt; RTC Alarm through EXTI Line Interrupt */ USBWakeUp_IRQn = 42, /*!&lt; USB Device WakeUp from suspend through EXTI Line Interrupt */ TIM8_BRK_IRQn = 43, /*!&lt; TIM8 Break Interrupt */ TIM8_UP_IRQn = 44, /*!&lt; TIM8 Update Interrupt */ TIM8_TRG_COM_IRQn = 45, /*!&lt; TIM8 Trigger and Commutation Interrupt */ TIM8_CC_IRQn = 46, /*!&lt; TIM8 Capture Compare Interrupt */ ADC3_IRQn = 47, /*!&lt; ADC3 global Interrupt */ FSMC_IRQn = 48, /*!&lt; FSMC global Interrupt */ SDIO_IRQn = 49, /*!&lt; SDIO global Interrupt */ TIM5_IRQn = 50, /*!&lt; TIM5 global Interrupt */ SPI3_IRQn = 51, /*!&lt; SPI3 global Interrupt */ UART4_IRQn = 52, /*!&lt; UART4 global Interrupt */ UART5_IRQn = 53, /*!&lt; UART5 global Interrupt */ TIM6_IRQn = 54, /*!&lt; TIM6 global Interrupt */ TIM7_IRQn = 55, /*!&lt; TIM7 global Interrupt */ DMA2_Channel1_IRQn = 56, /*!&lt; DMA2 Channel 1 global Interrupt */ DMA2_Channel2_IRQn = 57, /*!&lt; DMA2 Channel 2 global Interrupt */ DMA2_Channel3_IRQn = 58, /*!&lt; DMA2 Channel 3 global Interrupt */ DMA2_Channel4_5_IRQn = 59 /*!&lt; DMA2 Channel 4 and Channel 5 global Interrupt &#125;","tags":"硬件拾忆 stm32"},{"title":"STM32 IO操作","url":"/article/7971e1ca.html","text":"一、位带操作SRAM 和片内外设区的最低 1MB 范围都支持位带操作。每一 bit 都有自己的 32 位“位带别名区”，可以用来访问原始 bit。SRAM 中最低 1MB ：0x2000 0000 - 0x200f ffff片内外设中最低 1MB：0x4000 0000 - 0x100f ffff​当一个别名地址被访问时，会先把该地址变换成位带地址。位带区的每个比特都映射到别名地址区的一个 LSB 有效的字。对于读操作，读取位带地址中的一个字，再把需要的位右移到 LSB，并把 LSB 返回。对于写操作，把需要写的位左移至对应的位序号处，然后执行一个原子的“读-改-写”过程。对于 SRAM 位带区的某个比特，记它所在字节地址为 A，位序号为 n（0&lt;&#x3D;n&lt;&#x3D;7），则该比特在别名区的地址为：AliasAddr &#x3D; 0x22000000+((A-0x20000000)*8+n)*4 &#x3D; 0x22000000+(A-0x20000000)32+n4对于片上外设位带区的某个比特，记它所在字节的地址为 A，位序号为 n（0&lt;&#x3D;n&lt;&#x3D;7），则该比特在别名区的地址为：AliasAddr &#x3D; 0x42000000+((A-0x40000000)*8+n)*4 &#x3D; 0x42000000+(A-0x40000000)32+n4c 语言代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//位带操作,实现 51 类似的 GPIO 控制功能//具体实现思想,参考&lt;&lt;CM3权威指南&gt;&gt;第五章(87页~92页).//IO口操作宏定义#define BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x2000000+((addr &amp;0xFFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))#define MEM_ADDR(addr) *((volatile unsigned long *)(addr))#define BIT_ADDR(addr, bitnum) MEM_ADDR(BITBAND(addr, bitnum))//IO口地址映射#define GPIOA_ODR_Addr (GPIOA_BASE+12) //0x4001080C#define GPIOB_ODR_Addr (GPIOB_BASE+12) //0x40010C0C#define GPIOC_ODR_Addr (GPIOC_BASE+12) //0x4001100C#define GPIOD_ODR_Addr (GPIOD_BASE+12) //0x4001140C#define GPIOE_ODR_Addr (GPIOE_BASE+12) //0x4001180C#define GPIOF_ODR_Addr (GPIOF_BASE+12) //0x40011A0C #define GPIOG_ODR_Addr (GPIOG_BASE+12) //0x40011E0C #define GPIOA_IDR_Addr (GPIOA_BASE+8) //0x40010808#define GPIOB_IDR_Addr (GPIOB_BASE+8) //0x40010C08#define GPIOC_IDR_Addr (GPIOC_BASE+8) //0x40011008#define GPIOD_IDR_Addr (GPIOD_BASE+8) //0x40011408#define GPIOE_IDR_Addr (GPIOE_BASE+8) //0x40011808#define GPIOF_IDR_Addr (GPIOF_BASE+8) //0x40011A08#define GPIOG_IDR_Addr (GPIOG_BASE+8) //0x40011E08//IO 口操作，只对单一的 IO 口//确保 n 的值小于16#define PAout(n) BIT_ADDR(GPIOA_ODR_Addr,n) //输出#define PAin(n) BIT_ADDR(GPIOA_IDR_Addr,n) //输入#define PBout(n) BIT_ADDR(GPIOB_ODR_Addr,n) //输出#define PBin(n) BIT_ADDR(GPIOB_IDR_Addr,n) //输入#define PCout(n) BIT_ADDR(GPIOC_ODR_Addr,n) //输出#define PCin(n) BIT_ADDR(GPIOC_IDR_Addr,n) //输入#define PDout(n) BIT_ADDR(GPIOD_ODR_Addr,n) //输出#define PDin(n) BIT_ADDR(GPIOD_IDR_Addr,n) //输入#define PEout(n) BIT_ADDR(GPIOE_ODR_Addr,n) //输出#define PEin(n) BIT_ADDR(GPIOE_IDR_Addr,n) //输入#define PFout(n) BIT_ADDR(GPIOF_ODR_Addr,n) //输出#define PFin(n) BIT_ADDR(GPIOF_IDR_Addr,n) //输入#define PGout(n) BIT_ADDR(GPIOG_ODR_Addr,n) //输出#define PGin(n) BIT_ADDR(GPIOG_IDR_Addr,n) //输入二、IO 口模式1、输入浮空2、输入上拉3、输入下拉4、模拟输入5、开漏输出6、推挽输出7、推挽式复用功能8、开漏复用功能每个 IO 口有 7 个寄存器：配置模式的 2 个 32 位端口配置寄存器 CRL 和 CRH2 个 32 位数据寄存器 IDR 和 ODR1 个 32 位的置位&#x2F;复位寄存器 BSRR1 个 16 位的复位寄存器 BRR1 个 32 位的锁存寄存器 LCKRCRL 和 CRH每个 IO 口占 4 位，高 2 位为 CNF，低 2 位为 MODE。0x0 表示模拟输入（ADC 用）0x4 表示浮空输入0x8 表示上下拉模式（输入口）PxODR&#x3D;0下拉；&#x3D;1上拉0x3 表示推挽输出（输出口，50M速率）（0x2-2M、0x1-10M）0x7 表示开漏输出（0x6-2M 、0x5-10M ）0xb 表示复用推挽输出（IO口第二功能，50M速率 ）（0xa-2M 、0x9-10M ）0xf 表示复用开漏输出（IO口第二功能，50M速率 ）（0xe-2M 、0xd-10M ）IDR 和 ODR​只用了低 16 位。IDR 为只读，ODR 为读写。","tags":"硬件拾忆 stm32"},{"title":"STM32 F(S)MC 总线","url":"/article/c21dfbe4.html","text":"CPU 内置灵活的静态存储器控制器（FSMC），可以外扩总线型的存储器（如SRAM、NOR Flash）。FSMC 的英文全称为“Flexible static memory controller”。所有的外部存储器共享控制器输出的地址、数据和控制信号，每个外部设备可以通过一个唯一的片选信号加以区分。FSMC 在任一时刻只访问一个外部设备。注意： 上图中的有些信号是多个信号引到同一个 CPU 管脚。比如 FSMC_NCE4_1 和 FSMC_NE3同时引到了 PG10 管脚。软件可配置 GPIO 和 FSMC 相关的寄存器进行选择。从 FSMC 的角度看，可以把外部存储器划分为固定大小为 256M 字节的四个存储块（BLOCK），见下图。存储块 1 用于访问最多 4 个 NOR 闪存或 SRAM 存储设备。这个存储区被划分为 4 个 BANK 并有 4 个专用的片选 FSMC_NE[4:1]。 CPU 的数据手册将这个区命名为 NOR&#x2F;PSRAM 区，其中 NOR 指 NOR Flash；PSRAM 指伪 SRAM，即接口封装为 SRAM 形式的动态 RAM（DRAM）。其实，这个区也可以直接用于 SRAM。存储块 2 和 3 用于访问 NAND 闪存设备，每个存储块连接一个 NAND 闪存。存储块 4 用于访问 PC 卡设备 每一个存储块上的存储器类型是由用户在配置寄存器中定义的。HADDR 是需要转换到外部存储器的内部 AHB 地址线。HADDR[25:0] 已连接到 CPU 口线，对应 FSMC_A[25:0]。HADDR[27:26] 仅在 CPU 内部使用，没有连接到 CPU 口线。HADDR[27:26] 位用于选择四个存储块之一：HADDR 是字节地址，而存储器访问不都是按字节访问，因此接到存储器的地址线依存储器的数据宽度有所不同，如下表：在同一时刻，CPU 只能访问一个外部总线设备（SRAM、NOR Flash、NAND Flash、LCD）。外部总线设备间的协调就靠 CS 片选信号进行的，也就是同一时刻，只有一个外设的片选信号为低。除了片选信号外，其它的地址线、数据线、控制线都是共用的。当 SRAM 的片选为高电平时，也就是不被选中时，SRAM 的数据线 I&#x2F;O15~I&#x2F;O0 呈高阻状态，这样就不会影响其它总线设备的通信。","tags":"硬件拾忆 stm32"},{"title":"STM32 时钟树总结","url":"/article/19efc0ad.html","text":"一、时钟源1、物理时钟源看到好多地方都说 STM32F1 有五个时钟源 HSE、HSI、LSI、LSE 和 PLL，但是我觉得 PLL 严格来讲不算一个时钟源，它是在基本的物理时钟上倍频得到的，因此我把 HSE、HSI、LSI、LSE 归结为 STM32F1 的四个基本物理时钟源。STM32F1xx 有 4 个物理时钟源：HSE（High Speed External clock signal）4-16MHzHSI（High Speed Internal clock signal） 8MHzLSI（Low Speed Internal clock signal） 40kHz 驱动独立看门狗 IWDG 和 AWULSE（Low Speed External clock signal）32.768kHz 驱动RTC其中 HSE 和 HSI 可经 PLL 倍频得到 PLL 高频时钟源（最大 72M）。（1）高速外部时钟信号（HSE）​ 由以下两种时钟源产生：· HSE 外部晶体&#x2F;陶瓷谐振器· HSE 用户外部时钟外部时钟源（HSE旁路）在这个模式里，必须提供外部时钟。它的频率最高可达 25MHz。用户可通过设置在控制寄存器中的 HSEBYP 和 HSEON 位来选择这一模式。外部时钟信号（50% 占空比的方波、正弦波或三角波）必须连到 OSC_IN 引脚，同时保证 OSC_OUT 引脚悬空，如上图。外部晶体&#x2F;陶瓷谐振器（HSE晶体）4~16MHz 外部振荡器可为系统提供更为精确的主时钟。相关的硬件配置参考上图（关于晶体&#x2F;陶瓷谐振器的原理，或者遇到晶振不起振的问题，可以参考下皮尔斯振荡器）。为了减少时钟输出的失真和缩短启动稳定时间，晶体&#x2F;陶瓷谐振器和负载电容器必须尽可能地靠近振荡器引脚。负载电容值必须根据所选择的振荡器来选择。时钟控制寄存器 RCC_CR 中的 HSERDY 位用来指示高速外部振荡器是否稳定。在启动时，知道这一位被硬件置“1”,时钟才被释放。如果在时钟中断寄存器 RCCC_CIR 中允许产生中断，将会产生相应中断。HSE 晶体可以通过设置时钟控制寄存器里 RCC_CR 中的 HSEON 位被启动和关闭。（2）高速内部时钟信号（HSI）HSI 时钟信号由内部 8MHz 的 RC 振荡器产生，可直接作为系统时钟或在 2 分频后作为 PLL 输入（此时最大 64M）。HSI RC 振荡器能在不需要任何外部器件的条件下提供系统时钟。它的启动时间比 HSE 晶体振荡器短。然而，即使在校准之后它的时钟频率精度仍较差。​HSI 校准：制造工艺决定了不同芯片的 RC 振荡器频率会不同，这就是为什么每个芯片的 HSI 时钟频率在出厂前已经被 ST 校准到 1%（25℃）的原因。系统复位时，工厂校准值被装在到时钟控制器的 HSICAL[7:0] 位。如果用户的应用基于不同的电压或环境温度，这将会影响 RC 振荡器的精度。可以通过时钟控制寄存器里的 HSITRIM[4:0] 位来调整 HSI 频率。时钟控制寄存器中的 HSIRDY 位用来指示 HSI RC 振荡器是否稳定。在时钟启动过程中，知道这一位被硬件置“1”,HSI RC 输出时钟才被释放。HSI RC 可由时钟控制寄存器中的 HSION 位来启动和关闭。如果 HSE 晶体振荡器失效，HSI 时钟会被作为备用时钟源。​（3）低速外部时钟信号（LSE）LSE 晶体是一个 32.768kHz 的低速外部晶体或陶瓷谐振器。它为实时时钟或其他定时功能提供一个低功耗且精确的时钟源。LSE 晶体通过在备份域控制寄存器（RCC_BDCR）里的 LSEON 位启动和关闭。在备份域控制寄存器（RCC_BDCR ）里的 LSERDY 指示 LSE 晶体振荡是否稳定。在启动阶段，知道这个位被硬件置 1 后，LSE 时钟信号才被释放出来。如果在时钟中断寄存器里被允许，可产生中断申请。外部时钟源（LSE旁路）在这个模式里必须提供一个 32.768kHz 频率的外部时钟源。可以通过设置在备份域控制寄存器（RCC_BDCR）里的 LSEBYP 和 LSEON 位来选择这个模式。具有 50% 占空比的外部时钟信号（方波、正弦波或三角波）必须连到 OSC32_IN 引脚，同时保证 OSC32_OUT 引脚悬空。​（4）低速内部时钟信号（LSI）LSI RC 担当一个低功耗时钟源的角色，它可以在停机和待机模式下保持运行，为独立看门狗和自动唤醒单元提供时钟。LSI 时钟频率大约 40kHz（在 30kHz 到 60kHz 之间）。LSI RC 可以通过控制&#x2F;状态寄存器（RCC_CSR）里的 LSION 位来启动或关闭。在控制&#x2F;状态寄存器（RCC&#x2F;CSR）里的 LSIRDY 位指示低速内部振荡器是否稳定。在启动阶段，知道这个位被硬件置 1 后，此时钟才被释放。如果在时钟中断寄存器（RCC_CIR）里被允许，将产生 LSI 中断申请。LSI 校准：（只有大容量和互联型产品可以进行 LSI 校准）可以通过校准内部低速振荡器 LSI 来补偿其频率便宜，从而获得精度可接受的 RTC 时间基数，以及独立看门狗 IWDG 的超时时间（当这些外设以 LSI 为时钟源）。校准可以通过使用 TIM5 的输入时钟（TIM5_CLK）测量 LSI 时钟频率实现。测量以 HSE 的精度为保证，软件可以通过调整 RTC 的 20 位预分频器来获得精确的 RTC 时钟基数，以及通过计算得到精确的独立看门狗 IWDG 的超时时间。LSI 校准步骤如下：打开 TIM5，设置通道 4 为输入捕获模式；设置 AIFO_MAPR 的 TIM5_CH4_IREMAP 位为 1，在内部把 LSI 连接到 TIM5 的通道 4；通过 TIM5 的捕获&#x2F;比较 4 事件或者中断来测量 LSI 时钟频率；根据测量结果和期望的 RTC 时间基数和独立看门狗的超时时间，设置 20 位预分频器。（5）PLL内部 PLL 可以用来倍频 HSI RC 的输出时钟或 HSE 晶体输出时钟。PLL 的设置（选择 HSI 振荡器除以2或者 HSE 振荡器为 PLL 输入时钟，和选择倍频因子）必须在其被激活前完成。一旦 PLL 被激活，这些参数就不能被改动。如果 PLL 中断在时钟中断寄存器里被允许，当 PLL 准备就绪时，可产生中断申请。如果需要在应用中使用 USB 接口，PLL 必须被设置为输出 48 或 72MHz 时钟，用于提供 48MHz 的 USBCLK 时钟。2、系统时钟 SYSCLKSTM32 的系统时钟 SYSCLK 由 SW 控制，从 HSI、PLLCLK 和 HSE 中三选一，通常选 PLLCLK。系统刚上电 的时候，使用系统内部 8MRC 时钟。SYSCLK 最大 72MHz，也可超频至 128MHz，但不建议。若使用 HSI 经 PLL 作为 SYSCLK，最大 64MHz，因为先 2 分频，PLL 最大只能 16 倍频。系统复位后，HSI 振荡器被选为系统时钟。当时钟源被直接或通过 PLL 间接作为系统时钟时，它将不能被停止。只有当目标时钟源准备就绪了，从一个时钟源到另一个时钟源的切换才会发生。在被选择时钟源没有就绪时，系统时钟的切换不会发生。直至目标时钟源就绪，才发生切换。在时钟控制寄存器（RCC_CE）里的状态位指示哪个时钟已经准备好了，哪个时钟目前被用作系统时钟。二、时钟分配1、SYSCLK系统时钟 SYSCLK，它是供 STM32 中绝大部分部件工作的时钟源。系统时钟可选择为 PLL 输出、HSI 或者 HSE。系统时钟最大频率为 72MHz，它通过 AHB 分频器分频后送给各模块使用，AHB 分频器可选择 1、2、4、8、16、64、128、256、512 分频。其中 AHB 分频器输出的时钟送给 5 大模块使用：送给 AHB 总线、内核、内存和 DMA 使用的 HCLK 时钟。通过 8 分频后送给 Cortex 的系统定时器时钟 SYSTICK。直接送给 Cortex 的空闲运行时钟 FCLK。送给 APB1 分频器。APB1 分频器可选择 1、2、4、8、16 分频，其输出一路供 APB1 外设使用(PCLK1，最大频率 36MHz)，另一路送给定时器 (Timer)2、3、4 倍频器使用。该倍频器可选择1 或者 2 倍频，时钟输出供定时器 2、3、4 使用。送给 APB2 分频器。APB2 分频器可选择 1、2、4、8、16 分频，其输出一路供 APB2 外设使用(PCLK2，最大频率 72MHz)，另一路送给定时器 (Timer)1 倍频器使用。该倍频器可选择 1 或者 2 倍频，时钟输出供定时器 1 使用。另外，APB2 分频器还有一路输出供 ADC 分频器使用，分频后送给 ADC 模块使用。ADC 分频器可选择为 2、4、6、8 分频。在以上的时钟输出中，有很多是带使能控制的，例如 AHB 总线时钟、内核时钟、各种 APB1 外设、 APB2 外设等等。当需要使用某模块时，记得一定要先使能对应的时钟。2、具体时钟分配CM3 的系统滴答时钟 SYSTICK，来源是 AHB 分频后再 8 分频，通常设置 AHB 不分频，所以 SYSTICK 的频率就是 SYSCLK&#x2F;8。APB1（低速APB）总线上的外设时钟 PCLK1，最大为 36MHz，所有挂载在 APB1 上的外设，最大时钟都是 36MHz，定时器除外。PCLK1 的时钟由 APB1 预分频器设置，默认 2 分频（72MHz&#x2F;2）。挂在这一总线的外设有： 电源接口、备份接口、CAN、USB、I2C1、I2C2、UART25、SPI2、SPI3、窗口看门狗(WWDG)、Timer27。注意 USB 模块虽然需要一个单独的 48MHz 时钟信号，但它应该不是供 USB 模块工作的时钟，而只是提供给串行接口引擎(SIE)使用的时钟。APB2（高速 APB）总线上的外设时钟 PCLK2，最大为 72MHz，所有挂载在 APB2 上的外设，最大时钟都是 72MHz。PCLK2 的时钟由 APB2 预分频器设置，默认不分频。挂在这一总线的外设有：UART1、GPIOAG、SPI1、ADC13、高级定时器（1、8）第二功能 IO 口。SDIO 接口的时钟频率固定为 HCLK&#x2F;2。ADC 时钟由高速 APB2 时钟经 2、4、6 或 8 分频获得。如果相应的 APB 预分频系数是 1，定时器时钟频率与所在 APB 总线频率一致，否则为与其相连的 APB 总线频率的 2 倍​FCLK 是 CM3 的自由运行时钟。STM32 中有一个全速功能的 USB 模块，其串行接口引擎需要一个频率为 48MHz 的时钟源。该时钟源只能从 PLL 输出端获取，可以选择为 1.5 分频或者 1 分频，也就是，当需要使用 USB 模块时，PLL 必须使能，并且时钟频率配置为 48MHz 或 72MHz。3、时钟安全系统（CSS）时钟安全系统可以通过软件激活。一旦其被激活，时钟监测器将在 HSE 振荡器启动延迟后被使能，并在 HSE 时钟关闭后关闭。如果 HSE 时钟发生故障，HSE 振荡器被自动关闭，时钟失效事件将被送到高级定时器（TIM1 和 TIM8）的刹车输入端，并产生时钟安全中断 CSSI，允许软件完成营救操作。此 CSSI 中断连接到 Cortex-M3 的 NMI 中断。一旦 CSS 被激活，并且 HSE 时钟出现故障，CSS 中断就产生，并且 NMI 也自动产生。NMI 将被不断执行，知道 CSS 中断挂起位被清除。因此，在NMI的处理程序中必须通过设置时钟中断寄存器（RCC_CIR）里的 CSSC 位来清除 CSS 中断。如果 HSE 振荡器被直接或间接地作为系统时钟，（间接是指作为 PLL 输入时钟而 PLL 时钟作为系统时钟），时钟故障将导致系统时钟自动切换到 HSI 振荡器，同时外部 HSE 振荡器被关闭。在时钟失效时，如果 HSE 振荡器时钟（被分频或未被分频）是用作系统时钟的 PLL 的输入时钟，PLL 也将被关闭。4、RTC 时钟通过设置备份域控制寄存器（RCC_BDCR）里的 RTCSEL[1:0] 位，RTCCLK 时钟源可以有 HSE&#x2F;128、LSE 或 LSI 时钟提供。除非备份域复位，此选择不能被改变。LSE 时钟在备份域里，但 HSE 和 LSI 时钟不是。因此：如果 LSE 被选为 RTC 时钟：只要 VBAT 维持供电，尽管 VDD 供电被切断，RTC 仍继续工作。如果 LSI 被选为自动唤醒单元（AWU）时钟：如果 VDD 供电被切断，AWU 状态不能被保证。如果 HSE 时钟 128 分频后作为 RTC 时钟：如果 VDD 供电被切断或内部电压调压器被关闭（1.8V 域的供电被切断），则 RTC 状态不确定。必须设置电源控制寄存器的 DPB 位为 1（取消后备区域的写保护）。5、看门狗时钟如果独立看门狗已经由硬件选项或软件启动，LSI 振荡器将被强制在打开状态，并且不能被关闭。在 LSI 振荡器稳定后，时钟供应给 IWDG。三、时钟输出STM32 可以选择一个时钟信号输出到 MCO 脚(PA8)上，可以选择为 PLL 输出的 2 分频、HSI、HSE、或者 SYSCLK。四、相关寄存器（1）时钟控制寄存器（RCC_CR）初始化用（2）时钟配置寄存器（RCC_CFGR）初始化用（3）时钟中断寄存器（RCC_CIR）（4）APB2 外设复位寄存器（RCC_APB2RSTR）（5）APB1 外设复位寄存器（RCC_APB1RSTR）（6）AHB 外设时钟使能寄存器（RCC_AHBENR）（7）APB2 外设时钟使能寄存器（RCC_APB2ENR）（8）APB1 外设时钟使能寄存器（RCC_APB1ENR）（9）备份域控制寄存器（RCC_BDCR）（10）控制&#x2F;状态寄存器（RCC_CSR）（11）RCC 寄存器地址映像RCC 地址：0x4002 1000-0x4002 13ff","tags":"硬件拾忆 stm32"},{"title":"STM32 程序烧录","url":"/article/5087e30b.html","text":"STM32 的程序烧录方法有多种：USB、串口、JTAG、SWD等。开发板串口烧录时，mcuisp 软件设置 DTR 低电平复位，RTS 高电平进 BootLoader，选择编程前重装文件，编程后执行，校验，不要选择使用 RamIsp。JLINK v8 支持 JTAG 和 SWSTM32 启动方式：BOOT0BOOT1启动模式说明0X用户闪存存储器用户闪存存储器，也就是FLASH启动10系统存储器系统存储器启动11SRAM 启动SRAN启动，用于在SRAM中调试代码用户闪存，即芯片内置的 FLASH，从用户闪存启动是正常的工作模式；SRAM，是芯片内置的 RAM 区，就是内存；系统存储器，是芯片内部一块特定的区域，芯片出厂时，在这个区域预置了一段 Bootloader，就是通常说的 ISP 程序，这个区域的内容在芯片出场后，没有人能够修改或擦除，即它是一个 ROM 区。标准的 ISP 下载步骤（串口下载）：​ ① 配置 BOOT0 为 1，BOOT1 为 0​ ② 按复位键​ ③ 通过程序下载代码​ ④ 下载完成后将 BOOT0 设置为 GND，以便每次复位后都可以运行用户代码一般不使用内置 SRAM 启动，因为 SRAM 掉电数据丢失。多数情况下 SRAM 只在调试时使用，也可以做其他用途，如故障的局部诊断，写一小段程序加载到 SRAM 中诊断板上的其他电路，或用此方法读写板上的 FLASH 或 EEPROM 等。还可以通过这种方法接触内部FLASH的读写保护，当然接触读写保护的同时，FLASH 的内容也被自动清除，以防止恶意的软件拷贝。一般 BOOT0 和 BOOT1 跳线都跳到 0。只是在 ISP 下载的情况下，BOOT0&#x3D;1，BOOT1&#x3D;0，下载完成后，把 BOOT0 的跳线接回 0。STM32 内部 FLASH 地址起始于 0x08000000，一般情况下，程序文件就从此地址开始写入。此外 STM32 是基于Cortex-M3 内核的微控制器，其内部通过一张“中断向量表”来响应中断，程序启动后，将首先从“中断向量表”取出复位中断向量执行复位中断程序完成启动，而这张“中断向量表”的起始地址 0x08000004，当中断来临，STM32 的内部硬件机制亦会自动将 PC 指针定位到“中断向量表”处，并根据中断源取出对应的中断向量执行中断服务程序。复位中断服务函数执行完之后，会跳转到 main 函数。","tags":"硬件拾忆 stm32"},{"title":"STM32 F4 GPIO","url":"/article/37b6571a.html","text":"1、在 RESET 期间和刚 RESET 之后，IO 端口配置为浮空输入。除了调试接口会在 RESET 之后配置为相应的上下拉模式。2、每个 AHB1 时钟周期输入寄存器 GPIOx_IDR 捕获当前引脚数据。3、输出开漏模式时，只有 N-MOS 工作，写 0 时输出低，写 1 时位高阻态。输出模式下，施密特触发器输入是开启的。输出模式下读取输入寄存器可获得 IO 状态，读取输出寄存器可获得上一次写入的值。4、RESET 之后，所有 IO 连接至第二功能 0（AF0）。5、外设第二功能映射为从 AF1 到 AF13。6、RTC_REFIN 引脚应配成浮空输入。7、MCO1 和 MCO2 引脚必须配成第二功能模式。8、ADC 和 DAC 配置成模拟功能。9、通过映射到 AF15 可将 IO 用来输出 CM4 的 FPU EVENTOUT 信号。10、EVENTOUT 不能映射到P C13，PC14，PC15，PH0，PH1 和 PI8。11、每组 IO 口有 4 个控制寄存器GPIOx_MODERselect IO direction（Input，Output，AF，Analog）GPIOx_OTYPERselect output type（push-pull or open-drain）GPIOx_OSPEEDRselect speedGPIOx_PUPDRselect pull-up&#x2F;pull-down whatever the IO direction12、每组 IO 口有 2 个数据寄存器。GPIOx_IDRinputGPIOx_ODRoutput13、GPIOx_BSRR 允许对 GPIOx_ODR 寄存器进行位元操作。set 比 reset 的优先级高。位元操作时不需要关闭中断。14、通过操作 GPIOx_AFRL 和 GPIOx_AFRH 寄存器可以将任一 IO 引脚连接至 16 种第二功能（AF0到AF15）的任意一个。15、写 GPIOx_LCKR 寄存器需要特定的读写序列，可以锁存 4 个控制寄存器、GPIOx_AFRL 和 GPIOx_AFRH 寄存器。16、使用 IO 外部中断必须配置成输入 模式。17、使用模拟功能时，输出 buffer 关闭，施密特触发器关闭，施密特触发器的输出强制为 0，上下拉电阻关闭，读输入寄存器只能读到 0。18、不使用 LSE 振荡器时，可将 PC14 和 PC15 用作普通 IO。LSE 的优先级比 GPIO 功能高，当 RCC_BDCR 寄存器的 LSEON 位置位时，LSE 振荡器打开 PC14 和 PC15 作为 OSC32_IN 和 OSC32_OFF。1.2V 域掉电时（器件进入掉电模式），或备份域有 VBAT 供电时，PC14 和 PC15 的 GPIO 功能丧失，这种情况下，处于模拟输入模式。19、RESET 后，HSE 振荡器默认关闭，此时 PH0&#x2F;PH1 可以作为普通 IO，而非 OSC_IN 和 OSC_OUT 功能。通过置位 RCC_CR 寄存器的 HSEON 位可开启 HSE 振荡器。HSE 比 GPIO 优先级高。","tags":"硬件拾忆 stm32"},{"title":"STM8S TIM1 时基单元","url":"/article/134333cf.html","text":"一、简介TIM1 由一个 16 位自动装载计数器组成，它由一个可编程的预分频器驱动。高级控制定时器适用于许多不同的用途：基本的定时测量输入信号的脉冲宽度（输入捕获）产生输出波形（输出比较，PWM 和单脉冲模式）对应不同事件（捕获，比较，溢出，刹车，触发）的中断与 TIM5&#x2F;TIM6 或者外部信号（外部时钟，复位信号，触发和使能信号）同步高级控制定时器广泛适用各种控制应用，包括那些需要中间对齐模式 PWM 的应用，该模式支持互补输出和死区时间控制。高级控制定时器的时钟可以是内部信号，也可以是外部信号，通过寄存器配置来选择。二、主要特性TIM1的特性包括：16 位向上、向下、向上&#x2F;下自动装载计数器允许在指定数目的计数器周期之后更新定时器寄存器的重复计数器16 位可编程（可实时修改）预分频器，计数器时钟频率的分频系数为 1~65536 间的任意数值同步电路，用于使用外部信号控制定时器以及定时器互联多达四个独立通道可以配置成：输入捕获输出比较PWM 生成（边缘或中间对齐模式）六步 PWM 输出单脉冲模式输出三个支持带互补输出，并且死区时间可编程的通道刹车输入信号可以将定时器输出信号置于复位状态或一个已知状态产生中断的事件包括：更新：计数器向上&#x2F;向下溢出，计数器初始化（通过软件或内部&#x2F;外部触发）触发事件（计数器启动、停止、初始化或由内部&#x2F;外部触发计数）输入捕获输出比较刹车信号输入三、时基单元时基单元包含：16位向上&#x2F;向下计数器16位自动重载寄存器重复计数器预分频器16 位计数器，预分频器，自动重载寄存器和重复计数器都可以通过软件读写。自动重载寄存器由预装载寄存器和影子寄存器组成。可在两种模式下写自动重载寄存器：自动预装载已使能（TIM1_CR1 寄存器的 ARPE 位置位）。在此模式下，写入自动重载寄存器的数据将被保存在预装载寄存器中，并在下一个更新事件（UEV）时传送到影子寄存器。自动预装载已禁止（TIM1_CR1 寄存器的 ARPE 位清除）。在此模式下，写入自动重载寄存器的数据将立即写入影子寄存器。更新事件的产生条件：计数器向下或向下溢出软件置位了 TIM1_EGR 寄存器的 UG 位时钟&#x2F;触发控制器产生了触发事件在预装载使能时（ARPE&#x3D;1），如果发生了更新事件，预装载寄存器中的数值（TIM1_ARR）将写入影子寄存器中，并且 TIM1_PSCR 寄存器中的值将写入预分频器中。置位 TIM1_CR1 寄存器的 UDIS 位将禁止更新事件（UEV）。计数器由预分频器的输出 CK_CNT 驱动，而 CK_CNT 仅在 IM1_CR1 寄存器的计数器使能位（CEN）被置位时才有效。在使能了 CEN 位的一个时钟周期后，计数器才开始计数。1、读写 16 位计数器写计数器的操作没有缓存，并且可以在任何时候写 TIM1_CNTRH 和 TIM1_CNTRL 寄存器，因此建议不要再计数器运行时写入新的数值，以免写入错误的数值。读计数器的操作带有 8 位缓存。在用户读了高位（MS）字节后，低位（LS）字节将被自动缓存，缓存的数据在 16 位的读操作完成之前不会有变化。注意：不要使用 LDW 指令来读取 16 位计数器的值，因为此指令先读低位（LS）字节，这样读出的数值是错误的。2、16 位 TIM1_ARR 寄存器的写操作通过预装载寄存器向 TIM1_ARR 寄存器中写入 16 位的值。此操作由两条指令完成，每条指令写入 1 个字节，高位（MS）字节是必须先写入的。影子寄存器在高位（MS）字节写入后被锁定，并保持到低位（LS）字节写完。不要使用 LDW 指令，因为此指令先写低位（LS）字节，这将导致写入的数值错误。3、预分频器TMI1 的预分频器基于一个由 16 位寄存器（TIM1_PSCR）控制的 16 位计数器。由于这个控制寄存器带有缓冲器，因此它能够在运行时被改变。预分频器可以将计数器的时钟频率按 1 到 65536 之间的任意值分频。计数器的频率可以由下式计算：fCK_CNT &#x3D; fCK_PSC&#x2F;（PSCR[15:0] + 1）预分频值由预装载寄存器写入，保存了当前使用值的影子寄存器在低位（LS）写入后被载入。需两次单独的写操作来写 16 位寄存器，高位（MS）先写。不要使用先写低位的 LDW 指令。新的预分频器的值在下一次更新事件到来时被采用。对 TIM1_PSCR 寄存器的读操作通过预装载寄存器完成，因此不需要特别的关注。4、向上计数模式计数器从 0 计数到用户定义的比较值（TIMx_ARR 寄存器的值），然后重新从 0 开始计数并产生一个计数器溢出事件，同时，如果 TIM1_CR1 寄存器的 UDIS 位是 0，将会产生一个更新事件（UEV）。置位 TIMx_EGR 寄存器的 UG 位（通过软件方式或使用从模式控制器）同样可产生一个更新事件。使用软件置位 TIMx_CR1 寄存器的 UDIS 位，可以禁止更新事件，这样可避免在更新预装载寄存器时更新影子寄存器。在 UDIS 位被清除之前，将不产生更新事件。但是在应该产生更新事件 时，计数器仍会被清 0，同时预分频器的计数也被清 0（但预分频器的数值不变）。此外，如果设置了 TIMx_CR1 寄存器中的 URS 位（选择更新请求），设置 UG 位将产生一个更新事件 UEV，但硬件不设置 UIF 标志（即不产生中断请求）。这是为了避免在捕获模式下清除计数器时，同时产生更新和捕获中断。当发生一个更新事件时，所有的寄存器都被更新，硬件同时（依据 URS 位）设置更新标志位（TIMx_SR 寄存器的 UIF 位）：自动装载影子寄存器被重新置入预装载寄存器的值（TIMx_ARR）预分频器的缓存器被置入预装载寄存器的值（TIMx_PSC 寄存器的内容）5、向下计数模式计数器从自动装载的值（TIMx_ARR 寄存器的值）开始向下计数到 0，然后再从自动装载的值重新开始计数，并产生一个计数器向下溢出时间。如果 TIM1_CR1 寄存器的 UDIS 位被清除，还会产生一个更新事件（UEV）。置位 TIMx_EGR 寄存器的 UG 位（通过软件方式或者使用从模式控制器）也同样可以产生一个更新事件。置位 TIMx_CR1 寄存器的 UDIS 位可以禁止 UEV 事件。这样可以避免在更新预装载寄存器时更新影子寄存器。因此 UDIS 位清除之前不会产生更新事件。然而，计数器仍会从当前自动加载值重新开始计数，并且预分频器的计数器重新从 0 开始（但预分频器不能被修改）。此外，如果设置了 TIMx_CR1 寄存器中的 URS 位（选择更新请求），设置 UG 位将产生一个更新事件 UEV 但不设置 UIF 标志（因此不产生中断），这是为了表面在发生补货时间并清除计数器时，同时产生更新和捕获中断。当发生更新事件时，所有的寄存器都被更新，并且（根据 URS 位的设置）更新标志位（TIMx_SR 寄存器中的 UIF 位）也被设置：预分频器的缓存器被存入预装载的值（TIMx_PSC 寄存器的值）。当前的自动加载寄存器被更新为预装载值（TIMx_ARR 寄存器中的内容）。要注意自动装载寄存器在计数器重载入之前被更新，因此下一个周期才是预期的值。以下是一些当 TIMx_ARR &#x3D; 0x36 时，计数器在不同时钟频率下的图表。下图描述了在向下计数模式下，预装载不使能时新的数值在下个周期时被写入。6、中央对齐模式（向上&#x2F;向下计数）在中央对其模式。计数器从 0 开始计数到自动加载的值（TIMx_ARR寄存器）-1，产生一个溢出事件，然后向下计数到 0 并且产生一个计数器下溢事件，然后再从 0 开始重新计数。在此模式下，不能写入 TIMx_CR1中 的 DIR 方向位。它由硬件更新并指示当前的计数方向。如果定时器带有重复计数器（如 TIM1），在重复了指定次数（TIM1_RCR 的值）的向上和向下溢出之后会产生更新事件（UEV）。否则每一次的向上向下溢出都会产生更新事件。置位 TIMx_EGR 寄存器的 UG 位（通过软件方式或者使用从模式控制器）也同样可以产生一个更新事件。此时，计数器重新从 0 开始计数，预分频器也重新从 0 开始计数。设置 TIMx_CR1 寄存器中的 UDIS 位可以禁止 UEV 事件。这样可以避免在更新预装载寄存器时更新影子寄存器。因此 UDIS 位被清 0 之前不会产生更新事件。然而，计数器仍会根据当前自动重加载的值，继续向上或向下计数。如果定时器带有重复计数器，由于重复寄存器没有双重的缓冲，新的重复数值将立刻生效，因此在修改时需要小心。此外，如果设置了 TIMx_CR1 寄存器中的 URS 位（选择更新请求），设置 UG 位将产生一个更新事件 UEV 但不设置 UIF 标志（因此不产生中断），这是为了避免在发生捕获事件并清除计数器时，同时产生更新和捕获中断。当发生更新事件时，所有的寄存器都被更新，并且（根据 URS 位的设置）更新标志位（TIMx_SR 寄存器中的 UIF 位）也被设置。预分频器的缓存器被加载为预装载（TIMx_PSC 寄存器）的值。当前的自动加载寄存器被更新为预装载值（TIMx_ARR 寄存器中的内容）。要注意到如果因为计数器溢出而产生更新，自动重装载寄存器将在计数器重载入之前被更新，因此下一个周期才是预期的值（计数器被装载位新的值）。以下是一些计数器在不同时钟频率下的操作的例子：使用中央对齐模式的提示：启动中央对齐模式时，计数器将按照原有的向上&#x2F;向下的配置计数。也就是说 TIM1_CR1 寄存器中的 DIR 位将决定计数器时向上还是向下计数。此外，软件不能同时修改 DIR 和 CMS 位的值。不推荐在中央对齐模式下，计数器正在计数时写计数器的值，这将导致不能预料的后果。具体的说：向计数器写入了比自动装载值更大的数值时（TIM1_CNT &gt; TIM1_ARR），但计数器的技术方向不发生改变。例如计数器已经向上溢出，但计数器仍然向上计数。向计数器写入了 0 或者 TIM1_ARR 的值，但更新事件不发生。安全使用中央对齐模式的计数器的方法是在启动计数器之前先用软件（置位 TIM1_EGR 寄存器的 UG 位）产生一个更新事件，并且不在计数器计数时修改计数器的值。7、重复计数器时基单元一节解释了计数器向上&#x2F;向下溢出时更新事件（UEV）是如何产生的，然而事实上它只能在重复计数器的值达到 0 的时候产生。这个特性对产生 PWM 信号非常有用。这意味着在每 N 次计数上溢或下溢时，数据从预装载寄存器传输到影子寄存器（TIMx_ARR 自动重载入寄存器，TIMx_PSC 预装载寄存器，还有在比较模式下的捕获&#x2F;比较寄存器 TIMx_CCRx），N 是 TIMx_RCR 重复计数寄存器中的值。重复计数器在下述任一条件成立时递减：向上计数模式下每次计数器向上溢出时向下计数模式下每次计数器向下溢出时中央对齐模式下每次上溢和下溢时虽然这样限制了 PW 的最大循环周期为 128，但它能够在每个 PWM 周期 2 次更新占空比。在中央对齐模式下，因为波形是对称的，如果每个 PWM 周期中仅刷新一次比较寄存器，则最大的分辨率为 2*tCK_PSC。重复计数器是自动加载的，重复速率由 TIMx_RCR 寄存器的值定义。当更新事件由软件产生（通过设置 TIMx_EGR 中的 UG 位）或者通过硬件的从模式控制器产生，则无论重复计数器的值是多少，立即发生更新事件，并且 TIMx_RCR 寄存器中的内容被重载到重复计数器。","tags":"硬件拾忆 stm8"},{"title":"STM8S 自动唤醒 AWU","url":"/article/3f13bc8b.html","text":"一、简介AWU 是用来当 MCU 进入低功耗的 Active Halt 模式时提供一个内部的唤醒时间基准。该时间基准的时钟是由内部的低速 RC 振荡器时钟（LSI）或通过预分频的 HSE 晶振时钟来提供的。LSI 时钟测量在使用 LSI 低速内部时钟时，为了确保最好的精度，它的频率可以通过 TIM3 的输入捕获 1 来测定。注意：LS 低速时钟源的选择是通过编程 CKAWUSEL 选项位来实现的。二、AWU 功能描述1、AUW 操作为了使用 AWU 功能，按顺序执行如下步骤：空闲模式如果不使用 AWU，必须载入‘0000’值到 AWU_TBR 的 AWUTB[3:0] 来降低功耗。2、时基选择3、LSI 低速内部时钟频率检测在经过出厂校验后，在全温度范围内低速内部 RC（LSI）振荡器的频率离散性是 128kHz±12.5%。为了获得精确的 AWU 时间间隔或蜂鸣器输出，必须精确测量 LSI 频率。三、AWU寄存器控制&#x2F;状态寄存器 AWU_CSR异步预分频寄存器 AWU_APR时基选择寄存器 AWU_TBR","tags":"硬件拾忆 stm8"},{"title":"STM8S 通用 IO","url":"/article/e68e2e45.html","text":"一、简介一个 GPIO 端口可以包括多达 8 个引脚，每个引脚可独立编程为数字输入或数字输出口。部分口可能会有模拟输入，外部中断，片上外设的输入输出等复用功能。但是同一时刻只有一个复用功能可以映射到引脚上。复用功能的映射是通过选项字节控制的。二、GPIO 主要功能浮空输入和上拉输入推完输出和开漏输出输入输出有各自的寄存器外部中断可单独使能和关闭输出摆率可单独使能和关闭输出摆率控制用以较少 EMC 噪声片上外设的 IO 功能复用当作为模拟输入时可以关闭输入施密特触发器来降低功耗数据输出锁存时支持 读-修改-写输入兼容 5VIO 口工作电压范围为 1.6V 到 VDDIOmax输出级在选择模拟输入时是禁止的。三、IO 的配置和使用每一个端口都有一个输出数据寄存器（ODR），一个引脚输入寄存器（IDR）和一个数据方向寄存器（DDR）总是同相关的。控制寄存器 1（CR1）和控制寄存器 2（CR2）用于对输入&#x2F;输出进行配置。任何一个 IO 引脚可以通过对 DDR，ODR，CR1 和 CR2 寄存器的相应位进行编程来配置。在真正的漏极开路硅片引脚上不存在连接到 VDD 的二极管，在硅片引脚和 VOL 之间集成了局部保护，以保护设备免受 positive stress。复位之后，所有引脚都是悬浮输入模式。个别引脚可能有其他动作。没有使用的 IO 引脚不能保持悬空以避免额外的电流消耗，必须从以下配置选一个：通过外部上拉或下拉电阻连接到 VDD 或 VSS，并设为悬空输入。配置为输入，使用内部上下拉电阻配置为推完输出低小封装中有些 IO 端口的引脚数不足 8 个，对这些端口的寄存器进行写操作不会有任何影响，输入寄存器中相应位的读出值是 0。如果 PA1&#x2F;PA2 被用来连接外部谐振器，为了确保在 HALT 模式下有最低功耗，必须配置 PA1 和 PA2 为上拉输入。三、输入模式详述1、复用功能输入部分 IO 口可以用作复用功能输入。例如：可以被用来作为输入到定时器的输入捕获口。复用的输入功能使不会自动选择的，用户可以通过写相应的外设寄存器的控制位来选择复用功能。对于复用功能的输入，用户必须通过配置 DDR 和 CR1 寄存器设置将对应的 IO 口设为悬空或上拉输入。2、中断功能每一个中断向量都可以独立编程为上升沿或下降沿触发。外部中断只有在对应 IO 口被设置为输入模式时才有效。3、模拟通道4、施密特触发器部分 IO 口包括一个内嵌的输入施密特触发器，可以通过 ADC_TDR 施密特触发器来禁止寄存器来使能&#x2F;禁止施密特触发器。四、输出模式详述1、复用功能输出复用功能使能时，复用功能模块接管了输出锁存寄存器（Px_ODR）并强制 Px_ODR 相应的位为 1。复用输出功能可以是上拉或者开漏输出，取决于外设本身和控制寄存器（Px_CR1），输出摆率取决于控制寄存器 2（Px_CR2）的值。例如：考虑到要达到最佳性能，SPI 输出引脚必须设置为上拉，快速摆率。 UART_Tx 可以被配置为上拉或开漏输出（带外部上拉）来实现多从机的配置。2、摆率控制输出摆率可以使用 CR2 的相应位通过软件控制。置位 CR 相应位选择为 10MHz 的输出频率。该功能既可以用在开漏也可以用在带上拉的输出模式 IO 口，输出类型为 O3 或 O4。五、GPIO 寄存器输出数据寄存器 Px_ODR输入数据寄存器 Px_IDR数据方向寄存器 Px_DDR控制寄存器1 Px_CR1控制寄存器2 Px_CR2","tags":"硬件拾忆 stm8"},{"title":"STM8S 电源管理","url":"/article/d8daeb2e.html","text":"默认情况下在系统或电源复位后，MCU 处于运行模式。在这种模式下，CPU 由 fCPU 提供时钟并执行程序代码，系统时钟分别为各个处于激活状态的外设提供时钟，MCU 功耗最大。在运行模式下，为了保持 CPU 继续运行并执行代码，有以下几种途径可以降低功率消耗：降低系统时钟关闭未使用外设的时钟关闭所有未使用的模拟功能块但是，如果 CPU 不需要保持运行，可使用下列三种低功耗模式：等待（Wait）活跃停机（Active Halt）可配置为慢速或快速唤醒停机（Halt）可配置为慢速或快速唤醒用户可选择以上三种模式中的一种，并合理配置，以在最低功耗、最快唤醒速度和可使用的唤醒源之间获得最佳平衡点。一、常规考虑硅片中通常存在两种功耗：静态功耗：由极化电流和漏电流造成。静态功耗很小，只在停机（Halt）模式和活跃停机（Active Halt）模式下有意义。动态功耗：来自于芯片上正在运行的数字模块。它取决于 VDD，时钟频率和负载电容。一个 MCU 的功耗取决于：VDD 供电电压模拟性能MCU 大小及数字逻辑门数（漏电流及负载电容）时钟频率处于激活状态的外设数目可用的低功耗模式及级别MCU 的处理速度也很重要，这使得用户程序只需很短时间处于运行状态，而更多时间处于低功耗模式下。二、低功耗的时钟管理1、降低系统时钟通过写时钟分频寄存器 CLK_CKDIVR 的位 CPUDIV[2:0]，可降低 fCPU 的时钟频率。这会降低 CPU 的速度，但同时可降低 CPU 的功耗。其它外设（由 fMASTER 提供时钟）不会受此设置影响。在运行模式下，任何时候需要恢复全速运行，将 CPUDIV[2:0] 清 0 即可。2、外设时钟门控使用时钟门控，用户可在任意时间打开或关闭 fMASTER 与各个外设的连接，在运行模式和等待模式均有效。三、低功耗模式1、等待模式（Wait）在运行模式下执行 WFI（等待中断）指令，可进入等待模式。此时 CPU 停止运行，但外设与中断控制器仍保持运行，因此功耗会有所降低。等待模式可与 PCG（外设时钟门控），降低 CPU 时钟频率，以及选择低功耗时钟源（LSI，HSI）相结合使用，以进一步降低系统功耗。等待模式下，所有寄存器与 RAM 的内容保持不变，之前所定义的时钟配置也保持不变（CLK_CMSR） 。当一个内部或外部中断请求发生时，CPU 从等待模式唤醒并恢复工作。2、停机模式（Halt）该模式下主时钟停止。即由 fMASTER 提供时钟的 CPU 及所有外设均被关闭。因此，所有外设均没有时钟，MCU 的数字部分不消耗能量。停机模式下，所有寄存器与 RAM 的内容保持不变，默认情况下时钟配置也保持不变（CLK_CMSR）。MCU 可通过执行 HALT 指令进入停机模式。外部中断可将 MCU 从停机模式唤醒。外部中断指配置为中断输入的 GPIO 端口或具有触发外设中断能力的端口。这种模式下，仅低电压调节器（和掉电复位）处于工作状态。快速时钟启动HSI RC 的启动速度比 HSE 快。因此，为了减少 MCU 唤醒时间，建议在进入暂停模式前选择 HSI 作为 fMASTER 的时钟源。在进入停机模式前可通过设置内部时钟寄存器 CLK_ICKR 的 FHWU 位选择 HSI 作为 fMASTER 的时钟源，而无需时钟切换。3、活跃停机模式（Active Halt）活跃停机模式与停机模式类似，但它不需要外部中断唤醒。它使用 AWU，在一定的延时后，产生一个内部唤醒事件，延迟时间是用户可编程的。在活跃停机模式下，主振荡器，CPU 以及几乎所有外设都被停止。如果 AWU 和 IWD 已被使能，则只有 LSI RC 和 HSE 仍处于运行状态，以驱动 AWU 和 IWD 计数器。为进入活跃停机模式，需首先使能 AWU然后执行 HALT 指令。主电源调节器自动关闭默认情况下，为了从活跃停机模式快速唤醒，主电压调节器处于激活状态。但其电流消耗是不可忽视的。为进一步降低功耗，当 MCU 进入活跃停机模式时，主电压调节器可自动关闭。通过设置内部时钟寄存器 CLK_ICKR 的 REGAH 位可实现此功能。此时:- MCU 内核由低功耗电压调节器（LPVR）供电。- 仅 LSI 时钟源可用，因为 HSE 时钟源对于 LPVR 来说电流消耗太大。在唤醒时主电压调节器重新被打开，这需要一个比较长的唤醒时间。快速唤醒时钟为了缩短唤醒时间，建议使用 HSI 作为 fMASTER 的时钟源。FHWU 位也可用于缩短切换时间。在活跃停机模式下，快速唤醒时很重要的。这可以提高 CPU 的执行效率，使 MCU 处于运行状态与低功耗模式之间的时间最短，从而减少整体平均功耗。四、附加的模拟功耗控制1、停机模式下的快速内存唤醒默认情况下，MCU 进入 Halt 模式后 FLASH 是处于掉电状态的。此时，漏电流可忽略，功耗是非常低的。但 FLASH 的唤醒时间较长（几us）。​如果用户需要从 Halt 模式快速唤醒，可将 FLASH_CR1 的 HALT 位置 1。当 MCU 进入停机模式时，这将确保 FLASH 处于等待状态，唤醒时间降至几纳秒。但功耗将增至几 uA。2、活跃停机模式下的超低内存功耗在活跃停机模式下，为加快唤醒时间，默认情况下 FLASH 处于工作状态，因此并没有降低功耗。为降低功耗，用户可将 FLASH_CR1 的 AHALT 位置 1。在进入活跃停机模式时，这将停止向 FLASH 供电以降低功耗，但唤醒时间将增至微秒级。","tags":"硬件拾忆 stm8"},{"title":"STM8S 时钟控制","url":"/article/ba78637e.html","text":"一、时钟控制时钟控制器功能强大而且灵活易用。其目的在于使用户获得最好性能的同时，亦能保证消耗的功率最低。用户可独立管理各个时钟源，并将它们分配到 CPU 各个外设。主时钟和 CPU 时钟均带有预分频器。具有安全可靠的无故障时钟切换机制，可在程序运行中将主时钟从一个时钟源切换到另一个时钟源。二、抗电磁干扰时钟配置寄存器为了避免由电磁干扰造成的对应用程序误写操作或系统挂起，大多数关键的时钟寄存器都有一个互补寄存器与之相对应。系统将会自动检测这些关键寄存器与其互补寄存器之间是否匹配。如果不匹配，则产生一个 EMS 复位，从而使应用程序恢复到正常操作。三、时钟树四、主时钟源下面 4 种时钟源可用作主时钟：1~24MHz 高速外部晶体振荡器（HSE）最大 24MHz 高速外部时钟信号（HSE user-ext）16MHz 高速内部 RC 振荡器（HSI）128KHz 低速内部 RC（LSI）各个时钟源可单独打开或关闭，从而优化功耗。1、HSE高速外部时钟信号可由以下两个时钟源产生：HSE外部晶体&#x2F;陶瓷谐振器HSE用户外部有源时钟为了最大限度减小输出失真和减小启动的稳定时间，谐振器和负载电容应尽可能得靠近振荡器引脚。负载电容值应根据所选的振荡器进行调整。外部晶体振荡器在启动时的输出时钟信号是不稳定的，默认情况下，在时钟信号被使用之前会插入 2048 个振荡周期的延迟。用户可通过设置选项字节 HSECNT 来缩短稳定时间。外部时钟寄存器 CLK_CEKR 中的标志位 HSERDY 用以指示高速外部振荡器是否稳定。启动时， HSE 时钟信号将不会生效直至次标志位被硬件置位。HSE 晶体可通过设置外部时钟寄存器 CLK_ECKR 中的 HSEEN 位来打开或关闭。用户可通过编程选项位 EXTCLK 选择 HSE 用户外部时钟模式，此时，占空比约 50% 的外部时钟信号（方波，正弦波，三角波）用以驱动 OSCIN 引脚，而 OSCOUT 引脚可作为 GPIO 使用。2、HSIHSI 信号由内部 16MHz RC 振荡器与一个可编程分频器（分频因子从 1 到 8）产生。分频因子由寄存器 CLK_CKDIVR 决定。启动时，主时钟源默认为 HSI RC 时钟的 8 分频，即 fHSI&#x2F;8。HSI RC 可提供一个低成本的 16MHz 时钟源，占空比 50%。HSI 启动速度比 HSE 晶体振荡器快，但是精度即使校准也仍然比外部晶体振荡器或陶瓷谐振器低。内部时钟寄存器 CLK_ICKR 中的标志位 HSIRDY 用以指示 HSI RC 是否稳定。启动时，HSI 时钟信号将不会生效直至此标志位被硬件置位。HSI RC 可通过设置内部时钟寄存器 CLK_ICKR 中的 HSIEN 位打开或关闭。备份时钟源当 HSE 晶体振荡器失效时 HSI&#x2F;8 可作为备份时钟源使用。快速启动特性如果寄存器 CLK_ICKR 中的 FHWU 位被置 1，则MCU从停机（Halt）模式或活跃停机（Active Halt）模式唤醒时，HSI 将自动被设为主时钟源。校准每个产品在出厂时均已经 ST 校准。复位后，出厂校准值将被自动加载至内部校准寄存器。如果实际应用中电压或温度偏差较大，将会影响 RC 振荡器的速度。用户可使用 HSI 时钟校准寄存器修正 HSI 的时钟频率。3、LSI128KHz 的 LSI RC 时钟是一个低功耗低成本的可选主时钟源，也可在停机（Halt）模式下作为维持独立看门狗和自动唤醒单元（AWU）运行的低功耗时钟源。LSI 可通过设置内部时钟寄存器 CLK_ICKR 中的 LSIEN 位打开或关闭。内部时钟寄存器 CLK_ICKR 中的标志位 LSIRDY 用以指示 LSI 是否稳定。启动时，LSI 时钟信号将不会生效直至此标志位被硬件置位。LSI 出厂也已经校准，但用户不能再进一步校准。注意：当独立看门狗使用 LSI 为时钟源时，为了保证 CPU 在系统出错时不与独立看门狗使用同一个时钟，当选项字节位 LSI_EN 为 0 时，LSI 不能作为主时钟。五、主时钟切换时钟切换功能为用户提供了一中易用、快速、安全的从一个时钟源切换到另一个时钟源的途径。1、系统启动为使系统快速启动，复位后时钟控制器自动使用 HSI 的 8 分频作为主时钟。其原因为 HSI 的稳定时间短，而 8 分频可保证系统在较差的 VDD 条件下安全启动。一旦主时钟源稳定，用户程序可将主时钟切换到另外的时钟源。2、主时钟切换的过程1）自动切换自动切换使用户可使用最少的指令完成时钟源的切换。应用软件可继续其它操作而不用考虑切换事件所占的确切时间。设置切换控制寄存器（CLK_SWCR）中的位 SWEN，使能切换机制。向主时钟切换寄存器（CLK_SWR）写入一个 8 位的值，用以选择目标时钟源。寄存器 CLK_SWCR 的 SWBSY 被硬件置位，目标源振荡器启动。原时钟源依然被用于驱动内核和外设。一旦目标时钟源稳定，寄存器 CLK_SWR 中的值将被复制到主时钟状态寄存器（CLK_CMSR）中去。此时，SWBSY 位被清除，新时钟源替代旧时钟源。寄存器 CLK_SWCR 中的标志位 SWIF 被置位，如果 SWIEN 为 1，则会产生一个中断。2）手动切换与自动切换不同，不能立即切换，但它允许用户精确地控制切换事件发生的时间。向主时钟切换寄存器（CLK_SWR）写入一个 8 位的值，用以选择目标时钟源。寄存器 CLK_SWCR 的 SWBSY 被硬件置位，目标源振荡器启动。原时钟源依然被用于驱动内核和外设。用户软件需等待至目标时钟源稳定。寄存器 CLK_SWCR 中的标志位 SWIF 用以指示目标时钟源是否已稳定，如果 SWIEN 为 1，则会产生一个中断。最后，由用户软件在所选的时间点，设置寄存器 CLK_SWCR 中的位 SWEN，执行切换。无论是手动切换还是自动切换，如果源时钟源仍然在被其他模块使用（如 LSI 在被独立看门狗使用），则原时钟源将不会被自动关闭。配置内部时钟寄存器 CLK_ICKR 和外部时钟寄存器 CLK_ECKR 中的相应位，可关闭原时钟源。如果由于某种原因时钟切换没有成功，软件可通过清除标志位 SWBSY 以复位当前的切换操作，使寄存器 CLK_SWR 恢复原值（原时钟源）。六、低速时钟源的选择可通过选择位 CKAWUSEL 来选择自动唤醒单元（AWU）和独立看门狗所使用的低速时钟源，可以是 LSI 或 HSE 的分频。HSE 的分频值可通过选项字节位 HSEPRSC[1:0] 编程。目的是是 HSE 分频器输出一个 128KHz 的时钟信号。七、CPU 时钟分频器CPU 时钟 fCPU 由主时钟 fMASTER 分频而来，分频因子由时钟分频寄存器（CLK_CKDIVR）中的位 CPUDIV[2:0] 决定。共 7 个分频因子可供选择（1 至 128 中，2 的幂）。fCPU 为 CPU 和窗口看门狗提供时钟。八、外设时钟门控关闭未使用外设的时钟可降低功耗。外设的时钟门控（PCG）模式使用户可在运行模式下随时打开或关闭 fMASTER 与下列外设的连接：ADCI2CAWU（寄存器时钟，而非计数器时钟）SPITIM[4:1]UARTCAN（寄存器时钟，而非 CAN 时钟）系统复位后，所有外设时钟均处于开的状态。用户可通过清除 CLK_PCKENR1 或 CLK_PCKENR2 中的 PCKEN 位来关闭响应的外设时钟。但是在关闭外设的时钟前，用户必须设置响应的位禁用该外设。为了使能一个外设，用户必须先设置寄存器 CLK_PCKENR 中对应的 PCKEN 位，然后设置外设控制寄存器中的外设使能位。AWU 计数器是由独立于 fMASTER 的内部或外部时钟（LSI 或 HSE）驱动，因此，即使寄存器的时钟已被关掉，该外设依然可以继续运行。九、时钟安全系统（CSS）时钟安全系统用于监控 HSE 时钟源是否失效。当 fMASTER 使用 HSE 作为时钟源时，如果 HSE 时钟由于谐振器损坏、断开或其它原因失效，时钟控制器将激活安全恢复机制，将 fMASTER 自动切换到辅助时钟源 HSI&#x2F;8。系统将一直使用辅助时钟源，直至 MCU 被复位。设置时钟安全系统寄存器 CLK_CSSR 中的 CSSEN 位，可使能时钟安全系统。为安全起见，CSS 一旦使能就不能被关闭，直到下一次复位。必须满足下面的条件，CSS 方可检测 HSE 石英晶体的失效：HSE 晶体开：（外部时钟寄存器 CLK_ECKR 中的位 HSEEN&#x3D;1）HSE 振荡器被置为石英晶体：（选项位 EXTCLK为 1）CSS 功能开：（寄存器 CLK_CSSR 中 CSSEN&#x3D;1）如果当前的主时钟源位 HSE，当失效被检测到时，CSS 将执行以下操作：寄存器 CLK_CSSR 中的 CSSD 位被置为，如果 CSSIEN 为 1，则同时产生一个中断CLK_CMSR，CLK_SWR，及 CLK_CKDIVR 中的 HSIDIV[1:0] 位被置为复位值（CKM[7:0]&#x3D;SW[7:0]&#x3D;E1h）。HSI&#x2F;8 称为主时钟每部时钟寄存器 CLK_ICKR 中的 HSIEN 被置位（HSI开）外部时钟寄存器 CLK_ECKR 中的 HSEEN 被清除（HSE关）AXU 位被置位，用以指示辅助时钟源 HSI&#x2F;8 被强制使用用户可通过软件清除 CSSD 位，但 AXU位 只能由复位清除。为了提高时钟频率，用户在清除寄存器 CLK_CSSR 中的 CSSD 位以后，课修改寄存器 CLK_CKDIVR 中的 HSIDIV[1:0] 位。如果失效发生时 HSE 不是主时钟源，主时钟将不会被切换到辅助时钟源，以上操作也不会发生，仅执行下面的操作：外部时钟寄存器 CLK_ECKR 中的 HSEEN 被清除，HSE 关闭。寄存器 CLK_CSSR 中的位 CCSD 被置位，如果 CSSIEN 位 1，则同时产生一个中断。如果 HSE 不是当前主时钟源，且主时钟正在被切换至 HSE，则在清除 CSSD 位之前，必须先清除寄存器 CLK_SWCR 的 SWBSY 位。如果当失效被检测到时，HSE 被 CCOSEL 选择为时钟输出模式，则 HSI（HSIDIV）将替代 HSE，被自动强制选择为输出时钟。十、时钟输出功能（CCO）可配置的时钟输出功能使用户可在外部管脚 CCO 上输出指定的时钟。用户可选择下 6 种时钟信号之一作为 CCO 时钟：fHSEfHSIfHSIDIVfLSIfMASTERfCPU（可选择分频）注意：在所有可能的分频值下，不能保证信号的占空比全部为 50%。通过配置时钟输出寄存器 CLK_CCOR 中域 CCOSEL[3:0] 可选择输出的时钟。用户需位指定的 I&#x2F;O 引脚选择期望输出的时钟。此 IO 必须通过配置寄存器 Px_CR1 对应的位为 1 来设为上拉输入或推挽输出模式。一旦可配置始终输出寄存器 CLK_CCOR 的 CCOEN&#x3D;1 就开始输出所选定的时钟信号。如果 CCOBSY 位 为1，则表明可配置时钟输出系统正在工作。只要 CCOBSY 为 1，CCOSEL 位就会被写保护。如果需要，CCO 可自动激活目标振荡器。当所选时钟就绪时，CCORDY 被置位。用户可通过清除 CCOEN 位来禁用时钟输出功能。CCOBSY 位和 CCORDY 位都将保持为 1 直到禁用操作结束。从清除 CCOEN 位到这两个标志位被复位之间的时间可能会很长，例如当所选的输出时钟相对于 fCPU 频率很低时。十一、时钟中断​ 当下列事件发生时，时钟控制器可产生中断：主时钟源切换事件CSS 事件​ 这两个中断均可被独立屏蔽十二、时钟寄存器内部时钟寄存器 CLK_ICKR外部时钟寄存器 CLK_ECKR主时钟状态寄存器 CLK_CMSR主时钟切换寄存器 CLK_SWR切换控制寄存器 CLK_SWCR时钟分频寄存器 CLK_CKDIVR外设时钟门控寄存器1 CLK_PCKENR1外设时钟门控寄存器2 CLK_PCKENR2时钟安全系统寄存器 CLK_CSSR可配置时钟输出寄存器 CLK_CCORCAN外部时钟控制寄存器 CLK_CANCCRHSI时钟修正寄存器 CLK_HSITRIMRSWIM时钟控制寄存器 CLK_SWIMCCR","tags":"硬件拾忆 stm8"},{"title":"STM8S 复位","url":"/article/a27a49c3.html","text":"stm8s 共 9 个复位源：NRST 引脚产生的外部复位上电复位（POR）掉电复位（BOR）独立看门狗复位窗口看门狗复位软件复位SWIM 复位非法操作码复位EMS 复位：当一些关键的寄存器被破坏或错误加载时产生的复位一、复位电路复位引脚 NRST 内部集成了弱上拉电阻 RPU，既可作为输入，也可作为开漏输出。一个在复位引脚上宽度最小为 500ns 的低电平脉冲即可产生一个外部复位。对于复位的检测是异步进行的，因此即使 MCU 处于停机（Halt）模式，也有可能进入复位状态。复位引脚也可以作为开漏输出用于对外部设备进行复位。无论内部复位源是什么，一旦复位，内部复位电路都会产生一个至少脉宽为 20us 的复位脉冲。当没有外部复位发生时，内部弱上拉电阻可保证复位引脚处于高电平。二、内部复位源除了 POR 和 BOR，每个内部复位源在复位状态寄存器中都有一个标志位与之相对应。复位时，根据导致复位的复位源，这些标志位被分别设置。因此，这些标志位可用于指示引起最后一次复位的复位源。通过软件写 1 可清除标志位。1、上电复位（POR）和掉电复位（BOR）上电期间，POR 保持设备处于复位状态，直到供电电压（VDD 和 VDDIO）到达 BOR 的启动电压。此时，BOR 复位取代 POR，POR 自动关闭。BOR 复位一直持续到供电电压到达工作电压。当工作电压降到们限制 VIT- 以下时，BOR 也将产生一个复位，此后 POR 模块将重新准备好以响应下一次上电复位。电压迟滞用以保证清楚地检测电压的上升和下降。即使是 MCU 处于低功耗模式，BOR 也总是保持激活状态。2、非法操作码复位为了提高设备的可靠性，防止意外行为的发生，使用了非法操作码检测系统。如果一个被执行的代码与任意操作码或预置字节均不相符，则产生一个复位。此功能与看门狗相配合，可是设备从一个意外错误或干扰中恢复。一个有效的预置字节与一个有效的操作码组成的一个非法的组合将不会产生复位。3、EMS 复位为了避免由电磁干扰造成的对应用程序误写操作或系统挂起，大多数关键寄存器都有一个互补寄存器与之相对应。系统将会自动检测这些关键寄存器与其互补寄存器之间是否匹配。如果不匹配，则产生一个 EMS 复位，从而使应用程序恢复到正常操作。","tags":"硬件拾忆 stm8"},{"title":"STM8S 供电","url":"/article/5806842a.html","text":"STM8 MCU 有 4 种相对独立的供电电源：- VDD&#x2F;VSS：主电源（3V 到 5.5V）- VDDIO&#x2F;VSSIO：I&#x2F;O 口供电电源（3V 到 5.5V ）- VDDA&#x2F;VSSA：模拟部分供电电源- VREF+&#x2F;VREF-：ADC 参考电源VDD&#x2F;VSS 引脚用来为内部主稳压器（MVR）和内部低功耗稳压器（LPVR）供电。这两个调节器的输出连在一起，向MCU的核（CPU，Flash 和 RAM）提供 1.8V 电压。在低功耗模式下系统自动从 MVR 切换到 LPVR，以减少电流消耗。为了稳定 MVR，必须在 VCAP 脚接一个电容。根据封装的大小，可能有一对或两对特定的 VDDIO&#x2F;VSSIO 来给I&#x2F;O供电。VDDA&#x2F;VSSA和VREF+&#x2F;VREF- 都与ADC模块相连接。","tags":"硬件拾忆 stm8"},{"title":"STM8S 中断控制","url":"/article/f86689bf.html","text":"ITC 简介硬件中断管理大多数 I&#x2F;O 口都具有外部中断能力，有专用的中断向量，每个端口都可以设置边沿检测方式（上升&#x2F;下降）。外设中断能力软件中断能力（TRAP）使用复杂中断优先级和等级管理的嵌套或并发中断管理最多 4 个软件可编程的嵌套等级最多 32 个由硬件固定的中断向量2 个不可屏蔽事件：RESET，TRAP1 个不可屏蔽的最高级硬件中断（TLI）中断管理基CPU 的 CCR 寄存器的 l1 和 l0 位软件优先级寄存器（ITC_SPRx）复位向量地址 0x008000 在程序存储器的起始位置。在有 boot ROM 的器件中，复位初始化程序由 STMicroelectronics 编程在 ROM 中。固定的中断向量地址位于存储器地址映射的高地址（0x00 8004 到 0x00 807C），按硬件优先级顺序排列。中断屏蔽和处理流程中断屏蔽由 CCR 寄存器的 l1 和 l0 位和设置每个中断向量的软件优先级等级的 ITC_SPRx 寄存器管理。当一个中断请求必须被响应时：1、正常的过程被暂停在当前指令执行的最后一条。2、PC，X，Y，A 和 CCR 寄存器入栈。3、CCR 寄存器的 l1 和 l0 位根据 ITC_SPRx 寄存器中相应的中断向量的值置位。4、PC 然后载入中断的中断向量，以响应中断，取指中断服务函数的第一条指令。中断服务函数应该以IRET指令结束，这条指令使得保存的寄存器值从栈中恢复。IRET 指令也会是 l1 和 l0 从栈中恢复，同时程序恢复正常执行过程。如果中断屏蔽位 l0 和 l1 在中断服务函数（ISR）中被使用 SIM 指令置位，使用 RIM 对中断屏蔽进行移除将造成软件优先级被设置为 0 级。为了在中断服务函数中使能或禁止中断时恢复正确的优先级，遵循 Table 8 中的步骤来使能或禁止中断。一、服务挂起中断几个中断可以同时被挂起。下一个要处理的中断由以下两步操作决定：1、最高软件优先级的中断被响应。2、如果几个中断的软件优先级相同，硬件优先级最高的中断首先响应。当一个中断请求没有被立即响应的时候，它将被锁存，并在软件优先级和硬件优先级相结合为最高优先级的时候进行处理。注意：1、硬件优先级是独一无二的，而软件的不是。这允许只有一个中断的时候能继续先前的过程。2、在判定过程中，RESET，TLI 和 TRAP 被认为拥有最高软件优先级。二、中断源STM8中断控制器安排了两种中断源类型。- 非可屏蔽中断：RESET，TLI 和 TRAP- 可屏蔽中断：外部中断或内部外设触发的中断非可屏蔽中断源在处理非可屏蔽中断源时，忽略 CCR 寄存器的 l1 和 l0 的状态。PC，X，Y，A 和 CCR 寄存器只有在一个 TRAP 中断发生时入栈。然后，相应的中断向量载入 PC 寄存器，CCR 寄存器的 l1 和 l0 设置为禁止中断。● TRAP（非可屏蔽软件中断）​ 当 TRAP 指令执行时，这个软件中断源得到响应。它和 TLI 一样根据 Figure 13 的流程图来响应。​ TRAP 中断不允许处理器从 Halt 模式下退出。● RESET​ RESET 中断源拥有 STM8 最高等级的软件和硬件优先级。这意味着在复位程序的开始，所有的中断都会被禁止。它们必须被 RIM 指令重使能。​ RESET 中断允许处理器从 Halt 模式下退出。● TLI（顶级硬件中断）​ 这个硬件中断发生在在的 TLI 输入端检测到一个特定的边沿时。​ TLI 服务函数中必须使用一个 TRAP 指令。可屏蔽中断源如果可屏蔽中断被使能，而且如果它自己在 ITC_SPRx 寄存器中的中断软件优先级比当前正在响应的中断（CCR 寄存器中的 l1 和 l0）高，该可屏蔽中断向量源开始响应。如果这两个条件之一没有满足，中断将被锁存并挂起。外部中断外部中断可被用来从 Halt 模式下唤醒 CPU。器件对外部中断的边沿敏感性可通过外部中断控制寄存器（EXTI_CRx）进行软件选择。当连接到同一个中断线的几个输入引脚同时被选择时，他们是逻辑或的关系。当外部电平触发中断被锁存时，如果给定的电平在中断程序的最后依然保持时，中断保持激活，除非它在程序中被禁止。外设中断大多数外部中断能将 MCU 从 Halt 模式下唤醒。当外设状态寄存器中的一个特定的标志位置位，并且外设控制寄存器中相应的使能位置位时，发生一个外设中断。​中断和低功耗模式所有中断都能使处理器从 wait 模式中退出。只有外部中断及其他特殊中断允许处理器从 halt 和 active-halt 模式下退出。当从 halt 模式下唤醒又同时有几个中断挂起时，第一个响应的中断只能是一个能从 halt 模式退出的中断。它由 Figure14 中给出的过程精确选择。如果最高优先级的挂起中断不能将器件从 halt 模式中唤醒，将会响应下一个中断。如果 HALT 指令执行时发生了任意内部或外部中断（例如定时器），HALT 指令会被执行完但是在 HALT 指令完成之后中断会立即调用唤醒机制。这样，MCU 实际上是从 halt 模式唤醒到 run 模式，相应的延迟参考 datasheet 中的 tWUH。活跃等级&#x2F;低功耗模式控制MCU 的活跃等级通过编程 CFG_GCR 寄存器中的 AL 位来配置。这一位用来控制 MCU 的低功耗模式。在非常低功耗的应用中，MCU 的大部分时间花在 WFI，并且在特殊时刻（通过中断）来唤醒以执行特殊任务。这些再发任务中，有一些非常短，可以直接在中断服务函数（ISR）里执行，而不用回到主函数中。对于这种情况，可以在进入低功耗模式以前（同过执行 WFI 指令）将 AL 置位，然后中断函数直接返回到低功耗模式。由于寄存器上下文只保存在第一个中断中，run time&#x2F;ISR 指令相应缩减。因此，在非常简单的应用中，所有操作都可以在 ISR 中执行。在更复杂的应用中，一个中断函数可以通过复位 AL 位来重新启动主函数。例如，一个应用可能需要每隔 50ms 由自动唤醒单元（AWU）来唤醒，以检查一些引脚&#x2F;传感器&#x2F;按键的状态。大部分时间，当这些引脚未激活时，MCU 可以返回到低功耗模式而不运行主函数。如果这些引脚的其中之一激活，ISR 将通过复位 AL 位来启动主函数。并发和嵌套中断管理STM8 器件的特色之一是有两个中断管理模式：- 并发模式- 嵌套模式一、并发中断管理模式在这以模式下，所有中断都是 3 级优先级，所以它们都不能被中断，除了 TLI，RESET 或 TRAP。硬件优先级按照下面的从低到高的顺序给出：MAIN，IT4，IT3，IT2，IT1，IT0，TRAP&#x2F;TLI（优先级相同），RESET。二、嵌套中断管理模式：在这个模式下，可以在中断函数中嵌套中断。只要有一个中断优先级低于 3 级，这个模式就会被激活。硬件优先级按下面的从低到高的顺序给出：MAIN，IT4，IT3，IT2，IT1，IT0，TRAP。每一个中断向量都可以通过设置相应的 ITC_SPRx 寄存器的 l1_x 和 l0_x 位，来配置软件优先级。l1_x 和 l0_x 位与 CCR 寄存器的 l1 和 l0 位的意义相同。不能编程为等级 0（l1_x &#x3D; 1，l0_x &#x3D; 0）。在这种情况下，将保持先前存储的值。例如，如果先前的值为 0xcf，编程值等于 64h，结果是 44h。RESET 和 TRAP 向量没有软件优先级。当其中一个被响应时，CCR 寄存器的 l1 和 l0 位都会置位。注意：如果中断 x 被执行时，l1_x 和 l0_x 位被修改，器件会进行以下操作：如果中断 x 仍然挂起（新的中断或标志位没有清除）且新的软件优先级比先前的一个高，那么中断 x 将重新进入。否则，中断优先级将保持不变直到下一个中断请求（在中断 x 的 IRET 之后）。在一个中断函数执行期间，HALT，POPCC，RIM，SIM 和 WFI 指令会改变当前的软件优先级，直到下一个 IRET 指令或前面提到的指令之一被发出。警告：可能会发生栈溢出，而不通知软件这个错误。外部中断五个中断向量专用于外部中断事件：PA 口有 5 个中断线：PA[6:2]PB 口有 8 个中断线：PB[7:0]PC 口有 8 个中断线：PC[7:0]PD 口有 7 个中断线：PD[6:0]PE 口有 8 个中断线：PE[7:0]除了 20 脚封装的器件可以使用一个备用功能重映射操作位在 PC3 脚上获得 TLI，其他器件的 PD7 是最高级中断源（TLI）。为了触发一个中断，相应的 GPIO 端口必须配置成有中断功能的输入模式。中断的边沿敏感性必须由 EXTI_CR1 和 EXTI_CR2 寄存器配置。中断指令ITC（中断控制）和EXTI（外部中断）寄存器一、CPU 状态码寄存器中断位（CCR）l[1:0]：软件中断优先级位这两位表示当前中断请求的软件优先级。当一个中断请求发生时，相应中断的软件优先级从软件优先级寄存器（ITC_SPRx）自动载入。l[1:0] 位也可以使用 RIM，SIM，HALT，WFI，IRET 或 PUSH&#x2F;POP 指令来软件清空。TLI，TRAP 和 RESET 时间可以中断一个 3 级的程序。二、软件优先级寄存器 x（ITC_SPRx）由软件写入，来定义每一个中断向量的软件优先级。ITC_SPR1 的 [1：0] 位由硬件强制置 1（TLI）ITC_SPR8 的 [7：4] 位由硬件强制置 1禁止写入 10（优先级 0），如果写入 10，将保持原来的值，且中断优先级不会改变。三、外部中断控制寄存器 1（EXTI_CR1）四、外部中断控制寄存器 2（EXTI_CR2）五、ITC 和 EXTI 寄存器映射和复位值","tags":"硬件拾忆 stm8"},{"title":"STM8S Flash 程序存储器和数据 EEPROM","url":"/article/52dc6b9c.html","text":"介绍stm8 内部的 FLASH 程序存储器和数据 EEPROM 由一组通用寄存器来控制。用户可以使用这些寄存器来编程或擦出存储器的内容，设置写保护，或者配置特定的低功耗模式。用户也可以对器件的选项字节（Option byte）进行编程。术语块 Block —— 一个块是指可由一个简单编程操作变成或擦除的一组字节。块级的操作非常快，是标准的编程和擦除操作。页 Page —— 一页由一组块组成。stm8s 器件拥有启动代码，程序代码和数据 EEPROM，这些区域都有特定的结构所保护。通过对特定的选项字节进行操作，这些区域的大小能够以页为单位来进行调整。Flash 主要特性stm8s EEPROM 分为两个存储器阵列：最多至 128K 字节的 FLASH 程序存储器，不同的器件容量有所不同。最多至 2K 字节的数据 EERPOM（包括option byte），不同器件容量不同。编程模式：字节编程和自动快速字节编程（没有擦除操作）字编程块编程和快速块编程（没有擦除操作）在编程&#x2F;擦除操作结束时和发生非法编程操作时产生中断读同时写（RWW）功能。该特性并非所有 stm8s 器件都有。在应用编程（IAP）和在线编程（ICP）能力。保护特性：存储器度保护（ROP）基于存储器存取安全系统（MASS 密钥）的程序存储器写保护基于存储器存取安全系统（MASS 密钥）的数据存储器写保护可编程的用户启动代码区域（UBC）写保护在待机（Halt）模式和活跃待机（Active-halt）模式下，存储器可配置为运行状态和掉电状态。存储器组织结构1、stm8s 和 stm8af 存储器组织结构stm8s 和 stm8af 的 EEPROM 以 32 位字长（每字 4 字节）为基础组织起来。根据不同的器件，存储器组织结构有所不同：小容量 stm8s 和 stm8af 器件：8K Flash 程序存储器，每页（或块）64 字节，共 128 页（或块）。分为 2 个区域，大小可由选项字节配置的 user boot code 区（UBC），和主程序存储区。FLash 程序存储器地址映射在 stm8s 地址空间的最上端，且包括复位和中断向量。最多 640 字节数据 EEPROM，每页（或块） 64 字节，共 10 页（或块） 。有一个块（64 字节）中包含 11 个用来配置器件硬件特性的选项字节。选项字节可在 user，IAP 和 ICP&#x2F;SWIM 模式下编程。中容量 stm8s 和 stm8af 器件：从 16K 到 32K Flash 程序存储器，每页 4 个 128 字节的块，最多 64 页。Flash 程序存储器分为 2 个区， 大小可由选项字节配置的 user boot code 区（UBC），和主程序存储区。FLash 程序存储器地址映射在 stm8s（或 stm8af）地址空间的最上端，且包括复位和中断向量。最多1K 字节数据 EEPROM，每页 4 个 128 字节的块，最多 2 页。有一个块（128字节）中包含 13 个用来配置器件硬件特性的选项字节。选项字节可在 user，IAP 和 ICP&#x2F;SWIM 模式下编程。大容量 stm8s 和 stm8af 器件：从 32 到 128K 字节 Flash 程序存储器，每页 4 个 128 字节的块，最多 256 页。Flash 程序存储器分为 2 个区， 大小可由选项字节配置的 user boot code 区（UBC），和主程序存储区。FLash 程序存储器地址映射在 stm8s（或 stm8af）地址空间的最上端，且包括复位和中断向量。最多 2K 字节数据 EEPROM，每页 4 个 128 字节的块，最多 4 页。有一个块（128 字节）中包含 15 个用来配置器件硬件特性的选项字节。选项字节可在 user，IAP 和 ICP&#x2F;SWIM 模式下编程。EEPROM 存取时间决定了器件最多运行在 16MHz 下。对于时钟频率超过 16MHz 的应用，FLash&#x2F;数据 EEPROM 存取必须被被配置成等待状态（1 wait state）。这由器件选项字节使能。2、存储器存取&#x2F;等待状态配置Flash&#x2F;数据EEPROM 存取时间允许器件运行在最高 16MHz 时钟下，无需等待状态。当使用高速外部时钟（HSE）在更高的最多 24MHz 下时，需要一个等待状态。在这种情况下，器件应该对选项字节进行编程以插入这个等待状态。3、用户启动区域（UBC）UBC 包含有复位和中断向量表，它可用于存储 IAP 及通信程序。UBC 有一个两级保护结构可保护用户代码及数据在 IAP 编程中免于无意的擦除或修改。这意味着该区域总是写保护的，而且写保护不能通过使用 MASS 密钥来解锁。在 ICP 模式下（使用 SWIM 接口）可以通过修改选项字节来配置 UBC 的大小。UBC 选项字节指定了分配在 UBC 中的页的数量。UBC 区域的歧视地址是 0x8000。可以通过读取 UBC 选项字节来获得 UBC 区域的大小。前两页的 128 个字节包含了 32 个中断向量。4、数据 EEPROM（DATA）数据 EEPROM（DATA）区域可用于存储用户具体项目所需的数据。默认情况下，DATA 区域是写保护的，这样可以在主程序工作在 IAP 模式时防止 DATA 区域被无意地修改。只有使用特定的 MASS 密钥才能对 DATA 区域的写保护解锁。5、主程序区域主程序区是 Flash 程序存储器中用于存储应用代码的区域。6、选项字节（Option bytes）选项字节用于配置硬件特性和存储器保护状态，这些字节位于同一页的特定存储器阵列中。选项字节可以再 ICP&#x2F;SWIM 模式中或 IAP 模式中修改，注意此时要保证 FLASH_CR2 中的 OPT 位为 1 以及 FLASH_NCR2 中的 NOPT 位为 0。对选项字节的编程参考 STM8 SWIM 通讯协议和调试模块用户手册 UM0470。存储器保护1、读保护当选项字节中的 ROP 字节被编程为 0xAA 时，读保护就生效了。这种情况下，无论写保护是否生效，在 ICP 模式中（使用 SWIM 接口）读取或修改 FLASH 程序存储器和 DATA 区域都是被禁止的。即使认为没有什么保护是完全不可破解的，对于一个通用微处理器来说，stm8 的读保护的特性也提供了一个非常高水平的保护级别。取消写保护可以在 ICP 模式中通过对选项字节中的 ROP 字节重新编程来接触程序存储器、UBC 和 DATA 区域的读保护。在这种情况下，程序存储器、UBC、DATA 区域以及选项字节都被自动擦除，器件也可以被重新编程了。2、存储器存取安全系统（MASS）在复位以后，主程序和 DATA 区域都被自动保护以防止无意的写操作。在试图修改其内容前必须对其解锁，而解锁的机制由存储器存取安全系统（MASS）来管理。UBC 区域的特性指明了在 UBC 中的内容一直是写保护的。一旦存储器内容被修改完毕，推荐将写保护使能以防止数据被破坏。对主程序存储器的写保护在器件复位后，可以通过向 FLASH_PUKR 寄存器连续写入两个被叫作 MASS 密钥的值来解除主程序存储器的写保护。这两个写入 FLASH_PUKR 的值回合一下两个硬件密钥值相比较：第一个硬件密钥：8’b01010110（0x56）第二个硬件密钥：8’b10101110（0xAE）需要通过如下步骤来解除主程序存储器区域的写保护：1）向 FLASH_PUKR 写入第一个 8 位密钥。在系统复位后，当这个寄存器被首次写入值时，数据总线上的值没有被直接锁存到这个寄存器中，而是和第一个硬件密钥值（0x56）相比较。2）如果密钥输入错误，FLASH_PUKR 寄存器在下一次系统复位之前将一直被锁住。在下一次复位前，再向该寄存器进行的任何写操作都会被系统忽略掉。3）如果第一个硬件密钥正确，当这个寄存器被第二次写入值时，数据总线上的值没有被直接锁存到这个寄存器中，而是和第二个硬件密钥值（0xAE）相比较。4）如果密钥输入错误，FLASH_PUKR 寄存器在下一次系统复位之前将一直被锁住。在下一次复位前，再向该寄存器进行的任何写操作都会被系统忽略掉。5）如果第二个硬件密钥正确，主程序存储器写保护被解除，同时 FLASH_IAPSR 中的 PUL 位为 1。在开始编程之前，应用程序可以校验 PUL 为是否被有效置 1。应用程序可以再任意时刻通过清 PUL 位来重新禁止对 DATA 区域的写操作。对DATA区域的写操作在器件复位后，可以通过向FLASH_DUKR寄存器连续写入两个被叫作MASS密钥的值来解除主程序存储器的写保护。这两个写入FLASH_PUKR的值回合一下两个硬件密钥值相比较：第一个硬件密钥：8’b01010110（0x56）第二个硬件密钥：8’b10101110（0xAE）需要通过如下步骤来解除数据区域的写保护：1）向FLASH_DUKR 写入第一个 8 位密钥。在系统复位后，当这个寄存器被首次写入值时，数据总线上的值没有被直接锁存到这个寄存器中，而是和第一个硬件密钥值（0x56）相比较。2）如果密钥输入错误，应用程序可以尝试重新输入这两个 MASS 密钥来对 DATA 区域进行解锁。3）如果第一个硬件密钥正确，当这个寄存器被第二次写入值时，数据总线上的值没有被直接锁存到这个寄存器中，而是和第二个硬件密钥值（0xAE）相比较。4）如果密钥输入错误，DATA EEPROM 区域在下一次系统复位之前将一直保持写保护状态。在下一次复位前，再向该寄存器进行的任何写操作都会被系统忽略掉。5）如果第二个硬件密钥正确，DATA 区域的写保护被解除，同时 FLASH_IAPSR 中的 DUL 位为 1。在开始编程之前，应用程序可以校验 DUL 为是否被有效置 1 来确认DATA区域已经将写保护解锁。应用程序可以再任意时刻通过清 DUL 位来重新禁止对 DATA 区域的写操作。3、对选项字节的写操作​对选项字节的写操作的步骤和对 DATA EEPROM 的操作大致相同。但是要注意到 FLASH_CR2 中的 OPT 位要为 1 以及 FLASH_NCR 中的 NOPT 位要为 0，这样才可以对选项字节进行写操作。存储器编程在尝试任何编程操作之前，必须对主程序寄存器和 DATA 区域解锁。1、读同时写（RWW）RWW 特性允许用户在执行程序和读程序存储器时对 DATA EEPROM 区域进行写操作，因此执行的时间被优化了。相反的操作是不允许的：不可以在写程序寄存器时对 DATA EEPROM 进行读操作。RWW 特性是一直有效的而且可以在任意时刻使用。并不是所有 stm8 器件都有 RWW 特性。2、字节编程可以对主程序存储器和 DATA 区域逐字节地编程。要对一个字节编程，应用程序可直接向目标地址写入数据。在主程序存储器中​ 当字节编程操作执行时，应用程序停止运行。在DATA区域中​ 有 RWW 功能的器件： 在 IAP 模式下，应用程序不停止运行，字节编程利用 RWW 功能进行操作。​ 无 RWW 功能的器件：当字节编程操作执行时，应用程序停止运行。要擦除一个字节，向对应的字节简单写入 0x00 即可。应用程序可以通过读 FLASH_IAPSR 寄存器来校验编程或擦出操作是否已被正确执行：在一次成功的编程操作后 EOP 位被置 1。当软件试图对一个被保护的页进行写操作时 WP_PG_DIS 位被置 1。在这种情况下，写操作不会被执行。如果 FLASH_CR1 中的 IE 位已经被预先使能，则只要这些标志位（EOP&#x2F;WP_PG_DIS）中有一个被置位就会产生一个中断。自动快速字节编程根据目标地址的初始化内容的不同，编程持续时间可能也有所不同。如果字（4 个字节）中包含不为空的字节，在编程前整个字节会被自动擦除。相反，如果字为空，由于不会执行擦除操作从而编程时间变短（参考 tPROG）。然而，可以通过对 FLASH_CR1 中的 FIX 位置 1 来强迫执行系统擦除操作而不管其内容是否为空，从而使编程时间固定（参考 FLASH 控制寄存器）。编程总时间随之被规定位擦除时间和写操作时间的和。为了快速写一个字节（没有擦除操作），将要被写入数据的整个字（4 个字节）必须被预先擦除。因此不可能对同一个字做连续两次快速写操作（在第二次写之前没有擦除操作）：第一次写字节操作将是快速操作但针对另外一个字节的第二次写操作将需要一个擦除操作。3、字编程字写入操作允许一次对整个 4 字节的字进行编程，从而将编程时间缩短。主程序存储器和 DATA EEPROM 都可以进行字操作。在一些 stm8s 器件中，也拥有当 DATA EEPROM 在进行写操作时同时具备 RWW 功能。为了对一个字编程，FLASH_CR2 和 FLASH_NCR2 中的 WPRG&#x2F;NWPRG 位必须预先置位&#x2F;清零来使能字编程模式。然后将要被编程字的 4 个字节必须被从首地址开始装载。当四个字节都被写入后，编程周期自动开始。像字节操作一样，FLASH_IAPSR 中的 EOP 与 WR_PG_DIS 控制位和 FLASH 中断相配合，可用于检查操作是否被正确执行完毕。4、块编程块编程比字节编程和字编程都要快。在块编程操作中，整个块的编程或擦除在一个编程周期就可以完成。在主程序存储器和 DATA 区域都可以执行块操作。在主程序存储器中​ 用于块编程的代码必须全部在 RAM 中执行。在 DATA 区域中​ 有 RWW 功能的器件：DATA 块操作可在主程序存储器中执行，然而数据装载阶段必须在 RAM 中执行。​ 无 RWW 功能的器件：用于块编程的代码必须全部在 RAM 中执行。​一共有三种可能的块操作：块编程（也叫标准块编程）：整个块在编程前被自动擦除快速块编程：在编程前没有预先的块擦除操作。块擦除。在块擦除时，中断被硬件自动屏蔽。标准块编程块编程操作允许一次对整个进行编程，整个块在编程前被自动擦除。为了对整个块编程，FLASH_CR2 和 FLASH_NCR2 中的 PRG&#x2F;NPRG 位必须预先置位&#x2F;清零来使能标准块编程。然后需要向主程序存储器或 DATA 区域的目标地址依次写入要编程的数据，这样数据会被锁存在内部缓存中。为编程整个块，块中的所有字节都需要被写入数据。但要注意，所有被写入缓存的数据必须位于同一个块中，这意味着这些数据必须有同样的高位地址：仅仅低 6 位的地址可以不一样。当目标块的最后一个字节被装载到缓存后，编程就自动开始了。编程前首先会自动执行一次擦除操作。当对 DATA 区域进行块编程时，应用程序可以检查 FLASH_IAPSR 中的 HVOFF 位确认编程状态。一旦 HVOFF 被置 0，真正的编程阶段就开始了，此时应用程序就可以返回到主程序中去了。FLASH_IAPSR 中的 EOP 与 WR_PG_DIS 控制位和 FLASH 中断相配合，可用于检查操作是否被正确执行完毕。快速块编程快速块编程允许不擦除存储器内容就对块进行编程，因此快速块编程速度是标准块编程的两倍。该模式仅用于被编程部分已经被擦除过的情况，同时这种模式对向空白部分写入完整的应用代码特别有用，因为这种模式可以节省相当可观的时间。快速块编程的步骤和标准块编程的步骤大致一样，FLASH_CR2 和 FLASH_NCR2 中的 FPRG&#x2F;NFPRG 位必须预先置位&#x2F;清零来使能快速块编程。FLASH_ISPSR 中的 EOP 与 WR_PG_DIS 控制位和 FLASH 中断相配合，可用于检查快速块编程操作是否被正确执行完毕。警告：在执行快速块编程之前如果这个块不是空的话，不能保证写入的数据无误。块擦除块擦除允许擦除整个块。为了擦除整个块，FLASH_CR2 和 FLASH_NCR2 中的 ERASE&#x2F;NERASE 位必须预先置位&#x2F;清零来使能块擦除。通过对块中所有的字写入 0x00 00 00 00 来擦除整个块。字的起始地址必须以 0，4，8 或 C 作为结尾。FLASH_IARSR 中的 EOP 与 WR_PG_DIS 控制位和 FLASH 中断相配合，可用于检查操作是否被正确执行完毕。5、选项字节（Option byte）编程对选项字节编程和对 DATA EEPROM 区域编程非常相似。应用程序可直接向目标地址进行写操作。利用 stm8 的 RWW 功能，在对选项字节写操作的同时程序不必挺下来。ICP 和 IAP在线编程（ICP）用于更新整个存储器的内容。ICP 使用 SWIM 接口把用户的程序装载到微控制器中，同时提供迅速而有效的设计迭代并且去除了不必要的封装处理和器件插槽。SWIM 接口（单线接口模块）使用 SWIM 引脚和编程工具相连接。相对于 ICP 方式，在应用编程（IAP）可使用 stm8 支持的任意通讯接口（I&#x2F;O、I2C、SPI、UART…）来下载要编入存储器中的数据。IAP 允许在应用程序运行中对 FLASH 程序存储器的内容重新编程。然而要想使用 IAP，必须通过 ICP 对 FLASH 程序存储器预先编程。stm8 FLASH 编程手册 RM0051，stm8 SWIM 通信协议和调试模块用户手册 UM0470。FLASH寄存器FLASH控制寄存器1（FLASH_CR1）FLASH控制寄存器2（FLASH_CR2）FLASH互补控制寄存器2（FLASH_NCR2）FLASH保护寄存器（FLASH_FPR）FLASH保护寄存器（FLASH_NFPR）FLASH程序存储器解保护寄存器（FLASH_PUKR）DATA EEPROM解保护寄存器（FLASH_DUKR）FLASH状态寄存器（FLASH_IAPSR）","tags":"硬件拾忆 stm8"},{"title":"STM8S Memory and register map","url":"/article/1c2bfc5d.html","text":"存储器映射、I&#x2F;O 端口硬件寄存器映射和 CPU&#x2F;SWIM、调试模块&#x2F;中断控制寄存器的详细内容参见 datasheet。存储器映射各部分具体上限（upper limit）参看 datasheet。stm8s stack handling 栈处理stm8s 和 stm8af MCU 的栈在 user RAM 区实现。栈底所在的地址大于栈顶所在的地址。不是所有器件都有 roll-over limit 回卷限制。用户必须注意初始化栈指针。通常由开发工具（linker file）生成的初始化代码来正确加载这个指针，默认初始化到 RAM 尾地址。有些器件中，栈回卷限制为一个固定地址。如果使用 push 操作或为子函数或中断函数保存上下文时，栈指针减小到栈回卷限制处，栈指针将复位到 RAM 尾地址。当栈指针正参与运算时，不会回卷。Customized stack model 自定义栈模型stm8s 和 stm8af 的栈指针操作允许执行一个自定义的栈模型。这就使得栈的大小变得灵活，而不用受到栈回卷限制的约束。执行自定义栈也有利于寄存器配置不同的器件的软件可移植性。并不是所有器件都有栈回卷限制。保护单元（guard cells）是必须被应用程序连续轮询检测是否发生栈溢出的 RAM 位置。在这个模型中，初始的栈指针必须指向超过栈回卷限制的位置（必须必回卷限制的地址小）。因此，增长的栈永远不会到达回卷限制。很明显，这样的操作下，栈大小不会受到溢出机制的限制。虽然如此，用户必须在 link file 中定义栈的位置和栈的大小，也必须确保栈指针不会超出定义的栈区域（栈顶溢出或低于栈底）。超过或在自定义栈之下的 RAM 位置可以被常规的用作 RAM 来存储变量或其他信息。保护单元可以被配置在比栈顶更低的位置以检测是否栈指针超过了规定的边界。这些单元是标准的 RAM 位置，初始化为固定值，一旦发生溢出，栈将在这里重写。用户软件可以常规轮询这些单元，检测溢出条件，并将应用置于故障保护状态。在软件有效期内，硬件断点可被设在栈的两个极端位置，以确认栈溢出和欠载都没有发生。寄存器描述缩写","tags":"硬件拾忆 stm8"},{"title":"STM8S Boot ROM","url":"/article/fc6550d2.html","text":"stm8s Boot ROM 是用于系统启动的只读存储器。在某些 STM8 型号中有 2K 字节的内部 Boot ROM，其中包含有用于启动的代码。这段代码的主要作用是利用 STM8 的 SPI，CAN 或 UART 接口，将应用程序代码，数据，选项字节（Option Byte）和中断向量表下载到内部的 FLASH 和 E2RPOM 中去。执行的自举加载工作在 LIN 模式下，另一种引导装载程序通信协议在 UART2&#x2F;UART3 和 UART1 中执行。复位后，启动代码开始执行。更多详细内容参考 STM8 启动代码用户手册 UM0560。","tags":"硬件拾忆 stm8"},{"title":"STM8S CPU","url":"/article/bda8d4cb.html","text":"stm8s 是基于 8 位框架结构的微控制器CPU 内核有 6 个内部寄存器指令集支持 80 条基本语句，20 种寻址模式了解 stm8s 指令集参考 PM0044CPU寄存器（共 6 个）1、累加器（A）8 位通用寄存器，用于保存算术运算、逻辑运算以及数据操作的操作数及结果。2、索引寄存器（X 和 Y）都是 16 位寄存器，可实现高效率的寻址模式。可用作数据操作的暂存器以及用于乘除法这样的操作。大多数情况下，交叉汇编器会在使用了 Y 寄存器的指令代码中生成 PRECODE 指令，用以和使用了 X 寄存器的指令相区别。3、程序计数器（PC）24 位寄存器，用于存储 CPU 下一条要执行指令的地址。每一次指令操作后其内容自动刷新。最大寻址范围 16M 字节。4、堆栈指针（SP）16 位寄存器，其内容位堆栈中下一个可自由分配的单元地址。根据不同的型号，堆栈指针的高位会有一个指定的预设值。堆栈一般用于在中断调用或子程序调用时存储 CPU 的上下文（程序计数器，关键寄存器，相关函数的参数及局部变量等）。用户可以通过 POP 和 PUSH 指令直接对堆栈操作。SP 可以被 C 编译器的启动代码初始化，C 语言应用程序会根据用户所使用的包含绝对地址信息的链接文件来进行初始化。如果用户使用了自己编写的链接文件和启动代码，请确认 SP 被恰当地初始化（具体地址参考相应手册）。在 MCU 复位后，或执行了堆栈复位指令后（RSP），堆栈指针被设为其被允许的最大值。对于使用了汇编语言的应用程序，用户可使用 ST 提供的启动代码或编写自己的启动代码来对 SP 进行正确的初始化。入栈操作使堆栈指针值减小，出栈增加。当堆栈指针值为其被允许的最小值时，继续入栈会使堆栈指针值回卷至最大值，从而导致先前数据被覆盖，但此时没有中断或硬件标志位来指示该事件发生。子程序调用会占用 2 或 3 字节空间。中断调用会占用 9 字节空间来存储内部寄存器（除 SP 之外）。WFI&#x2F;HLAT 指令会预先保存 CPU 上下文。如果 CPU 出于 WFI 或 HALT 状态下有中断发生，则进入中断所需的延时会响应减少。5、条件代码寄存器（CC）​ 8 位寄存器，用于指示刚被执行的指令结果及处理器的状态。寄存器的第 6 位（0）是保留位，这些位可以被用户程序或代码单独测试，测试结果可用于指示程序或代码执行后的状态。（1）V：溢出​ 在上一次有符号数的算术操作中，如果结果的最高位有溢出发生，该位置 1。可参考 INC，INCW，DEC，DECW，NEG，NEGW，ADD，ADDW，ADC，SUB，SUBW，SBC，CP，CPW 等指令。（2）l1：中断屏蔽级别 1​ 与 l0 共同指示当前状态下 CPU 的可中断性。l1 和 l0 也会在 CPU 进入中断服务程序时被硬件自动设置为该中断对应的中断级别。（3）H：半进位​ 执行 ADD 或 ADC 操作的过程中，当 ALU 的第 3 位和第 4 位见发生进位时，H 位会被置 1，对于 BCD 码算术运算很有意义。（4）l0：中断屏蔽级别 0（5）N：负数​ 上一次的算术、逻辑或数据操作的结果是负的情况下，N 位被置 1（6）Z：零​ 上一次的算术、逻辑或数据操作的结果是负的情况下，N 位被置 1（7）C：进位​ 上一次的算术操作中，如果结果的最高位发生进位或借位，则该位置 1。当执行位测试，分支，移位，旋转和加载指令时，该位也会受到影响。参考 ADD，ADC，SUB，SBC 等指令。​ 在除法操作中，C 位用来指示在指令执行中是否有错误发生（商溢出或 0 作除数）。参考 DIV 指令。​ 在位测试操作中，被测试的位被复制到 C 位。参考 BTJF，BTJT 指令。在移位和旋转操作中，C 位根据结果进行相应地更新。参考 RRC，RLC，SRL，SLL，SRA 指令。​ 用户还可以通过 SCF，RCF，CCF 指令对 C 位进行置位，清除和取反。stm8s 入栈出栈顺序：（入栈和出栈都需要 9 个 CPU cycles）中断发生（中断从发生到响应之间有 1~6 个 CPU cycles 的延迟）PUSH PCL（8bit，1 CPU cycles） （PCL 在栈中地址较高）PUSH PCH（8bit，1 CPU cycles ）PUSH PCE（8bit，1 CPU cycles ）PUSH Y（16bit，2 CPU cycles ）PUSH X（16bit，2 CPU cycles ）PUSH A（8bit，1 CPU cycles ）PUSH CC（8bit，1 CPU cycles ）（CC 在栈中地址较低）跳转至中断向量指向的中断函数执行中断函数POP CCPOP APOP XPOP YPOP PCEPOP PCHPOP PCL （共9个CPU cycles）跳转至PC寄存器指向的地址stm8 CPU 寄存器映射​ CPU 寄存器在 STM8 的地址空间映射如上表，只有 CPU 的调试模块才可以使用这些寄存器的地址对其操作，在 CPU 核内执行的指令只能通过直接使用寄存器名才可以读写这些寄存器。全局配置寄存器（CFGGCR）地址偏移值 0x00复位值 0x00","tags":"硬件拾忆 stm8"},{"title":"UVa1583（DigitGenerator）解决思路","url":"/article/251da63b.html","text":"问题描述如果x加上x的各个位数字之和得到y，就说x是y的生成元；给出n（1≤n≤100000），求最小生成元。无解输出0。例如，n&#x3D;216，121，2005时的解分别为198 , 0, 1979。题目分析本题核心部分在于判断是否存在小于给定数字的一个数字，其本身与其各位数字之和等于给定数字，并不复杂。由于输入数字范围并不大，因此可以考虑用事先计算好范围内所有数字的最小元，然后通过查表的方式输出。而且建立查找表的过程也很简单，不需要计算生成元，而是从小到大遍历数值范围一遍，将数字与各位数值相加，便可作为生成元存放到对应的表中。另外，也可以每次都直接根据输入值来计算其生成元，省去了存放查找表的内存开销，但是每次都要重新计算。如果每次计算是用暴力方法遍历计算，会导致时间溢出，因此可根据题目的特点进行优化：由于生成元的数值本身加上各位数值即为输入数字，因此，根据输入数字的数量级，生成元最多比输入数值小 9x6&#x3D;54（其实是9x5&#x3D;45）。因此在求解生成元时，无需从 1 开始遍历，只需从比输入数值小 50 的数值开始遍历即可。至于输入小于 50 的情况也无需考虑，只是在负数的地方浪费了一点时间，不会影响平均时间复杂度。解法一：查表1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;#define MAXM 100005int ans[MAXM];int main()&#123; int t, n; memset(ans, 0, sizeof(ans)); for(int m=1; m&lt;MAXM; m++)&#123; int x=m, y=m; while(x&gt;0)&#123; y += x%10; x /= 10; &#125; if(y&gt;MAXM) continue; if(ans[y]==0 || m&lt;ans[y]) ans[y] = m; &#125;// for(int i=1; i&lt;MAXM; i++)&#123;// printf(&quot;%7d %7d\\n&quot;, i, ans[i]);// &#125; scanf(&quot;%d&quot;, &amp;t); while(t--)&#123; scanf(&quot;%d&quot;, &amp;n); printf(&quot;%d\\n&quot;, ans[n]); &#125; return 0;&#125;解法二：暴力枚举1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; int t, n; scanf(&quot;%d&quot;, &amp;t); while(t--)&#123; scanf(&quot;%d&quot;, &amp;n); int x = 0; int sum = 0; int ans = 0; for(int i=n-50; i&lt;n; i++)&#123; x = i; sum = x; while(x&gt;0)&#123; sum += x%10; x /= 10; &#125; if( sum == n)&#123; ans = i; break; &#125; &#125; printf(&quot;%d\\n&quot;, ans); &#125; return 0;&#125;","tags":"算法"},{"title":"MSP430 仿真与下载","url":"/article/3a830286.html","text":"对于 MSP430 来说，无论仿真还是烧写程序一般可以通过：JTAG、SBW、BSL 接口进行。JTAG、SBW 接口可以用于仿真接口，BSL 接口不能用于仿真。而编程器则三种接口都支持。所以并不能说 JTAG 只支持仿真不支持编程，这是概念错误，JTAG 仅仅是一种接口协议而已。J-TAG 6线SBW 2线BSL 2线（UART）下面简单描述一下三种接口的区别：1、JTAG 是边界扫描技术，其在 430 内部有逻辑接口给 JTAG 使用，内部有若干个寄存器连接到了 430 的内部数据地址总线上，所以可以用JTAG访问 430 内部的所有资源，包括对 FLASH 的读写操作。所以可以用于对 MSP430 的仿真及编程。主要连接线有 TMS、TCK、TDI、TDO、RST、TEST。2、SBW 是 SPY-BI-WIRE，可以简称两线制 JTAG，主要用 SBWTCK（连接到 JTAG 仿真器的 7 脚 TCK）与 SBWTDIO（连接到 JTAG 仿真器的 1 脚 TDO&#x2F;TDI），该接口主要用于小于 28 脚的 2 系列的 430 单片机，因为 28 脚以内的 2 系列单片机的 JTAG 接口一般与 IO 口复用，为了给用户预留更多的 IO 口，才推出了 SBW 接口。同样 SBW 接口可以用于仿真器及编程器。3、BSL 是 TI 在对 MSP430 出厂时预先固化到MCU内部的一段代码，有点类似 bootloader，但又与 bootloader 有明显的区别，BSL 只能用于对 MCU 内部的 FLASH 访问，不能对其他的资源访问，所以只能用作编程器接口。BSL 通过UART协议与编程器连接通信。编程器可以发送不同的通信命令来对 MCU 的存储器做不同的操作。BSL 的启动有些特殊，一般 430 复位启动时 PC 指针指向 FFFE 复位向量，但可以通过特殊的启动方式可以使 MCU 在启动是让 PC 指向 BSL 内部固化的程序。启动方式一般是由 RST 引脚与 TEST（或TCK）引脚做一个稍复杂的启动逻辑后产生。 BSL 启动后，就可以对 MCU 进行访问了。一般的 MCU 都有代码加密功能，430 是如何实现的呢？外部对 430 内部的代码读写只能通过上述的三种方式，所以又引入了熔丝位，熔丝位只存在于 JTAG、SBW接口逻辑内。BSL内部没有熔丝。当熔丝烧断时（物理破坏，且不可恢复）JTAG 与 SBW 的访问将被禁止，此时只有 BSL 可以访问。而通过 BSL 对 MCU 的访问是需要 32 个字节的密码，该密码就是用户代码的中断向量表。所以 430 的加密系统到目前为止尚无被解密的报告。一般个人学习用，不熔丝操作，只有成熟产品推向市场的时候，防止被其他人破解，才会熔丝。仿真器的型号一般有 UIF（USB 接口，支持 JTAG、SBW）、PIF（并口，只支持 JTAG）、EZ430（USB 接口的，只支持 SBW 模式）。专业编程器有 GANG430（串口、一拖 8 个，支持 JTAG、SBW，不支持 BSL）；多功能编程器（JTAG、SBW、BSL）。这些编程器都可以做离线烧写，即脱离计算机来对目标板烧写。","tags":"硬件拾忆 msp430"},{"title":"MSP430 中断系统","url":"/article/5d740b09.html","text":"中断是 MSP430 的一大特色，因为几乎每个外设模块都能产生中断，MSP430 可以在没有任务时进入超低功耗状态，有事件时中断唤醒 cpu，处理完毕再次进入超低功耗状态。整个中断的响应过程是这样的，当有中断请求时，如果 cpu 处于活动状态，先完成当前命令；如果处于低功耗，先退出，将下一条指令的 pc 值压入堆栈；如果有多个中断请求，先响应优先级高的；执行完后，等待中断请求标志位复位，要注意，单中断源的中断请求标志位自动复位，而多中断的标志位需要软件复位；然后系统总中断允许位 SR.GIE 复位，相应的中断向量值装入 pc，程序从这个地址继续执行。这里要注意，中断允许位 SR.GIE 和中断嵌套问题。如果当你执行中断程序过程中，希望可以响应更高级别的中断请求时，必须在进入第一个中断时把 SR.GIE 置位。其实，其他的外围模块时钟沿着时钟和中断这个核心来执行的。具体的结构我也不啰嗦了，可以参考 MSP430 系列手册。MSP430 中断格式1234567#pragma vetcor = 中断向量__(两个)interrupt void 函数名(void)&#123; //中断函数无返回值 无形参 用户程序;&#125;","tags":"硬件拾忆 msp430"},{"title":"MSP430 时钟系统","url":"/article/1f6ae1c8.html","text":"系统时钟是一个程序运行的指挥官，时序和中断也是整个程序的核心和中轴线。MSP430 最多有三个振荡器：DCO：内部数字控制振荡器，它的频率可以通过 DCOCLK 进行配置。在系统 PUC 之后，DCOx&#x3D;7，MODx&#x3D;3。在系统 PUC 之后，SMCLK 与 MCLK 都以 DCO 作为时钟源，震荡频率在 1.1M 左右，ACLK 以 LFXT1 作为时钟源，工作在 LF 模式下内部 6pF 的负载电容。LFXT1：可接高速和低速晶振，在低速模式下，它可以外接 32k 的晶振而不需要负载电容，在单片机内部已经集成了几个电容供选择。同时，通过寄存器进行配置，它还可以接内部的 VLOCLK，这个晶振是一个 12k 的低速晶振。高速模式下它可以接 0.4~16M（有的是 8M） 的晶振。通常将 LFXT1 配置成一个 32k 的振荡源，为 ACLK 提供低速的时钟信号。XT2：高速振荡器，它可以接一个 0.4~16M（有的是 8M） 的晶振，需要外接电容，它相当于高速模式下的 LFXT1。通常将它配置成一个高速的振荡源，为 MCLK 和 SMCLK 提供高速时钟信号。经验发现，接 XT2 时，需要注意自己开启 XT2，并延时 50us 等待 XT2 起振，然后手工清除 IFG1 中的 OFIFG 位，其操作顺序为：打开 XT2 -&gt; 等待 XT2 稳定 -&gt; 切换系统时钟为 XT2。MSP430 有三种时钟信号：MCLK 系统主时钟，可分频1 2 4 8，供 cpu 使用，其他外围模块在有选择情况下也可使用；SMCLK 系统子时钟，供高速外设使用，可选择不同振荡器产生的时钟信号；ACLK 辅助时钟，只能由 LFXT1 产生，供低速外设使用。DIVS0~DIVS1：DIVS&#x3D;0,1,2,3 对应 SMCLK 的分频因子为 1,2,4,8SELS：选择 SMCLK 的时钟源，0：COCLK；1：XT2CLK&#x2F;LFXTCLKDIVM0~1：选择 MCLK 的分频因子DIVM&#x3D;0,1,2,3：对应分频因子为 1,2,4,8SELM0~1：选择 MCLK 的时钟源，0, 1：COCLK, 2：XT2CLK, 3：FXT1CL其它：1、LFXT1：一次有效的 PUC 信号将使 OSCOFF 复位，允许 LFXT1 工作，如果 LFXT1 信号没有用作 SMCLK 或 MCLK，可软件置 OSCOFF 关闭 LFXT1。2、XT2：XT2 产生 XT2CLK 时钟信号，如果 XT2CLK 信号没有用作时钟 MCLK 和 SMCLK，可以通过置 XT2OFF 关闭 XT2，PUC 信号后置 XT2OFF，即 XT2 的关闭的。3、振荡器失效时，DCO振荡器会自动被选做 MCLK 的时钟源。如果 DCO 信号没有用作 SMCLK 和 MCLK 时钟信号时，可置SCG0 位关闭 DCO 直流发生器。4、在 PUC 信号后，由 DCOCLK 作为 MCLK 的时钟信号，根据需要可将 MCLK 的时钟源另外设置为 LFXT1 或 XT2，设置顺序如下：&lt;1&gt; 清 OSCOFF&#x2F;XT2。&lt;2&gt; 清 OFIFG。&lt;3&gt; 延时等待至少 50us。&lt;4&gt; 再次检查 OFIFG，如果仍置位，则重复(1)-(4)步，直到 OFIFG&#x3D;0 为止。&lt;5&gt; 设置 BCSCTL2 的相应 SELM。注意：&lt;1&gt; 最好将 IFG1&amp;&#x3D;~OFIFG; 放入 do-while 循环中&lt;2&gt; 在 XT2 出现错误的情况下将 XT2 设定为 MCLK SMCLK 的时钟源，单片机会自动的把时钟源更换为 DCO 振荡器。当时钟信号丢失 50us 时，振荡器失效。如果 MCLK 信号来自 LFXT1 或者 XT2，那么 MSP430 自动把 MCLK 的信号切换为 DCO，这样可以保证程序继续运行。MSP430 不对低频模式的 LFXT1 进行监测。&lt;3&gt; BCSCTL2&#x3D;SELM_2+SELS; 语句必须放在 while 之后，因为当 XT2 没有起振之前，XT2 处于错误阶段，因此在 XT2 没有起振之前将它设定为主时钟与子系统时钟后，单片机会自动的将 DCO 设定为 SMCLK MCLK 的时钟源。","tags":"硬件拾忆 msp430"},{"title":"2018 随笔","url":"/article/9517d5c7.html","text":"12.29编造的历史于作者和读者都有益，但于真相和真理无益。12.26笛卡尔用坐标系帮我们打开了数学世界的大门，也把我们牢牢束缚在了看不见的坐标系中。帮我们认识了三维世界，也把我们困在了三维世界中。12.17减少知识记忆，提高创新能力和复杂事物沟通能力。当下一个爱因斯坦诞生的时候，我们能不能听懂他的话？12.16西方民主是一种产物，而不是其他事物的原因。12.08多折腾事，少折腾人。11.27靠想象力创造是件好事，但是靠想象力说话就算了。11.24一见如故易，再见如初难。很少有人会选择多米诺骨牌式的人生 —— 用尽一生去码牌，只为了最后推倒那一刻。11.15摩擦力的存在，让我们用了很长时间才认识到运动的本质规律，如果不存在摩擦力，动力学的研究工作可能会提早很多年，因为现象与本质都显而易见了。有些事物的表象与根因相去甚远，甚至看起来毫无联系，这也正是科研探索的难点和乐趣所在。当你选择了走捷径，这条捷径有可能就成了你唯一的路。11.13干一行爱一行的根本原因是只有干好了，才会感兴趣。11.13一千年后，古代 APP 在古玩市场交易火热。。。11.03大学那会的加分条，是不是就和快递单上的“此人是国家栋梁，请优先配送”一个道理。11.02表达者的宿命是被误会。10.30可喜的是，今天阳光明媚，难过的是，这太阳是 8 分钟前的。10.29藏弓早，借剑难。10.26从来不学习的天才，以及没有天分的学习者，都不能成为大师。10.25真正的隐士，都是入世的强者。10.22只学了如何相遇，没有学如何告别。很多时候快乐只不过是被多巴胺和荷尔蒙欺骗而产生的错觉，并不是真正的快乐，只是化学过程的搬运工。10.21雪中不送炭，锦上别添花。09.25君子不立危墙之下。09.24目的通常是复合的。09.23许多所谓的规格，无非是成年社会为了省心而承袭的惯性。怕就怕，坐在井底还闭着眼。09.23余生漫长，你不要慌。09.22善弈者通盘无妙手。善战者无赫赫之功，善医者无煌煌之名。09.08成熟的重要标志之一是知道什么时候动脑，什么时候动心。09.05投机者都在所谓的创新领域，因为这里的东西好抄。08.29在光的眼里，我们是什么样？08.28一些整天不说话的职业非常容易导致个体情绪激动。不是时间约束了我们，而是我们约束了时间。没有认识到玻璃的重要性，是几百年前中国与西方拉开差距的重要原因。08.21吾生有涯而（小）知无涯08.12每一次发明时光机之后的世界都不存在了。08.06远见超出能力的时候，再去做管理。07.27思考是找答案，学习是找问题。07.20素人一本书，大师一句话。07.19努力不够，朋友圈来凑。07.17聪明人需要笨功夫，不够聪明的需要走捷径。07.15有缘相会，无缘幸会。07.13你必须非常努力，才能知道自己是真的不行。07.10奴性是社会组成的一部分。07.09朋友圈三日可见 —— 士别三日当刮目相待。07.08除掉恶龙最好的办法就是不唤醒心中的恶龙。正确答案闪闪发光，我选择视而不见。不敢发火，怕点着肚子里的草，不过也无所谓，毕竟有脑子里的水。06.28靠经济萧条切入市场的小企业，能在下一次萧条中活下来才是真正有价值的公司。06.28新品牌的崛起很多都是靠用户对老品牌的不满。06.22你看中人家的利息，人家看中你的本金。06.21加班就像借钱， 救急不救穷。06.17慢慢来，是最快的。06.16听从你心，无问西东。06.14民主和专制貌似已无法概括现今的政治制度了。06.12我们这一代很多人的梦想，已经从儿女双全变成猫狗双全了。06.06德不配位，必有灾殃06.03在全是蚊子的房间里，我才是外人。05.31没见过世面的老实人，未必是真老实。05.28物联网的真正崛起，不仅需要 5G 和微电子的崛起，还需要一场世界范围的金融危机。05.27一点就炸，弱者心态。05.21世界第一之前喜欢国外文化那叫崇洋媚外，世界第一之后就叫兼容并包。人在看到他人遭遇无法改变的苦难时，会将苦难合理化，轮到自己时，总会抱怨命运的不公。","tags":"心花路放"},{"title":"MSP430 串口","url":"/article/bcaeaef6.html","text":"MSP430 常见的 USART（universal synchronous&#x2F;asynchronous receive&#x2F;ransmit）接口通常有三种：UART、IIC、SPI。其中 UART（串口）是调试过程中最常用的接口，这里根据 User’s Guide 谈谈 MSP430x1xx 系列串口的使用。在 UART 一章的开始，有这样一段文字：可见，在 X14X 和 X16X 中，有两组串口，而 X12X 、X13X 和 X15X 中只有 UART0。使用不同型号，务必先查看手册中的资源介绍。一、Introduction本节一开始，有这样一段话：说明了UART提供两个接口：UTXD（发送）和URXD（接收），使用时只需要这两个引脚就可以与其他串口设备通信，但要注意的一点是，除了这两个引脚的连接外，两设备还必须共地，也就是说他们的GND也要连在一起，这是两设备成功通信的关键！接下来介绍了该模块的特性：值得关注的几点是：1、430 UART 的发送和接收移位寄存器都是独立的2、发射和接收缓冲器是分离的，这一点不同于 51 单片机3、低位优先发送和接收二、Operation发送和接收使用相同的波特率。PUC（上电清除）或SWRST置位会导致USART复位。1、上电复位后各位状态上面这段话给出了上电后，各标志位的初始状态：1）USART 自动置位（置1）2） URXIEx、UTXIEx、URXIFGx、RXWAKE、TXWAKE、RXERR、BRK、PE、OE 和 FE 复位（置0）3） UTXIFGx、TXEPT 置位4） URXEx 和 UTXEx 不受影响清除 SWRST 将允许操作 USART。2、初始化或重配置顺序1）SWRST 置位（置1）2）在 SWRST&#x3D;1 的前提下初试化各个 USART 寄存器3）通过 MEx 特殊功能寄存器使能 USART 模块4）软件清除 SWRST（置0）5）通过 IEx 特殊功能寄存器使能中断3、字符格式起始位 – 7 或 8 位数据位 – 地址位 – 奇偶校验位 – 1 或 2 位停止位。由波特率寄存器设置。4、异步通信格式双机通信时，使用空闲总线模式。多机通信时，支持空闲总线模式和地址位处理模式。1）空闲总线多处理机模式（MM&#x3D;0）两个数据块之间隔了一个大于 10 个时钟的空闲时间，而数据块内的数据之间的间隔小于 10 个时钟。在前一个字符的的第一个停止位之后又接收了 10 或者更多连续的时钟后，将检测接收总线。当使用 2 个地址位时，第二个地址位将作为空闲周期的第一个标志。一个空闲周期之后的第一个接收到的数据是地址字符。RXWAKE 位用来标志每个数据块的地址位。空闲总线模式下，当接收到地址并且传送至 UxRXBUF 时，该位将置位。URXWIE 位用来控制数据接收。当该位置位时，所有的非地址字符被收集，但是不移送至 UxRXBUF 中，也不触发中断。接收到地址字符时接收器将暂时激活将字符传送至 UxRXBUF 中并且置位 URXIFGx 中断标志。任何满足条件的错误标志位也将置位。用户可以验证接收地址。如果接收到一个地址字符，用户可以软件验证地址，并且必须复位 URXWIE 以保证继续接收数据。如果保持置位，将只接收地址字符。URXWIE 位不会由硬件自动修改。在空闲总线模式下，可以由 USART 产生一个精准的空闲周期去产生 UTXDx 中的地址字符标志符来传送地址。WUT 暂时唤醒标志是一个由用户可访问的TXWAKE位双缓存的内部标志。当发送器从 UxTXBUF 中载入数据，WUT 也从 TXWAKE 中载入，并复位 TXWAKE。以下步骤可以传送一个空闲帧表明后面是地址字符：1&gt; 置位 TXWAKE，然后向 UxTXBUF 写入任意字符。UxTXBUF 必须准备好接收新字符（UTXIFGx &#x3D; 1）。TXWAKE 值移入 WUT，当 UxTXBUF 准备好接收新数据时，UxTXBUF 的内容被移入发送移位寄存器。这将置位WUT，抑制正常传输中的起始位、数据位、奇偶校验位。然后发送大约十一位的空闲周期。当使用两个地址位时，第二个地址位将作为空闲周期的第一个标志。TXWAKE 自动复位。2&gt; 向 UxTXBUF 中写入所需地址字符。UxTXBUF 必须准备好接收新字符（UTXIFGx &#x3D; 1）。在 UTXDx 的地址标志空闲周期之后，代表了特殊地址的新字符被发出。必须向 UxTXBUF 写入第一个任意字符，这是为了将 TXWAKE 位移入 WUT 并触发空闲总线条件。这个数据并不重要，也不会出现在 UTXDx 上。2）地址位多处理机模式（MM&#x3D;1）每个数据包含一个额外的位用于地址表示。数据块中的第一个字符带有一个置位的地址位表明这个字符是地址。当接收到字符是一个有效的地址字符且被移入 UxRXBUF 中，USART 的 RXWAKE 位将被置位。URXWIE 位用来控制数据接收。当该位置位时，数据字符（地址位&#x3D;0）将被接收器接收但不送入 UxRXBUF 并且不触发中断。当收到一个包含了地址位置位的字符时，接收器暂时唤醒将字符传送到 UxRXBUF 并将 URXIFGx 置位。所有满足条件的状态错误标志也会被置位。如果接收到一个地址，用户必须软件复位URXWIE以保证继续接收数据。如果 URXWIE 保持置位，值有地址字符（地址位&#x3D;1）可以倍接收。URXWIE 位不会有 USART 硬件自动改变。在地址位模式下发送地址数据时，一个字符的地址位可以通过写入 TXWAKE 位来控制。TXWAKE 位的值将被载入从UxTXBUF 传送到移位寄存器的字符的地址位，然后自动清除 TXWAKE 位。TXWAKE 不能软件复位，它将在传送至 WUT 或被 SWRST 置位后有 USART 硬件清零。3）自动错误检测参看User’s Guide。5、USART接收使能从状态转移图可以清楚的看出 URXEx 对接收的影响。6、USART发送使能​当 UTXEx 置位时，UART 发送器使能。向 UxTXBUF 写入数据将发起发送。数据将在 TX 移位寄存器置空的下一个 BITCLK 被送进去，然后发送开始。当 UTXEx 位复位时发送终止。任何移入 UxTXBUF 的数据和任何正在发送移位寄存器中进行的数据发送，若先于清空 UTXEx 的操作，都将继续进行发送，直到所有的数据发送完毕。当发送器被使能（UTXEx&#x3D;1），数据不应该被写入 UxTXBUF，除非 UxTXBUF 已经准备好接收新数据，表现为 UTXIFGx&#x3D;1。如果 UxTXBUF 中的数据在它将被送至发送寄存器时被修改，这一扰乱将导致错误的发送。完成所有发送后，发送器需要关闭（UTXEx&#x3D;0），表现为发送器清空标志位置位（TXEPT &#x3D; 1）。在发送器关闭时，任何写入 UxTXBUF 的数据都将被保存在缓冲器中，但是不会移入发送移位寄存器或者被发送。一旦 UTXEx 被置位，发送缓存里的数据立即被载入发送移位寄存器中，而且数据发送重新开始。7、UART波特率产生USART 波特率发生器是由不标准的时钟频率产生标准的波特率。波特率发生器使用一个预定标器&#x2F;除法器和一个调制器。这个组合为波特率发生器提供小数除数因子。USART 的最大波特率是 UART 时钟频率 BRCLK 的三分之一。波特率配置常数及误差：8、USART中断USART有一个发送中断向量和一个接收中断向量。1）发送中断操作发送器置位 UTXIFGx 中断标志位，表明 UxTXBUF 准备好接收另一个字符。如果 UTXIEx 和GIE 置位，也会触发一个中断请求。若中断请求得到响应或者一个字符写入 UxTXBUF，UTXIFGx 将自动复位。UTXIFGx 在 PUC 之后或 SWRST&#x3D;1 时都会被置位。2）接收中断操作每次接收到一个数据并载入 UxRXBUF 都会置位 URXIFGx 中断标志。如果 URXIEx 和 GIE 置位，也会触发一个中断请求。URXIFGx 和 URXIEx 会在系统复位信号 PUC 之后或 SWRST&#x3D;1 时复位。若悬而未决的中断得到响应（当 URXSE&#x3D;0）或者当 UxRXBUF 被读取时，URXIFGx 将自动复位。URXEIE 用来使能或关闭置位 URXIFGx 造成的错误字符。在使用地址位模式时，URXWIE 用来自动检测有效的地址字符和拒绝不需要的数据字符。两种字符不能置位 URXIFGx：当 URXEIE&#x3D;0 时的错误字符，当 URXWIE&#x3D;1 时的非地址字符。当 URXEIE&#x3D;1 一个 break 条件将置位 BRK 位和 URXIFGx 标志。3）接收起始边沿检测操作URXSE 位使能接收起始边沿检测特性。当 BRCLK 由 DCO 提供，以及当 DCO 因为低功耗模式而关闭时，推荐使用接收开始边沿特性。DCO 的超快振荡允许在起始边沿检测之后接收字符。当 URXSE，URXIEx 和 GIE 置位，并且一个起始边沿出现在 URXDx，内部信号 URXS 将会置位。当 URXS 置位，将会触发一个接收中断请求，但 URXIFGx 不会置位。用户在接收中断服务程序中可以检测 URXIFGx 来判断中断源。当 URXIFGx&#x3D;0，检测起始边沿；当 URXIFGx&#x3D;1，接收一个有效的字符（或 break）。当中断服务函数判断中断请求来自起始边沿，用户软件触发 URXSE，而且必须从中断服务函数中返回有效的模式或一个 BRCLK 激活的低功耗模式，以使能 BRCLK。如果中断服务函数返回到一个 BRCLK 未激活的低功耗模式，字符不能被接收。触发 URXSE 清除 URXS 信号并将为未来的字符重新使能起始边沿检测。当前激活的 BRCLK 允许 USART 接收字符。接收完一个字符并送入 UxRXBUF 之后，URXIFGx 将置位，并请求一个中断服务。在中断服务函数入口，URXIFGx&#x3D;1 表明接收到一个字符。当用户软件读取 UxRXBUF 时 URXIFGx 标志被清除。当使用接收边沿检测时，若BRCLK关闭，将不能检测到break条件。4）接收起始边沿检测条件当 URXSE&#x3D;1 时，故障将抑制阻止 USART 被意外启动。URXDs 的任何一个比抗尖峰脉冲时间（大约300ns）短的低电平都会被 USART 忽视而不会触发中断请求。当一个故障时间长于抗尖峰脉冲时间，或一个有效的起始位出现在 URXDx，USART 接收将启动，且会进行一个多数投票。如果多数投票认为没有检测到的不是起始位，将会中断字符接收。如果字符接收中断，就没有必要激活 BRCLK。软件可以通过一个比字符接收持续时间长的延时周期来表明没有在预期周期内接收到字符，且软件可以关闭 BRCLK。三、Registers寄存器详细内容参考相应手册。","tags":"硬件拾忆 msp430"},{"title":"MSP430 IO","url":"/article/477c7c8d.html","text":"注意事项上电后寄存器状态为输入高电平。改变 PxOUT 或 PxDIR 时 PxIFG 标志将置位。向 PxIES 写入数据将导致相应的中断标志置位。只置位 PxSELx 不能自动设置引脚方向。其他外设模块需要跟据模块功能配置 PxDIRx，改变引脚方向。开启外部中断时，要先设置 OUT、DIR、IES，然后复位 IFG，最后开中断。 msp430x14x、x15x、x16x的 P1、P2 口具有中断能力。未使用的IO引脚应配置成IO功能，输出方向，并连接在PCB板上，以降低功耗。PxOUT位的值无所谓，因为其引脚未连接。未使用的引脚的正确连接方式：MSP430 IO 特点独立的可编程 IO同组 IO 口输入输出任意组合P1、P2 中断独立配置输入输出数据寄存器独立一、输入寄存器 PxINBit &#x3D; 0 ： 输入为低Bit &#x3D; 1 ： 输入为高PxIN是只读寄存器，执行写入指令将增加电流消耗。二、输出寄存器 PxOUTBit &#x3D; 0 ： 输出为低Bit &#x3D; 1 ： 输出为高三、方向寄存器 PxDIRPxDIR 的每一位用来选择相应引脚的方向，无论选择了什么第二功能。如果 IO 开启了第二功能，必须根据需要来设置相应的方向。Bit &#x3D; 0 ： 输入方向Bit &#x3D; 1 ： 输出方向四、功能选择寄存器 PxSEL端口引脚经常复用作其他内部外设模块功能。PxSEL 的每一位决定了引脚用作 IO 功能还是内部外设模块功能（第二功能）。Bit &#x3D; 0 ： IO功能Bit &#x3D; 1 ： 内部外设功能只置位PxSELx不能自动设置引脚方向。其他外设模块需要跟据模块功能配置 PxDIRx，改变引脚方向。PxSEL 置位时，中断关闭。当引脚作为外设的输入时，输入到外设的信号在因脚伤经过一次锁存。当 PxSELx&#x3D;1 时，内部输入信号跟随引脚上的输入信号。若 PxSELx&#x3D;0，输入到外设的信号将维持引脚上的输入信号的值，直到 PxSELx 位重置。P1、P2 口可中断的器件通过配置 PxIFG、PxIE 和 PxIES 寄存器，P1 和 P2 口的每个引脚都能具有中断能力。所有的 P1 口引脚都使用一个单独的中断源，所有的 P2 引脚使用另一个单独的中断源。可以检测 PxIFG 来判断 P1 或 P2 中断。五、中断标志位寄存器 P1IFG，P2IFG选择的输入信号边沿出现在引脚上时，相应的中断标志会置位。相应的 PxIE 以及 GIE 置位后，所有 PxIFGx 中断标志都需要一个中断响应。PxIFG 必须由软件复位。软件也可以置位PxIFG，提供一种软件触发中断的方法。Bit &#x3D; 0 ： 无中断请求Bit &#x3D; 1 ： 中断请求只有跳变能触发中断，而稳定的电平不能。如果任意 PxIFGx 在中断服务程序中置位，或者在中断服务程序执行 RETI 命令之后置位，PxIFGx 标志位将触发另一个中断。这样确保了每一个跳变得到响应。改变 PxOUT 或 PxDIR 时 PxIFG 标志将置位。任何外部中断时间都应该至少是 MCLK 的 1.5 倍，以保证单片机能检测到并且中断标志置位。六、中断边沿选择寄存器 P1IES，P2IESPxIES 用来选择中断 IO 引脚的中断边沿。Bit &#x3D; 0 ： 由低向高的跳变置位 PxIFGxBit &#x3D; 1 ： 由高向低的跳变置位 PxIFGx向 PxIES 写入数据将导致相应的中断标志置位。PxIESxPxINxPxIFGx0→10May be set0→11Unchanged1→00Unchanged1→01May be set七、中断使能寄存器P1IE，P2IEBit &#x3D; 0 ： 中断关闭Bit &#x3D; 1 ： 中断使能","tags":"硬件拾忆 msp430"},{"title":"MSP430 单片机入门指北","url":"/article/53f9a99d.html","text":"在介绍 MSP430 的学习方法前，先简略介绍一下MSP430 吧。MSP430 系列单片机是美国 TI 公司 1996 年开始推向市场的一种 16 位超低功耗、具有精简指令集（RISC）的混合信号处理器（Mixed Signal Processor）。MSP430 单片机（后面简称 430）称之为混合信号处理器，是由于其针对实际应用需求，将多个不同功能的模拟电路、数字电路模块和微处理器集成在一个芯片上，以提供“单片机”解决方案。该系列单片机多应用于需要电池供电的便携式仪器仪表中。其基本特性为：处理能力强（16 位 RISC），运算速度快（含硬件乘法器），超低功耗，片内资源丰富，开发方便等。下面开始谈 430 的学习。之所以推荐大家学完 51 之后学习 430 而不是 ARM 或 STM32，不是因为大家不能学后者，而是因为在大家将要参加的很多竞赛中，常常要求低功耗，而这正是 430 的一大长处。而且，即便学完了 51，大家的程度也只停留在学过而不是学会 51。不信大家可以扪心自问，谁学 51 的时候看过单片机的芯片手册？是不是照书上的例程写的，或者从网上找个例程然后改编？这样的学习还是很粗浅的，只能让大家入个门。在实际项目开发中，我们经常会走捷径，直接拿别人的代码来用。但是在学习阶段，我们必须掌握独立完成代码的技能，只有这样，才是一个合格的开发者。学习一款单片机，我们并不是为了学习这一种单片机的开发，而是为了掌握通用的单片机的开发技术，因此，我们不能为了学 430 而学 430，那样学完了还是只会用 430，甚至只会用这一种型号的 430。而事实上，市面上的单片机种类繁多，同一种单片机又分为好多种型号。如果只会用一种固定型号的单片机，可以说几乎没什么用。所以，学习 430 的时候，我们是在学习 16 位单片机的开发，甚至为接触 32 位、64 位处理器打下坚实的基础。单片机的学习，不可避免的要购买开发板。因为只靠软件仿真而不看现象，一来不可靠，二来提不起兴趣。但是买开发板时随之附带的海量资料往往又让我们望而却步。其实，学习430 开发，除了在开始阶段学习一些软件的使用或者下载方法需要用到资料外，剩下的路完全可以自己走。而写这篇文档，也是为了帮助大家走好这条路。刚说了路可以自己走，但是旅途中还是需要一些水啊，食物啊，拐杖啊之类的基本物品的。这些就是我们 430 自学之路的可靠战友。下面就让我们的战友们闪亮登场：战友一：所学型号的 User’s Guide：直接翻译过来就是《用户指南》，就好像旅游的时候拿一本旅游指南一样，重要性自己想。战友二：所学型号的 Datasheet：直接翻译过来就是《数据手册》，里面记载了芯片的内部模块分布与连接，以及各管脚的电气特性。在使用 IO 口时，其作用尤为重要。战友三：所学型号的详细引脚图：可以看引脚位置，更重要的是查看第二功能。其实 Datasheet 里就有，但是为了使用方便，最好单独截图出来放在外边。战友四：所学型号的库文件（其实是头文件）这个其实是在IDE中查看比较方便。像TI官方出的 CCS，可以通过 ctrl+ 鼠标左键直接访问头文件。头文件中大部分是对各个寄存器的各个位的宏定义，它们让我们的编程更方便和直观。上面的都是最最核心的战友，多看看 TI 官方出的 Application Note，也是很有帮助的。那么我们如何利用好这些可靠的战友资源呢？不妨边了解它们的资源，边学习如何利用。一、User’s Guide​ 430 的 User’s Guide 通常都是按系列给出，因为好多型号内部资源大同小异，这样也避免了过多的工作量。如果我们是拿 MSP430F149 或者 F169 来进行学习，那么只需要看MSP430x1xx Family User’s Guide 就可以。​ 打开后封面如上图，然而这个并不重要。我们先通过目录了解一下其内部资源：​ 如上图，目录很清楚地列出了该系列 430 的所有内部资源。但是要注意的一点是，由于是按系列给出，所有有些内部资源在有些型号中是没有的。在查看对应章节时，里面会说明哪些型号不含此资源。另外查看 Datasheet 也能知晓该资源有没有，因为 Datasheet 本身就是记录内部资源连接以及电气特性的。不难看出，几乎各章节都有《Introduction》、《Operation》、《Registers》。个别章节还有其他小节。​《Introduction》是通过很短的篇幅整体介绍该模块，同时列出它的特性。​ 《Operation》是具体介绍模块在使用时的配置方式及注意事项。因为有些寄存器的某些位配置以后是会对其他位或寄存器有影响的，所以这里都会具体说明。​ ​ 《Register》则是具体给出各寄存器的每一位的位置，及其功能的详细描述。因此，熟练的编程者在了解了前两节的内容后，以后编程可以直接看这一节。但是前提是前两节里的注意事项你都记住了！否则，将给你的编程及调试带来很多莫名的麻烦。二、Datasheet​ Datasheet 第一页看起来就没有 User’ Guide 封面的逼格那么高了，而与正常芯片的Datasheet 格式大致相同。因为这个本来就是给专业技术人员看的，为了让系统设计更加专业，因此就采用正规的 Datasheet 格式了。而 User’s Guide 写的通俗，是因为它是面向用户的一个指南，而用户专业程度未必很高，所以写的尽量简单易懂。​ Datasheet 中会给出该手册涉及的各个信号的具体引脚图，从图中不仅能查看各引脚的位置，还能知道它们的第二功能，有些高度复用的型号还有第三功能，这是极为重要的。​ ​ 从目录也能看出，哪些型号具有或不具有哪些资源。有时候在编程遇到具体问题时，还是要看看 Datasheet 里具体模块的描述。比如在 AD 采集时，要查看对应引脚的最高输入电压。还有在驱动外围器件时，必须知道对应引脚的最大拉电流、最大灌电流以及外围模块的正常工作电流，才能设计出稳定的系统。​ 这一部分，也就是《input&#x2F;output schematic》是编程中最最常用的。​ 因为这一部分给出了芯片每一个引脚的内部结构，以及相应的寄存器配置，在开启引脚第二功能时，查看这一章节，比从网上搜个程序要快的多也正确的多。奇怪的是，这里的引脚结构并不是按组给出，有的是三五个一组，有的一两个一组，这是因为每个引脚几乎都有第二功能，而且有的还有中断功能，因此其端口电路必然不同，所以就把相似程度较高（而不是完全相同）的几个引脚放在同一组给出。三、引脚图这个就不说了，没啥可说的。图在上一节也贴过了。四、库文件每个可以编译仿真 430 程序的 IDE 都会提供其各种型号的库文件，供用户直接调用。先介绍下常用的 IDE 吧。430 编程中常用的 IDE 是 IAR 和 CCS。其中 CCS 是 TI 官方推出的一款基于 Eclipse 的 IDE， 包含一整套用于开发和调试嵌入式应用的工具。它包含适用于每个 TI 器件系列的编译器、源码编辑器、项目构建环境、调试器、描述器、仿真器以及多种其它功能。其优点是界面人性化，快捷键方便，支持动态语法检查，支持 Grace 图形化界面配置，以及提供 TI 官方例程。缺点是软件功能过于全面带来的冗杂，编译效率低，以及运行和编译时可能崩溃，即不稳定。IAR 是瑞典的IAR公司推出的 C编译器-IAR Embedded Workbench, 支持众多知名半导体公司的微处理器。如 8051、MSP430、STM32、ARM 等。优点是界面简洁，与常见 IDE 风格类似，编译效率高，另外几乎支持各厂商的单片机，在使用其他单片机时不用学习新的 IDE。缺点是编辑快捷键不够便捷，调试时的一些功能不够智能化和直观。下面开始介绍库文件，对于用户来讲其实是相应型号的 .h 文件。如果用 f149 的话，就打开下面的头文件。在 CCS 中，ctrl+ 左键点击上面的 &lt;msp430x14x.h&gt; 就可以打开该文件：#include &lt;msp430x14x.h&gt;如果是 IAR，就在头文件上右键，然后点击 Open “msp430x14x.h”:​ 这样就打开了 &lt;msp430x14x.h&gt; 这一头文件：不同的 IDE 提供的库文件可能内容是不一样的，但是使用方法是一样的。比如，要使用 ADC12 的相关寄存器设置，就在头文件中按快捷键 “ctrl+f”，输入 “ADC12”，然后回车，就会出现相关内容：​ 这些都是 ADC12 的相关寄存器的宏定义，具体使用则要看后面的注释。一般来说注释就能很清楚的表达其功能，如果表达不清楚，再参看 User’s Guide 的《Register》章节即可。在这里简要谈了 430 的学习方法，后面会推出各模块的独立编程方法。我们的目标是参看手册去编程，而不是参看例程去编程。","tags":"硬件拾忆 msp430"},{"title":"Git 与 Github","url":"/article/4cd2af9a.html","text":"〇、Github 与 Git 的关系1、Git 与 Github 简介Git 是一款免费、开源的分布式版本控制系统GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。另外还有其他的平台，如国内的 码云Git 负责本地的代码版本控制，而 Github 负责远程托管2、Git 的工作流程：1）在工作目录（Working Directory）中修改文件。2）暂存文件，将文件的快照放入暂存区域（Staging Area）。3）提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录（Repository）。其中：Git **仓库目录 ** 是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。工作目录 是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。暂存区域 是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作&#96;‘索引’’，不过一般说法还是叫暂存区域。3、Git 与 Github关系图示：一、注册 Github 账号注册没有难度，这里不赘述，建议使用简单大方的用户名和注册邮箱，方便后期使用。网址： Github二、下载安装 Git网址： Git （如果链接打不开可在网上搜索其他下载站点）软件安装也没有什么难度，安装完成之后在任意文件夹下右键出现 Git Bash Here 说明安装成功。在任意文件夹中都可以使用 Git Bash Here，既可以将所有需要代码版本管理的项目放在同一个文件夹中，也可以分散在任意地方，建议前者。关于 Git 的一些资料Reference Manual（可查看各种 Git 指令的说明）Pro Git （Git 的详细介绍）三、安装 Git 后的配置1、如果是个人使用大部分配置可以暂时忽略，仅设置用户名称和邮件地址即可：通过 Git Bash Here 进入命令行界面，输入：git config --global user.name &quot;YourName&quot; （引号不可省略）git config --global user.email YourEmailYourName 和 YourEmail 设置成你 Github 里注册的用户名和邮箱。这里的设置是为了让 Github 根据用户名和邮箱去确定代码上传者的信息，也可以只设置其中一个。2、如果是团队使用若需要设置统一的提交信息格式，可以创建一个模板文件，通过 commit.template 来设置模板文件。也可以通过 core.editor 修改编辑提交信息的默认编辑器。详情都请查看 Reference Manual 中的 自定义 Git - 配置 Git ，也可以输入 git config 自行探索。四、创建自己的代码仓库1、在 Github 上创建 Repository1）点击 Github 页面右上角 “+” 号，点击 New repository2）填写基本信息后，点击 Create repository3）建成的仓库如下图README.md 文件是 markdown 格式的文件，通常用来描述项目信息（可以看看其他人是怎么写的），可以后期自己建立并上传。Github 会显示根目录下的 md 文件内容。如果需要删除代码仓库，点击上图中的 Settings，在页面最下方的 Danger Zone 中有 Delete this repository 按钮。2、在本地建立 Repository添加 SSH keyGithub 的仓库链接有两种格式：https 格式，例如 https://github.com/YourName/YourRepo.gitSSH 格式，例如 &#x67;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#98;&#46;&#x63;&#x6f;&#109;:YourName&#x2F;YourRepo.git两种形式的地址都可以用于 Github 与本地 Git 建立连接，但是如果用的是 https，每次上传代码的时候，都需要输入 Github 用户名和密码，因此建议使用 SSH。生成 SSH key 的步骤：提示： Git Bash 命令行界面中，复制&#x2F;粘贴的快捷键分别是 Ctrl+Ins 和 Shift+Ins1&gt; 在任意文件夹内右击，选择 Git Bash Here，进入命令行界面。2&gt; 输入 ssh-keygen -t rsa -C &quot;YourEmail@YourEmail.com&quot;​ 引号内是 Github 的登录邮箱，引号不能省略。3&gt; 一般不建议修改 SSH Key 的保存目录，因此连按三下回车，选择默认路径以及无密码。从提示信息中可以找到你的电脑上 SSH Key 的保存位置。4&gt; 从 3&gt; 中的保存位置找到 id_rsa.pub 文件，通常路径为 C:\\Users\\Administrator\\.ssh，用记事本或其他编辑软件打开并复制里面的内容。也可以在 Git Bash 命令行界面中输入 clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub 后按回车，若无错误提示表示复制成功。5&gt; 打开 Github，鼠标指向自己的头像，选择 Settings。6&gt; 在左边栏中选择 SSH and GPG keys，点击 New SSH Key，添加复制的 SSH Key 即可。如果个人有多台电脑，为了方便区分，SSH Key 的 Title 取一个辨识度较高的名字。7&gt; Git Bash 命令行界面中输入 ssh -T git@github.com​ 问是否继续连接，输入 yes ，按回车。​ 如果出现 Hi YourName! You&#39;ve successfully authenticated, but GitHub does not ... 说明设置成功了。本地建立 Repository方法一：（git clone 指令）使用 git clone 指令可以直接将 Github 上的代码仓库（可以是新建的，也可以是已经有内容的） clone 到本地仓库。步骤如下：1&gt; 在 Github 页面进入准备 clone 到本地的代码仓库，点击如下图①位置的 Clone or download 即可复制代码仓库链接。注意应使用 SSH 格式的链接，在②位置可以切换两种格式。2&gt; 在欲存放代码的地方进入 Git Bash（不需要自己再建立文件夹），输入 git clone git@github.com:YourName/YourRepo.git（复制的仓库链接），即可完成本地仓库的建立。此时可直接上传新的代码文件至 Github，具体操作见后文。注意：如果选择了 https 格式的地址，想修改成 SSH 格式的地址，可以按照以下步骤操作：git remote rm origin # 移除当前远端服务器git remote -v # 查看当前 Github 仓库服务器地址，无返回信息说明已移除git remote add origin &#103;&#x69;&#116;&#x40;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#99;&#111;&#x6d;:YourName&#x2F;YourRepo.git # 添加 SSH 格式地址git remote -v # 再次查看当前 Github 仓库服务器地址，是否已修改成功方法二：（git init 指令）使用 git init 指令可以在本地初始化一个代码仓库，然后与 Github 上的代码仓库进行连接，操作如下：1&gt; 在欲存放代码的地方建立项目文件夹，进入该文件夹后右击进入 Git Bash，输入 git init，可以看到此时在文件夹中生成了一个隐藏的 .git 文件夹，此文件夹内存放着此代码仓库的各种信息。2&gt; 如果在安装好 Git 后已经配置了用户名和邮箱，此步骤可跳过，否则输入git config --global user.name &quot;YourName&quot; （引号不可省略）git config --global user.email YourEmail3&gt; 输入 git remote add origin git@github.com:yourName/yourRepo.git，依旧建议使用 SSH 格式地址。此时就建立起了与 Github 服务器的连接。在方法一中，由于是直接 clone 远端的 Github 仓库的内容，所以无论是新建的 Github 仓库，还是已经上传过内容的 Github 仓库，都可以完整地克隆到本地。但在方法二中，由于是从本地先初始化了一个代码仓库，仓库中无任何内容，所以如果本地仓库中的内容和 Github 仓库中的内容不一致（例如 Github 仓库初始化时生成了 README.md 文件），就需要先把 Github 仓库中的内容下载（pull）到本地，保持两者的一致性之后，才能上传（push）代码到 Github 仓库，具体操作是输入 git pull origin master ，等代码下载完成，即可添加新内容并上传。五、简单 Git 操作指令1、push 代码到 Github假设要 push 一个名为 123.txt 的文件，在项目文件夹中进入 Git Bash，分别输入以下内容：git add 123.txt # 将文件内容添加到缓存区快照git commit -m &quot;123.txt&quot; # 将改动点记录到代码仓git push origin master # 将改动提交到 Github 远端服务器，分支为 master说明：若一次提交多个文件，可使用 git add . ，注意 “.” 不能省略第二行中引号内的内容是提交信息，会显示在 Github 上，如果需要提交很多信息，输入 git commit 即可，会弹出默认编辑器 GUN nano，如果不会使用该编辑器，可以运行 git config --global core.editor &quot;F：\\Program Files\\Sublime Text 3\\sublime text.exe&quot; ，其中引号中是想修改的新编辑器的路径，根据自己电脑上的位置修改。master 是指该仓库的 master 分支，关于分支的概念请参考 Git 官网。2、从 Github pull 代码git pull origin master3、查看工作目录状态git status以上几个指令是个人使用时最常用的指令，如果多人合作，或 fork 其他人的项目，可以从官网查询其他指令。","tags":"软件使用 github"}]}